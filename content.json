{"meta":{"title":"水聿津","subtitle":"坚持做有价值的输出","description":"","author":"水聿津","url":"https://oxford561.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-30","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"09-30","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"09-30","excerpt":""},{"title":"contact","text":"","path":"contact/index.html","date":"09-30","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"09-30","excerpt":""},{"title":"link","text":"","path":"link/index.html","date":"12-03","excerpt":""},{"title":"friends","text":"","path":"friends/index.html","date":"12-12","excerpt":""}],"posts":[{"title":"C++核心编程","text":"C++核心编程本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。 1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域 **代码区：** 存放 CPU 执行的机器指令 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令 **全局区：** 全局变量和静态变量存放在此. 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ==该区域的数据在程序结束后由操作系统释放==. 示例： &#x2F;&#x2F;全局变量 int g_a &#x3D; 10; int g_b &#x3D; 10; &#x2F;&#x2F;全局常量 const int c_g_a &#x3D; 10; const int c_g_b &#x3D; 10; int main() &#123; &#x2F;&#x2F;局部变量 int a &#x3D; 10; int b &#x3D; 10; &#x2F;&#x2F;打印地址 cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; &#x2F;&#x2F;静态变量 static int s_a &#x3D; 10; static int s_b &#x3D; 10; cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a &#x3D; 10; const int c_l_b &#x3D; 10; cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 打印结果： 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后**栈区：** 由编译器自动分配释放, 存放函数的参数值,局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： int * func() &#123; int a &#x3D; 10; return &amp;a; &#125; int main() &#123; int *p &#x3D; func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; **堆区：** 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存 示例： int* func() &#123; int* a &#x3D; new int(10); return a; &#125; int main() &#123; int *p &#x3D; func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符C++中利用==new==操作符在堆区开辟数据 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete== 语法：` new 数据类型` 利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 int* func() &#123; int* a &#x3D; new int(10); return a; &#125; int main() &#123; int *p &#x3D; func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;利用delete释放堆区数据 delete p; &#x2F;&#x2F;cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;报错，释放的空间不可访问 system(&quot;pause&quot;); return 0; &#125; 示例2：开辟数组 &#x2F;&#x2F;堆区开辟数组 int main() &#123; int* arr &#x3D; new int[10]; for (int i &#x3D; 0; i &lt; 10; i++) &#123; arr[i] &#x3D; i + 100; &#125; for (int i &#x3D; 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; &#x2F;&#x2F;释放数组 delete 后加 [] delete[] arr; system(&quot;pause&quot;); return 0; &#125; 2 引用2.1 引用的基本使用**作用： **给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： int main() &#123; int a &#x3D; 10; int &amp;b &#x3D; a; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl; b &#x3D; 100; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： int main() &#123; int a &#x3D; 10; int b &#x3D; 20; &#x2F;&#x2F;int &amp;c; &#x2F;&#x2F;错误，引用必须初始化 int &amp;c &#x3D; a; &#x2F;&#x2F;一旦初始化后，就不可以更改 c &#x3D; b; &#x2F;&#x2F;这是赋值操作，不是更改引用 cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： &#x2F;&#x2F;1. 值传递 void mySwap01(int a, int b) &#123; int temp &#x3D; a; a &#x3D; b; b &#x3D; temp; &#125; &#x2F;&#x2F;2. 地址传递 void mySwap02(int* a, int* b) &#123; int temp &#x3D; *a; *a &#x3D; *b; *b &#x3D; temp; &#125; &#x2F;&#x2F;3. 引用传递 void mySwap03(int&amp; a, int&amp; b) &#123; int temp &#x3D; a; a &#x3D; b; b &#x3D; temp; &#125; int main() &#123; int a &#x3D; 10; int b &#x3D; 20; mySwap01(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap02(&amp;a, &amp;b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap03(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： &#x2F;&#x2F;返回局部变量引用 int&amp; test01() &#123; int a &#x3D; 10; &#x2F;&#x2F;局部变量 return a; &#125; &#x2F;&#x2F;返回静态变量引用 int&amp; test02() &#123; static int a &#x3D; 20; return a; &#125; int main() &#123; &#x2F;&#x2F;不能返回局部变量的引用 int&amp; ref &#x3D; test01(); cout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl; &#x2F;&#x2F;如果函数做左值，那么必须返回引用 int&amp; ref2 &#x3D; test02(); cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl; test02() &#x3D; 1000; cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; ​ 2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： &#x2F;&#x2F;发现是引用，转换为 int* const ref &#x3D; &amp;a; void func(int&amp; ref)&#123; ref &#x3D; 100; &#x2F;&#x2F; ref是引用，转换为*ref &#x3D; 100 &#125; int main()&#123; int a &#x3D; 10; &#x2F;&#x2F;自动转换为 int* const ref &#x3D; &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref &#x3D; a; ref &#x3D; 20; &#x2F;&#x2F;内部发现ref是引用，自动帮我们转换为: *ref &#x3D; 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a); return 0; &#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加==const修饰形参==，防止形参改变实参 示例： &#x2F;&#x2F;引用使用的场景，通常用来修饰形参 void showValue(const int&amp; v) &#123; &#x2F;&#x2F;v +&#x3D; 10; cout &lt;&lt; v &lt;&lt; endl; &#125; int main() &#123; &#x2F;&#x2F;int&amp; ref &#x3D; 10; 引用本身需要一个合法的内存空间，因此这行错误 &#x2F;&#x2F;加入const就可以了，编译器优化代码，int temp &#x3D; 10; const int&amp; ref &#x3D; temp; const int&amp; ref &#x3D; 10; &#x2F;&#x2F;ref &#x3D; 100; &#x2F;&#x2F;加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; &#x2F;&#x2F;函数中利用常量引用防止误操作修改实参 int a &#x3D; 10; showValue(a); system(&quot;pause&quot;); return 0; &#125; 3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。 语法： 返回值类型 函数名 （参数= 默认值）&#123;&#125; 示例： int func(int a, int b &#x3D; 10, int c &#x3D; 10) &#123; return a + b + c; &#125; &#x2F;&#x2F;1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值 &#x2F;&#x2F;2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 int func2(int a &#x3D; 10, int b &#x3D; 10); int func2(int a, int b) &#123; return a + b; &#125; int main() &#123; cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(20, 20) &lt;&lt; endl; cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(100) &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型)&#123;&#125; 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 示例： &#x2F;&#x2F;函数占位参数 ，占位参数也可以有默认参数 void func(int a, int) &#123; cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl; &#125; int main() &#123; func(10,10); &#x2F;&#x2F;占位参数必须填补 system(&quot;pause&quot;); return 0; &#125; 3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件 示例： &#x2F;&#x2F;函数重载需要函数都在同一个作用域下 void func() &#123; cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl; &#125; void func(double a) &#123; cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl; &#125; void func(int a ,double b) &#123; cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl; &#125; void func(double a ,int b) &#123; cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;函数返回值不可以作为函数重载条件 &#x2F;&#x2F;int func(double a, int b) &#x2F;&#x2F;&#123; &#x2F;&#x2F; cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl; &#x2F;&#x2F;&#125; int main() &#123; func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(&quot;pause&quot;); return 0; &#125; 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例： &#x2F;&#x2F;函数重载注意事项 &#x2F;&#x2F;1、引用作为重载条件 void func(int &amp;a) &#123; cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl; &#125; void func(const int &amp;a) &#123; cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;2、函数重载碰到函数默认参数 void func2(int a, int b &#x3D; 10) &#123; cout &lt;&lt; &quot;func2(int a, int b &#x3D; 10) 调用&quot; &lt;&lt; endl; &#125; void func2(int a) &#123; cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl; &#125; int main() &#123; int a &#x3D; 10; func(a); &#x2F;&#x2F;调用无const func(10);&#x2F;&#x2F;调用有const &#x2F;&#x2F;func2(10); &#x2F;&#x2F;碰到默认参数产生歧义，需要避免 system(&quot;pause&quot;); return 0; &#125; 4 类和对象C++面向对象的三大特性为：==封装、继承、多态== C++认为==万事万物都皆为对象==，对象上有其属性和行为 例如： 人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌... 车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调... 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类 4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： 在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名&#123; 访问权限： 属性 / 行为 &#125;; 示例1：设计一个圆类，求圆的周长 示例代码： &#x2F;&#x2F;圆周率 const double PI &#x3D; 3.14; &#x2F;&#x2F;1、封装的意义 &#x2F;&#x2F;将属性和行为作为一个整体，用来表现生活中的事物 &#x2F;&#x2F;封装一个圆类，求圆的周长 &#x2F;&#x2F;class代表设计一个类，后面跟着的是类名 class Circle &#123; public: &#x2F;&#x2F;访问权限 公共的权限 &#x2F;&#x2F;属性 int m_r;&#x2F;&#x2F;半径 &#x2F;&#x2F;行为 &#x2F;&#x2F;获取到圆的周长 double calculateZC() &#123; &#x2F;&#x2F;2 * pi * r &#x2F;&#x2F;获取圆的周长 return 2 * PI * m_r; &#125; &#125;; int main() &#123; &#x2F;&#x2F;通过圆类，创建圆的对象 &#x2F;&#x2F; c1就是一个具体的圆 Circle c1; c1.m_r &#x3D; 10; &#x2F;&#x2F;给圆对象的半径 进行赋值操作 &#x2F;&#x2F;2 * pi * 10 &#x3D; &#x3D; 62.8 cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号 示例2代码： &#x2F;&#x2F;学生类 class Student &#123; public: void setName(string name) &#123; m_name &#x3D; name; &#125; void setID(int id) &#123; m_id &#x3D; id; &#125; void showStudent() &#123; cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl; &#125; public: string m_name; int m_id; &#125;; int main() &#123; Student stu; stu.setName(&quot;德玛西亚&quot;); stu.setID(250); stu.showStudent(); system(&quot;pause&quot;); return 0; &#125; 封装意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 示例： &#x2F;&#x2F;三种权限 &#x2F;&#x2F;公共权限 public 类内可以访问 类外可以访问 &#x2F;&#x2F;保护权限 protected 类内可以访问 类外不可以访问 &#x2F;&#x2F;私有权限 private 类内可以访问 类外不可以访问 class Person &#123; &#x2F;&#x2F;姓名 公共权限 public: string m_Name; &#x2F;&#x2F;汽车 保护权限 protected: string m_Car; &#x2F;&#x2F;银行卡密码 私有权限 private: int m_Password; public: void func() &#123; m_Name &#x3D; &quot;张三&quot;; m_Car &#x3D; &quot;拖拉机&quot;; m_Password &#x3D; 123456; &#125; &#125;; int main() &#123; Person p; p.m_Name &#x3D; &quot;李四&quot;; &#x2F;&#x2F;p.m_Car &#x3D; &quot;奔驰&quot;; &#x2F;&#x2F;保护权限类外访问不到 &#x2F;&#x2F;p.m_Password &#x3D; 123; &#x2F;&#x2F;私有权限类外访问不到 system(&quot;pause&quot;); return 0; &#125; 4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 class C1 &#123; int m_A; &#x2F;&#x2F;默认是私有权限 &#125;; struct C2 &#123; int m_A; &#x2F;&#x2F;默认是公共权限 &#125;; int main() &#123; C1 c1; c1.m_A &#x3D; 10; &#x2F;&#x2F;错误，访问权限是私有 C2 c2; c2.m_A &#x3D; 10; &#x2F;&#x2F;正确，访问权限是公共 system(&quot;pause&quot;); return 0; &#125; 4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性 示例： class Person &#123; public: &#x2F;&#x2F;姓名设置可读可写 void setName(string name) &#123; m_Name &#x3D; name; &#125; string getName() &#123; return m_Name; &#125; &#x2F;&#x2F;获取年龄 int getAge() &#123; return m_Age; &#125; &#x2F;&#x2F;设置年龄 void setAge(int age) &#123; if (age &lt; 0 || age &gt; 150) &#123; cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl; return; &#125; m_Age &#x3D; age; &#125; &#x2F;&#x2F;情人设置为只写 void setLover(string lover) &#123; m_Lover &#x3D; lover; &#125; private: string m_Name; &#x2F;&#x2F;可读可写 姓名 int m_Age; &#x2F;&#x2F;只读 年龄 string m_Lover; &#x2F;&#x2F;只写 情人 &#125;; int main() &#123; Person p; &#x2F;&#x2F;姓名设置 p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl; &#x2F;&#x2F;年龄设置 p.setAge(50); cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl; &#x2F;&#x2F;情人设置 p.setLover(&quot;苍井&quot;); &#x2F;&#x2F;cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl; &#x2F;&#x2F;只写属性，不可以读取 system(&quot;pause&quot;); return 0; &#125; 练习案例1：设计立方体类 设计立方体类(Cube) 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。 练习案例2：点和圆的关系 设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。 4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 一个对象或者变量没有初始状态，对其使用后果是未知 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名()&#123;&#125; 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名()&#123;&#125; 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 class Person &#123; public: &#x2F;&#x2F;构造函数 Person() &#123; cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;析构函数 ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; Person p; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.2.2 构造函数的分类及调用两种分类方式： 按参数分为： 有参构造和无参构造 按类型分为： 普通构造和拷贝构造 三种调用方式： 括号法 显示法 隐式转换法 示例： &#x2F;&#x2F;1、构造函数分类 &#x2F;&#x2F; 按照参数分类分为 有参和无参构造 无参又称为默认构造函数 &#x2F;&#x2F; 按照类型分类分为 普通构造和拷贝构造 class Person &#123; public: &#x2F;&#x2F;无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;有参构造函数 Person(int a) &#123; age &#x3D; a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;拷贝构造函数 Person(const Person&amp; p) &#123; age &#x3D; p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125; public: int age; &#125;; &#x2F;&#x2F;2、构造函数的调用 &#x2F;&#x2F;调用无参构造函数 void test01() &#123; Person p; &#x2F;&#x2F;调用无参构造函数 &#125; &#x2F;&#x2F;调用有参的构造函数 void test02() &#123; &#x2F;&#x2F;2.1 括号法，常用 Person p1(10); &#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 &#x2F;&#x2F;Person p2(); &#x2F;&#x2F;2.2 显式法 Person p2 &#x3D; Person(10); Person p3 &#x3D; Person(p2); &#x2F;&#x2F;Person(10)单独写就是匿名对象 当前行结束之后，马上析构 &#x2F;&#x2F;2.3 隐式转换法 Person p4 &#x3D; 10; &#x2F;&#x2F; Person p4 &#x3D; Person(10); Person p5 &#x3D; p4; &#x2F;&#x2F; Person p5 &#x3D; Person(p4); &#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 &#x2F;&#x2F;Person p5(p4); &#125; int main() &#123; test01(); &#x2F;&#x2F;test02(); system(&quot;pause&quot;); return 0; &#125; 4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例： class Person &#123; public: Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; mAge &#x3D; 0; &#125; Person(int age) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; mAge &#x3D; age; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; mAge &#x3D; p.mAge; &#125; &#x2F;&#x2F;析构函数在释放内存之前调用 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125; public: int mAge; &#125;; &#x2F;&#x2F;1. 使用一个已经创建完毕的对象来初始化一个新对象 void test01() &#123; Person man(100); &#x2F;&#x2F;p对象已经创建完毕 Person newman(man); &#x2F;&#x2F;调用拷贝构造函数 Person newman2 &#x3D; man; &#x2F;&#x2F;拷贝构造 &#x2F;&#x2F;Person newman3; &#x2F;&#x2F;newman3 &#x3D; man; &#x2F;&#x2F;不是调用拷贝构造函数，赋值操作 &#125; &#x2F;&#x2F;2. 值传递的方式给函数参数传值 &#x2F;&#x2F;相当于Person p1 &#x3D; p; void doWork(Person p1) &#123;&#125; void test02() &#123; Person p; &#x2F;&#x2F;无参构造函数 doWork(p); &#125; &#x2F;&#x2F;3. 以值方式返回局部对象 Person doWork2() &#123; Person p1; cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1; &#125; void test03() &#123; Person p &#x3D; doWork2(); cout &lt;&lt; (int *)&amp;p &lt;&lt; endl; &#125; int main() &#123; &#x2F;&#x2F;test01(); &#x2F;&#x2F;test02(); test03(); system(&quot;pause&quot;); return 0; &#125; 4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： class Person &#123; public: &#x2F;&#x2F;无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;有参构造函数 Person(int a) &#123; age &#x3D; a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;拷贝构造函数 Person(const Person&amp; p) &#123; age &#x3D; p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125; public: int age; &#125;; void test01() &#123; Person p1(18); &#x2F;&#x2F;如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl; &#125; void test02() &#123; &#x2F;&#x2F;如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错 Person p2(10); &#x2F;&#x2F;用户提供的有参 Person p3(p2); &#x2F;&#x2F;此时如果用户没有提供拷贝构造，编译器会提供 &#x2F;&#x2F;如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错 Person p5(10); &#x2F;&#x2F;此时如果用户自己没有提供有参，会出错 Person p6(p5); &#x2F;&#x2F;用户自己提供拷贝构造 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 示例： class Person &#123; public: &#x2F;&#x2F;无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;有参构造函数 Person(int age ,int height) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; m_age &#x3D; age; m_height &#x3D; new int(height); &#125; &#x2F;&#x2F;拷贝构造函数 Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#x2F;&#x2F;如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age &#x3D; p.m_age; m_height &#x3D; new int(*p.m_height); &#125; &#x2F;&#x2F;析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; if (m_height !&#x3D; NULL) &#123; delete m_height; &#125; &#125; public: int m_age; int* m_height; &#125;; void test01() &#123; Person p1(18, 180); Person p2(p1); cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 4.2.6 初始化列表作用： C++提供了初始化列表语法，用来初始化属性 语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125; 示例： class Person &#123; public: &#x2F;&#x2F;&#x2F;&#x2F;传统方式初始化 &#x2F;&#x2F;Person(int a, int b, int c) &#123; &#x2F;&#x2F; m_A &#x3D; a; &#x2F;&#x2F; m_B &#x3D; b; &#x2F;&#x2F; m_C &#x3D; c; &#x2F;&#x2F;&#125; &#x2F;&#x2F;初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125; void PrintPerson() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl; &#125; private: int m_A; int m_B; int m_C; &#125;; int main() &#123; Person p(1, 2, 3); p.PrintPerson(); system(&quot;pause&quot;); return 0; &#125; 4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： class A &#123;&#125; class B &#123; A a； &#125; B类中有对象A作为成员，A为对象成员 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？ 示例： class Phone &#123; public: Phone(string name) &#123; m_PhoneName &#x3D; name; cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl; &#125; ~Phone() &#123; cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl; &#125; string m_PhoneName; &#125;; class Person &#123; public: &#x2F;&#x2F;初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123; cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl; &#125; void playGame() &#123; cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl; &#125; string m_Name; Phone m_Phone; &#125;; void test01() &#123; &#x2F;&#x2F;当类中成员是其他类对象时，我们称该成员为 对象成员 &#x2F;&#x2F;构造的顺序是 ：先调用对象成员的构造，再调用本类构造 &#x2F;&#x2F;析构顺序与构造相反 Person p(&quot;张三&quot; , &quot;苹果X&quot;); p.playGame(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 示例1 ：静态成员变量 class Person &#123; public: static int m_A; &#x2F;&#x2F;静态成员变量 &#x2F;&#x2F;静态成员变量特点： &#x2F;&#x2F;1 在编译阶段分配内存 &#x2F;&#x2F;2 类内声明，类外初始化 &#x2F;&#x2F;3 所有对象共享同一份数据 private: static int m_B; &#x2F;&#x2F;静态成员变量也是有访问权限的 &#125;; int Person::m_A &#x3D; 10; int Person::m_B &#x3D; 10; void test01() &#123; &#x2F;&#x2F;静态成员变量两种访问方式 &#x2F;&#x2F;1、通过对象 Person p1; p1.m_A &#x3D; 100; cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl; Person p2; p2.m_A &#x3D; 200; cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl; &#x2F;&#x2F;共享同一份数据 cout &lt;&lt; &quot;p2.m_A &#x3D; &quot; &lt;&lt; p2.m_A &lt;&lt; endl; &#x2F;&#x2F;2、通过类名 cout &lt;&lt; &quot;m_A &#x3D; &quot; &lt;&lt; Person::m_A &lt;&lt; endl; &#x2F;&#x2F;cout &lt;&lt; &quot;m_B &#x3D; &quot; &lt;&lt; Person::m_B &lt;&lt; endl; &#x2F;&#x2F;私有权限访问不到 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 示例2：静态成员函数 class Person &#123; public: &#x2F;&#x2F;静态成员函数特点： &#x2F;&#x2F;1 程序共享一个函数 &#x2F;&#x2F;2 静态成员函数只能访问静态成员变量 static void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; m_A &#x3D; 100; &#x2F;&#x2F;m_B &#x3D; 100; &#x2F;&#x2F;错误，不可以访问非静态成员变量 &#125; static int m_A; &#x2F;&#x2F;静态成员变量 int m_B; &#x2F;&#x2F; private: &#x2F;&#x2F;静态成员函数也是有访问权限的 static void func2() &#123; cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl; &#125; &#125;; int Person::m_A &#x3D; 10; void test01() &#123; &#x2F;&#x2F;静态成员变量两种访问方式 &#x2F;&#x2F;1、通过对象 Person p1; p1.func(); &#x2F;&#x2F;2、通过类名 Person::func(); &#x2F;&#x2F;Person::func2(); &#x2F;&#x2F;私有权限访问不到 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 class Person &#123; public: Person() &#123; mA &#x3D; 0; &#125; &#x2F;&#x2F;非静态成员变量占对象空间 int mA; &#x2F;&#x2F;静态成员变量不占对象空间 static int mB; &#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例 void func() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl; &#125; &#x2F;&#x2F;静态成员函数也不占对象空间 static void sfunc() &#123; &#125; &#125;; int main() &#123; cout &lt;&lt; sizeof(Person) &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this class Person &#123; public: Person(int age) &#123; &#x2F;&#x2F;1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age &#x3D; age; &#125; Person&amp; PersonAddPerson(Person p) &#123; this-&gt;age +&#x3D; p.age; &#x2F;&#x2F;返回对象本身 return *this; &#125; int age; &#125;; void test01() &#123; Person p1(10); cout &lt;&lt; &quot;p1.age &#x3D; &quot; &lt;&lt; p1.age &lt;&lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout &lt;&lt; &quot;p2.age &#x3D; &quot; &lt;&lt; p2.age &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： &#x2F;&#x2F;空指针访问成员函数 class Person &#123; public: void ShowClassName() &#123; cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl; &#125; void ShowPerson() &#123; if (this &#x3D;&#x3D; NULL) &#123; return; &#125; cout &lt;&lt; mAge &lt;&lt; endl; &#125; public: int mAge; &#125;; void test01() &#123; Person * p &#x3D; NULL; p-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数 p-&gt;ShowPerson(); &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.3.4 const修饰成员函数常函数： 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： class Person &#123; public: Person() &#123; m_A &#x3D; 0; m_B &#x3D; 0; &#125; &#x2F;&#x2F;this指针的本质是一个指针常量，指针的指向不可修改 &#x2F;&#x2F;如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const &#123; &#x2F;&#x2F;const Type* const pointer; &#x2F;&#x2F;this &#x3D; NULL; &#x2F;&#x2F;不能修改指针的指向 Person* const this; &#x2F;&#x2F;this-&gt;mA &#x3D; 100; &#x2F;&#x2F;但是this指针指向的对象的数据是可以修改的 &#x2F;&#x2F;const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B &#x3D; 100; &#125; void MyFunc() const &#123; &#x2F;&#x2F;mA &#x3D; 10000; &#125; public: int m_A; mutable int m_B; &#x2F;&#x2F;可修改 可变的 &#125;; &#x2F;&#x2F;const修饰对象 常对象 void test01() &#123; const Person person; &#x2F;&#x2F;常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl; &#x2F;&#x2F;person.mA &#x3D; 100; &#x2F;&#x2F;常对象不能修改成员变量的值,但是可以访问 person.m_B &#x3D; 100; &#x2F;&#x2F;但是常对象可以修改mutable修饰成员变量 &#x2F;&#x2F;常对象访问成员函数 person.MyFunc(); &#x2F;&#x2F;常对象不能调用const的函数 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 ==friend== 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元class Building &#123; &#x2F;&#x2F;告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building); public: Building() &#123; this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;; this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;; &#125; public: string m_SittingRoom; &#x2F;&#x2F;客厅 private: string m_BedRoom; &#x2F;&#x2F;卧室 &#125;; void goodGay(Building * building) &#123; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; &#125; void test01() &#123; Building b; goodGay(&amp;b); &#125; int main()&#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.4.2 类做友元class Building; class goodGay &#123; public: goodGay(); void visit(); private: Building *building; &#125;; class Building &#123; &#x2F;&#x2F;告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay; public: Building(); public: string m_SittingRoom; &#x2F;&#x2F;客厅 private: string m_BedRoom;&#x2F;&#x2F;卧室 &#125;; Building::Building() &#123; this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;; this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;; &#125; goodGay::goodGay() &#123; building &#x3D; new Building; &#125; void goodGay::visit() &#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; &#125; void test01() &#123; goodGay gg; gg.visit(); &#125; int main()&#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.4.3 成员函数做友元 class Building; class goodGay &#123; public: goodGay(); void visit(); &#x2F;&#x2F;只让visit函数作为Building的好朋友，可以发访问Building中私有内容 void visit2(); private: Building *building; &#125;; class Building &#123; &#x2F;&#x2F;告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit(); public: Building(); public: string m_SittingRoom; &#x2F;&#x2F;客厅 private: string m_BedRoom;&#x2F;&#x2F;卧室 &#125;; Building::Building() &#123; this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;; this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;; &#125; goodGay::goodGay() &#123; building &#x3D; new Building; &#125; void goodGay::visit() &#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; &#125; void goodGay::visit2() &#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; &#x2F;&#x2F;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; &#125; void test01() &#123; goodGay gg; gg.visit(); &#125; int main()&#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算 class Person &#123; public: Person() &#123;&#125;; Person(int a, int b) &#123; this-&gt;m_A &#x3D; a; this-&gt;m_B &#x3D; b; &#125; &#x2F;&#x2F;成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) &#123; Person temp; temp.m_A &#x3D; this-&gt;m_A + p.m_A; temp.m_B &#x3D; this-&gt;m_B + p.m_B; return temp; &#125; public: int m_A; int m_B; &#125;; &#x2F;&#x2F;全局函数实现 + 号运算符重载 &#x2F;&#x2F;Person operator+(const Person&amp; p1, const Person&amp; p2) &#123; &#x2F;&#x2F; Person temp(0, 0); &#x2F;&#x2F; temp.m_A &#x3D; p1.m_A + p2.m_A; &#x2F;&#x2F; temp.m_B &#x3D; p1.m_B + p2.m_B; &#x2F;&#x2F; return temp; &#x2F;&#x2F;&#125; &#x2F;&#x2F;运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) &#123; Person temp; temp.m_A &#x3D; p2.m_A + val; temp.m_B &#x3D; p2.m_B + val; return temp; &#125; void test() &#123; Person p1(10, 10); Person p2(20, 20); &#x2F;&#x2F;成员函数方式 Person p3 &#x3D; p2 + p1; &#x2F;&#x2F;相当于 p2.operaor+(p1) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl; Person p4 &#x3D; p3 + 10; &#x2F;&#x2F;相当于 operator+(p3,10) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl; &#125; int main() &#123; test(); system(&quot;pause&quot;); return 0; &#125; 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载 4.5.2 左移运算符重载作用：可以输出自定义数据类型 class Person &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p); public: Person(int a, int b) &#123; this-&gt;m_A &#x3D; a; this-&gt;m_B &#x3D; b; &#125; &#x2F;&#x2F;成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 &#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123; &#x2F;&#x2F;&#125; private: int m_A; int m_B; &#125;; &#x2F;&#x2F;全局函数实现左移重载 &#x2F;&#x2F;ostream对象只能有一个 ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B; return out; &#125; void test() &#123; Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程 &#125; int main() &#123; test(); system(&quot;pause&quot;); return 0; &#125; 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据 class MyInteger &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint); public: MyInteger() &#123; m_Num &#x3D; 0; &#125; &#x2F;&#x2F;前置++ MyInteger&amp; operator++() &#123; &#x2F;&#x2F;先++ m_Num++; &#x2F;&#x2F;再返回 return *this; &#125; &#x2F;&#x2F;后置++ MyInteger operator++(int) &#123; &#x2F;&#x2F;先返回 MyInteger temp &#x3D; *this; &#x2F;&#x2F;记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp; &#125; private: int m_Num; &#125;; ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123; out &lt;&lt; myint.m_Num; return out; &#125; &#x2F;&#x2F;前置++ 先++ 再返回 void test01() &#123; MyInteger myInt; cout &lt;&lt; ++myInt &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl; &#125; &#x2F;&#x2F;后置++ 先返回 再++ void test02() &#123; MyInteger myInt; cout &lt;&lt; myInt++ &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl; &#125; int main() &#123; test01(); &#x2F;&#x2F;test02(); system(&quot;pause&quot;); return 0; &#125; 总结： 前置递增返回引用，后置递增返回值 4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator=, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 示例： class Person &#123; public: Person(int age) &#123; &#x2F;&#x2F;将年龄数据开辟到堆区 m_Age &#x3D; new int(age); &#125; &#x2F;&#x2F;重载赋值运算符 Person&amp; operator&#x3D;(Person &amp;p) &#123; if (m_Age !&#x3D; NULL) &#123; delete m_Age; m_Age &#x3D; NULL; &#125; &#x2F;&#x2F;编译器提供的代码是浅拷贝 &#x2F;&#x2F;m_Age &#x3D; p.m_Age; &#x2F;&#x2F;提供深拷贝 解决浅拷贝的问题 m_Age &#x3D; new int(*p.m_Age); &#x2F;&#x2F;返回自身 return *this; &#125; ~Person() &#123; if (m_Age !&#x3D; NULL) &#123; delete m_Age; m_Age &#x3D; NULL; &#125; &#125; &#x2F;&#x2F;年龄的指针 int *m_Age; &#125;; void test01() &#123; Person p1(18); Person p2(20); Person p3(30); p3 &#x3D; p2 &#x3D; p1; &#x2F;&#x2F;赋值操作 cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl; &#125; int main() &#123; test01(); &#x2F;&#x2F;int a &#x3D; 10; &#x2F;&#x2F;int b &#x3D; 20; &#x2F;&#x2F;int c &#x3D; 30; &#x2F;&#x2F;c &#x3D; b &#x3D; a; &#x2F;&#x2F;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl; &#x2F;&#x2F;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： class Person &#123; public: Person(string name, int age) &#123; this-&gt;m_Name &#x3D; name; this-&gt;m_Age &#x3D; age; &#125;; bool operator&#x3D;&#x3D;(Person &amp; p) &#123; if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; bool operator!&#x3D;(Person &amp; p) &#123; if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age) &#123; return false; &#125; else &#123; return true; &#125; &#125; string m_Name; int m_Age; &#125;; void test01() &#123; &#x2F;&#x2F;int a &#x3D; 0; &#x2F;&#x2F;int b &#x3D; 0; Person a(&quot;孙悟空&quot;, 18); Person b(&quot;孙悟空&quot;, 18); if (a &#x3D;&#x3D; b) &#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; if (a !&#x3D; b) &#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例： class MyPrint &#123; public: void operator()(string text) &#123; cout &lt;&lt; text &lt;&lt; endl; &#125; &#125;; void test01() &#123; &#x2F;&#x2F;重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(&quot;hello world&quot;); &#125; class MyAdd &#123; public: int operator()(int v1, int v2) &#123; return v1 + v2; &#125; &#125;; void test02() &#123; MyAdd add; int ret &#x3D; add(10, 10); cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; ret &lt;&lt; endl; &#x2F;&#x2F;匿名对象调用 cout &lt;&lt; &quot;MyAdd()(100,100) &#x3D; &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl; &#125; int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 4.6 继承继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中： 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现： &#x2F;&#x2F;Java页面 class Java &#123; public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;Python页面 class Python &#123; public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;C++页面 class CPP &#123; public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; &#x2F;&#x2F;Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; &#x2F;&#x2F;Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; &#x2F;&#x2F;C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 继承实现： &#x2F;&#x2F;公共页面 class BasePage &#123; public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;Java页面 class Java : public BasePage &#123; public: void content() &#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;Python页面 class Python : public BasePage &#123; public: void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;C++页面 class CPP : public BasePage &#123; public: void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; &#x2F;&#x2F;Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; &#x2F;&#x2F;Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; &#x2F;&#x2F;C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 继承的好处：==可以减少重复的代码== class A : public B; A 类称为子类 或 派生类 B 类称为父类 或 基类 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 4.6.2 继承方式继承的语法：class 子类 : 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 示例： class Base1 &#123; public: int m_A; protected: int m_B; private: int m_C; &#125;; &#x2F;&#x2F;公共继承 class Son1 :public Base1 &#123; public: void func() &#123; m_A; &#x2F;&#x2F;可访问 public权限 m_B; &#x2F;&#x2F;可访问 protected权限 &#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问 &#125; &#125;; void myClass() &#123; Son1 s1; s1.m_A; &#x2F;&#x2F;其他类只能访问到公共权限 &#125; &#x2F;&#x2F;保护继承 class Base2 &#123; public: int m_A; protected: int m_B; private: int m_C; &#125;; class Son2:protected Base2 &#123; public: void func() &#123; m_A; &#x2F;&#x2F;可访问 protected权限 m_B; &#x2F;&#x2F;可访问 protected权限 &#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问 &#125; &#125;; void myClass2() &#123; Son2 s; &#x2F;&#x2F;s.m_A; &#x2F;&#x2F;不可访问 &#125; &#x2F;&#x2F;私有继承 class Base3 &#123; public: int m_A; protected: int m_B; private: int m_C; &#125;; class Son3:private Base3 &#123; public: void func() &#123; m_A; &#x2F;&#x2F;可访问 private权限 m_B; &#x2F;&#x2F;可访问 private权限 &#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问 &#125; &#125;; class GrandSon3 :public Son3 &#123; public: void func() &#123; &#x2F;&#x2F;Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 &#x2F;&#x2F;m_A; &#x2F;&#x2F;m_B; &#x2F;&#x2F;m_C; &#125; &#125;; 4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？ 示例： class Base &#123; public: int m_A; protected: int m_B; private: int m_C; &#x2F;&#x2F;私有成员只是被隐藏了，但是还是会继承下去 &#125;; &#x2F;&#x2F;公共继承 class Son :public Base &#123; public: int m_D; &#125;; void test01() &#123; cout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 利用工具查看： 打开工具窗口后，定位到当前CPP文件的盘符 然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名 效果如下图： 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 问题：父类和子类的构造和析构顺序是谁先谁后？ 示例： class Base &#123; public: Base() &#123; cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl; &#125; &#125;; class Son : public Base &#123; public: Son() &#123; cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; &#x2F;&#x2F;继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： class Base &#123; public: Base() &#123; m_A &#x3D; 100; &#125; void func() &#123; cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl; &#125; public: int m_A; &#125;; class Son : public Base &#123; public: Son() &#123; m_A &#x3D; 200; &#125; &#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 &#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() &#123; cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl; &#125; public: int m_A; &#125;; void test01() &#123; Son s; cout &lt;&lt; &quot;Son下的m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; s.func(); s.Base::func(); s.Base::func(10); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return EXIT_SUCCESS; &#125; 总结： 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？ 静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： class Base &#123; public: static void func() &#123; cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl; &#125; static void func(int a) &#123; cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl; &#125; static int m_A; &#125;; int Base::m_A &#x3D; 100; class Son : public Base &#123; public: static void func() &#123; cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl; &#125; static int m_A; &#125;; int Son::m_A &#x3D; 200; &#x2F;&#x2F;同名成员属性 void test01() &#123; &#x2F;&#x2F;通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Son 下 m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; &#x2F;&#x2F;通过类名访问 cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son 下 m_A &#x3D; &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl; &#125; &#x2F;&#x2F;同名成员函数 void test02() &#123; &#x2F;&#x2F;通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; Son::func(); Son::Base::func(); &#x2F;&#x2F;出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100); &#125; int main() &#123; &#x2F;&#x2F;test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名） 4.6.7 多继承语法C++允许一个类继承多个类 语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议用多继承 示例： class Base1 &#123; public: Base1() &#123; m_A &#x3D; 100; &#125; public: int m_A; &#125;; class Base2 &#123; public: Base2() &#123; m_A &#x3D; 200; &#x2F;&#x2F;开始是m_B 不会出问题，但是改为mA就会出现不明确 &#125; public: int m_A; &#125;; &#x2F;&#x2F;语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123; public: Son() &#123; m_C &#x3D; 300; m_D &#x3D; 400; &#125; public: int m_C; int m_D; &#125;; &#x2F;&#x2F;多继承容易产生成员同名的情况 &#x2F;&#x2F;通过使用类名作用域可以区分调用哪一个基类的成员 void test01() &#123; Son s; cout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域 4.6.8 菱形继承菱形继承概念： 两个派生类继承同一个基类 又有某个类同时继承者两个派生类 这种继承被称为菱形继承，或者钻石继承 典型的菱形继承案例： 菱形继承问题： 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 示例： class Animal &#123; public: int m_Age; &#125;; &#x2F;&#x2F;继承前加virtual关键字后，变为虚继承 &#x2F;&#x2F;此时公共的父类Animal称为虚基类 class Sheep : virtual public Animal &#123;&#125;; class Tuo : virtual public Animal &#123;&#125;; class SheepTuo : public Sheep, public Tuo &#123;&#125;; void test01() &#123; SheepTuo st; st.Sheep::m_Age &#x3D; 100; st.Tuo::m_Age &#x3D; 200; cout &lt;&lt; &quot;st.Sheep::m_Age &#x3D; &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age &#x3D; &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.m_Age &#x3D; &quot; &lt;&lt; st.m_Age &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一 多态分为两类 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态 class Animal &#123; public: &#x2F;&#x2F;Speak函数就是虚函数 &#x2F;&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125; &#125;; class Cat :public Animal &#123; public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125; &#125;; class Dog :public Animal &#123; public: void speak() &#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数 &#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编 &#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编 void DoSpeak(Animal &amp; animal) &#123; animal.speak(); &#125; &#x2F;&#x2F; &#x2F;&#x2F;多态满足条件： &#x2F;&#x2F;1、有继承关系 &#x2F;&#x2F;2、子类重写父类中的虚函数 &#x2F;&#x2F;多态使用： &#x2F;&#x2F;父类指针或引用指向子类对象 void test01() &#123; Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 4.7.2 多态案例一-计算器类案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例： &#x2F;&#x2F;普通实现 class Calculator &#123; public: int getResult(string oper) &#123; if (oper &#x3D;&#x3D; &quot;+&quot;) &#123; return m_Num1 + m_Num2; &#125; else if (oper &#x3D;&#x3D; &quot;-&quot;) &#123; return m_Num1 - m_Num2; &#125; else if (oper &#x3D;&#x3D; &quot;*&quot;) &#123; return m_Num1 * m_Num2; &#125; &#x2F;&#x2F;如果要提供新的运算，需要修改源码 &#125; public: int m_Num1; int m_Num2; &#125;; void test01() &#123; &#x2F;&#x2F;普通实现测试 Calculator c; c.m_Num1 &#x3D; 10; c.m_Num2 &#x3D; 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl; &#125; &#x2F;&#x2F;多态实现 &#x2F;&#x2F;抽象计算器类 &#x2F;&#x2F;多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护 class AbstractCalculator &#123; public : virtual int getResult() &#123; return 0; &#125; int m_Num1; int m_Num2; &#125;; &#x2F;&#x2F;加法计算器 class AddCalculator :public AbstractCalculator &#123; public: int getResult() &#123; return m_Num1 + m_Num2; &#125; &#125;; &#x2F;&#x2F;减法计算器 class SubCalculator :public AbstractCalculator &#123; public: int getResult() &#123; return m_Num1 - m_Num2; &#125; &#125;; &#x2F;&#x2F;乘法计算器 class MulCalculator :public AbstractCalculator &#123; public: int getResult() &#123; return m_Num1 * m_Num2; &#125; &#125;; void test02() &#123; &#x2F;&#x2F;创建加法计算器 AbstractCalculator *abc &#x3D; new AddCalculator; abc-&gt;m_Num1 &#x3D; 10; abc-&gt;m_Num2 &#x3D; 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; &#x2F;&#x2F;用完了记得销毁 &#x2F;&#x2F;创建减法计算器 abc &#x3D; new SubCalculator; abc-&gt;m_Num1 &#x3D; 10; abc-&gt;m_Num2 &#x3D; 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; &#x2F;&#x2F;创建乘法计算器 abc &#x3D; new MulCalculator; abc-&gt;m_Num1 &#x3D; 10; abc-&gt;m_Num2 &#x3D; 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; &#125; int main() &#123; &#x2F;&#x2F;test01(); test02(); system(&quot;pause&quot;); return 0; &#125; 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多 4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为==抽象类== 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： class Base &#123; public: &#x2F;&#x2F;纯虚函数 &#x2F;&#x2F;类中只要有一个纯虚函数就称为抽象类 &#x2F;&#x2F;抽象类无法实例化对象 &#x2F;&#x2F;子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() &#x3D; 0; &#125;; class Son :public Base &#123; public: virtual void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; &#125;; &#125;; void test01() &#123; Base * base &#x3D; NULL; &#x2F;&#x2F;base &#x3D; new Base; &#x2F;&#x2F; 错误，抽象类无法实例化对象 base &#x3D; new Son; base-&gt;func(); delete base;&#x2F;&#x2F;记得销毁 &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.7.4 多态案例二-制作饮品案例描述： 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 示例： &#x2F;&#x2F;抽象制作饮品 class AbstractDrinking &#123; public: &#x2F;&#x2F;烧水 virtual void Boil() &#x3D; 0; &#x2F;&#x2F;冲泡 virtual void Brew() &#x3D; 0; &#x2F;&#x2F;倒入杯中 virtual void PourInCup() &#x3D; 0; &#x2F;&#x2F;加入辅料 virtual void PutSomething() &#x3D; 0; &#x2F;&#x2F;规定流程 void MakeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125; &#125;; &#x2F;&#x2F;制作咖啡 class Coffee : public AbstractDrinking &#123; public: &#x2F;&#x2F;烧水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;制作茶水 class Tea : public AbstractDrinking &#123; public: &#x2F;&#x2F;烧水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;业务函数 void DoWork(AbstractDrinking* drink) &#123; drink-&gt;MakeDrink(); delete drink; &#125; void test01() &#123; DoWork(new Coffee); cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl; DoWork(new Tea); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名() = 0; 类名::~类名()&#123;&#125; 示例： class Animal &#123; public: Animal() &#123; cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl; &#125; virtual void Speak() &#x3D; 0; &#x2F;&#x2F;析构函数加上virtual关键字，变成虚析构函数 &#x2F;&#x2F;virtual ~Animal() &#x2F;&#x2F;&#123; &#x2F;&#x2F; cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl; &#x2F;&#x2F;&#125; virtual ~Animal() &#x3D; 0; &#125;; Animal::~Animal() &#123; cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl; &#125; &#x2F;&#x2F;和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。 class Cat : public Animal &#123; public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl; m_Name &#x3D; new string(name); &#125; virtual void Speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话!&quot; &lt;&lt; endl; &#125; ~Cat() &#123; cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl; if (this-&gt;m_Name !&#x3D; NULL) &#123; delete m_Name; m_Name &#x3D; NULL; &#125; &#125; public: string *m_Name; &#125;; void test01() &#123; Animal *animal &#x3D; new Cat(&quot;Tom&quot;); animal-&gt;Speak(); &#x2F;&#x2F;通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 &#x2F;&#x2F;怎么解决？给基类增加一个虚析构函数 &#x2F;&#x2F;虚析构函数就是用来解决通过父类指针释放子类对象 delete animal; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 3. 拥有纯虚析构函数的类也属于抽象类 4.7.6 多态案例三-电脑组装案例描述： 电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 示例： #include&lt;iostream&gt; using namespace std; &#x2F;&#x2F;抽象CPU类 class CPU &#123; public: &#x2F;&#x2F;抽象的计算函数 virtual void calculate() &#x3D; 0; &#125;; &#x2F;&#x2F;抽象显卡类 class VideoCard &#123; public: &#x2F;&#x2F;抽象的显示函数 virtual void display() &#x3D; 0; &#125;; &#x2F;&#x2F;抽象内存条类 class Memory &#123; public: &#x2F;&#x2F;抽象的存储函数 virtual void storage() &#x3D; 0; &#125;; &#x2F;&#x2F;电脑类 class Computer &#123; public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) &#123; m_cpu &#x3D; cpu; m_vc &#x3D; vc; m_mem &#x3D; mem; &#125; &#x2F;&#x2F;提供工作的函数 void work() &#123; &#x2F;&#x2F;让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; &#x2F;&#x2F;提供析构函数 释放3个电脑零件 ~Computer() &#123; &#x2F;&#x2F;释放CPU零件 if (m_cpu !&#x3D; NULL) &#123; delete m_cpu; m_cpu &#x3D; NULL; &#125; &#x2F;&#x2F;释放显卡零件 if (m_vc !&#x3D; NULL) &#123; delete m_vc; m_vc &#x3D; NULL; &#125; &#x2F;&#x2F;释放内存条零件 if (m_mem !&#x3D; NULL) &#123; delete m_mem; m_mem &#x3D; NULL; &#125; &#125; private: CPU * m_cpu; &#x2F;&#x2F;CPU的零件指针 VideoCard * m_vc; &#x2F;&#x2F;显卡零件指针 Memory * m_mem; &#x2F;&#x2F;内存条零件指针 &#125;; &#x2F;&#x2F;具体厂商 &#x2F;&#x2F;Intel厂商 class IntelCPU :public CPU &#123; public: virtual void calculate() &#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; &#125; &#125;; class IntelVideoCard :public VideoCard &#123; public: virtual void display() &#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; &#125; &#125;; class IntelMemory :public Memory &#123; public: virtual void storage() &#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; &#125; &#125;; &#x2F;&#x2F;Lenovo厂商 class LenovoCPU :public CPU &#123; public: virtual void calculate() &#123; cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl; &#125; &#125;; class LenovoVideoCard :public VideoCard &#123; public: virtual void display() &#123; cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl; &#125; &#125;; class LenovoMemory :public Memory &#123; public: virtual void storage() &#123; cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl; &#125; &#125;; void test01() &#123; &#x2F;&#x2F;第一台电脑零件 CPU * intelCpu &#x3D; new IntelCPU; VideoCard * intelCard &#x3D; new IntelVideoCard; Memory * intelMem &#x3D; new IntelMemory; cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl; &#x2F;&#x2F;创建第一台电脑 Computer * computer1 &#x3D; new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; &#x2F;&#x2F;第二台电脑组装 Computer * computer2 &#x3D; new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; &#x2F;&#x2F;第三台电脑组装 Computer * computer3 &#x3D; new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3; &#125; 5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 ==&lt; fstream &gt;== 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件5.1.1写文件 写文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ofstream ofs; 打开文件 ofs.open(“文件路径”,打开方式); 写数据 ofs &lt;&lt; “写入的数据”; 关闭文件 ofs.close(); 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios:: out 示例： #include &lt;fstream&gt; void test01() &#123; ofstream ofs; ofs.open(&quot;test.txt&quot;, ios::out); ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; ofs.close(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多 读文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ifstream ifs; 打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式); 读数据 四种方式读取 关闭文件 ifs.close(); 示例： #include &lt;fstream&gt; #include &lt;string&gt; void test01() &#123; ifstream ifs; ifs.open(&quot;test.txt&quot;, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; &#x2F;&#x2F;第一种方式 &#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;; &#x2F;&#x2F;while (ifs &gt;&gt; buf) &#x2F;&#x2F;&#123; &#x2F;&#x2F; cout &lt;&lt; buf &lt;&lt; endl; &#x2F;&#x2F;&#125; &#x2F;&#x2F;第二种 &#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;; &#x2F;&#x2F;while (ifs.getline(buf,sizeof(buf))) &#x2F;&#x2F;&#123; &#x2F;&#x2F; cout &lt;&lt; buf &lt;&lt; endl; &#x2F;&#x2F;&#125; &#x2F;&#x2F;第三种 &#x2F;&#x2F;string buf; &#x2F;&#x2F;while (getline(ifs, buf)) &#x2F;&#x2F;&#123; &#x2F;&#x2F; cout &lt;&lt; buf &lt;&lt; endl; &#x2F;&#x2F;&#125; char c; while ((c &#x3D; ifs.get()) !&#x3D; EOF) &#123; cout &lt;&lt; c; &#125; ifs.close(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为 ==ios::binary== 5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型 ：ostream&amp; write(const char * buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： #include &lt;fstream&gt; #include &lt;string&gt; class Person &#123; public: char m_Name[64]; int m_Age; &#125;; &#x2F;&#x2F;二进制文件 写文件 void test01() &#123; &#x2F;&#x2F;1、包含头文件 &#x2F;&#x2F;2、创建输出流对象 ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary); &#x2F;&#x2F;3、打开文件 &#x2F;&#x2F;ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); Person p &#x3D; &#123;&quot;张三&quot; , 18&#125;; &#x2F;&#x2F;4、写文件 ofs.write((const char *)&amp;p, sizeof(p)); &#x2F;&#x2F;5、关闭文件 ofs.close(); &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 总结： 文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char *buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： #include &lt;fstream&gt; #include &lt;string&gt; class Person &#123; public: char m_Name[64]; int m_Age; &#125;; void test01() &#123; ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; &#125; Person p; ifs.read((char *)&amp;p, sizeof(p)); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; int main() &#123; test01(); system(&quot;pause&quot;); return 0; &#125; 文件输入流对象 可以通过read函数，以二进制方式读数据","path":"2021/11/20/c-he-xin-bian-cheng/","date":"11-20","excerpt":"","tags":[]},{"title":"C++基础入门","text":"C++基础入门1 C++初识1.1 第一个C++程序编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 1.1.2 创建文件右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 1.1.3 编写代码#include&lt;iostream&gt; using namespace std; int main() &#123; cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 1.1.4 运行程序 1.2 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明== 多行注释： /* 描述信息 */ 通常放在一段代码的上方，==对该段代码做整体说明== 提示：编译器在编译代码时，会忽略注释的内容 1.3 变量作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： #include&lt;iostream&gt; using namespace std; int main() &#123; &#x2F;&#x2F;变量的定义 &#x2F;&#x2F;语法：数据类型 变量名 &#x3D; 初始值 int a &#x3D; 10; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 1.4 常量作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 ==通常在文件上方定义==，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值 ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改 示例： &#x2F;&#x2F;1、宏常量 #define day 7 int main() &#123; cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl; &#x2F;&#x2F;day &#x3D; 8; &#x2F;&#x2F;报错，宏常量不可以修改 &#x2F;&#x2F;2、const修饰变量 const int month &#x3D; 12; cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl; &#x2F;&#x2F;month &#x3D; 24; &#x2F;&#x2F;报错，常量是不可以修改的 system(&quot;pause&quot;); return 0; &#125; 1.5 关键字作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 1.6 标识符命名规则作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 2 数据类型C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 2.1 整型作用：整型变量表示的是==整数类型==的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字作用：利用sizeof关键字可以==统计数据类型所占内存大小== 语法： sizeof( 数据类型 / 变量) 示例： int main() &#123; cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 整型结论：==short &lt; int &lt;= long &lt;= long long== 2.3 实型（浮点型）作用：用于==表示小数== 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： int main() &#123; float f1 &#x3D; 3.14f; double d1 &#x3D; 3.14; cout &lt;&lt; f1 &lt;&lt; endl; cout &lt;&lt; d1&lt;&lt; endl; cout &lt;&lt; &quot;float sizeof &#x3D; &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl; cout &lt;&lt; &quot;double sizeof &#x3D; &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl; &#x2F;&#x2F;科学计数法 float f2 &#x3D; 3e2; &#x2F;&#x2F; 3 * 10 ^ 2 cout &lt;&lt; &quot;f2 &#x3D; &quot; &lt;&lt; f2 &lt;&lt; endl; float f3 &#x3D; 3e-2; &#x2F;&#x2F; 3 * 0.1 ^ 2 cout &lt;&lt; &quot;f3 &#x3D; &quot; &lt;&lt; f3 &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 2.4 字符型作用：字符型变量用于显示单个字符 语法：char ch = &#39;a&#39;; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用==1个字节==。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： int main() &#123; char ch &#x3D; &#39;a&#39;; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; sizeof(char) &lt;&lt; endl; &#x2F;&#x2F;ch &#x3D; &quot;abcde&quot;; &#x2F;&#x2F;错误，不可以用双引号 &#x2F;&#x2F;ch &#x3D; &#39;abcde&#39;; &#x2F;&#x2F;错误，单引号内只能引用一个字符 cout &lt;&lt; (int)ch &lt;&lt; endl; &#x2F;&#x2F;查看字符a对应的ASCII码 ch &#x3D; 97; &#x2F;&#x2F;可以直接用ASCII给字符型变量赋值 cout &lt;&lt; ch &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符作用：用于表示一些==不能显示出来的ASCII字符== 现阶段我们常用的转义字符有： \\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 *\\\\* 代表一个反斜线字符”&quot; 092 &#39; 代表一个单引号（撇号）字符 039 &quot; 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围09，af，A~F 3位16进制 示例： int main() &#123; cout &lt;&lt; &quot;\\\\&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\tHello&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 2.6 字符串型作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = &quot;字符串值&quot; 示例： int main() &#123; char str1[] &#x3D; &quot;hello world&quot;; cout &lt;&lt; str1 &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 注意：C风格的字符串要用双引号括起来 C++风格字符串： string 变量名 = &quot;字符串值&quot; 示例： int main() &#123; string str &#x3D; &quot;hello world&quot;; cout &lt;&lt; str &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;== 2.7 布尔类型 bool作用：布尔数据类型代表真或假的值 bool类型只有两个值： true — 真（本质是1） false — 假（本质是0） bool类型占==1个字节==大小 示例： int main() &#123; bool flag &#x3D; true; cout &lt;&lt; flag &lt;&lt; endl; &#x2F;&#x2F; 1 flag &#x3D; false; cout &lt;&lt; flag &lt;&lt; endl; &#x2F;&#x2F; 0 cout &lt;&lt; &quot;size of bool &#x3D; &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; &#x2F;&#x2F;1 system(&quot;pause&quot;); return 0; &#125; 2.8 数据的输入作用：用于从键盘获取数据 关键字：cin 语法： cin &gt;&gt; 变量 示例： int main()&#123; &#x2F;&#x2F;整型输入 int a &#x3D; 0; cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F;浮点型输入 double d &#x3D; 0; cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; &#x2F;&#x2F;字符型输入 char ch &#x3D; 0; cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; &#x2F;&#x2F;字符串型输入 string str; cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; &#x2F;&#x2F;布尔类型输入 bool flag &#x3D; true; cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl; cin &gt;&gt; flag; cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS; &#125; 3 运算符作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; – 前置递减 a=2; b=–a; a=1; b=1; – 后置递减 a=2; b=a–; a=1; b=2; 示例1： &#x2F;&#x2F;加减乘除 int main() &#123; int a1 &#x3D; 10; int b1 &#x3D; 3; cout &lt;&lt; a1 + b1 &lt;&lt; endl; cout &lt;&lt; a1 - b1 &lt;&lt; endl; cout &lt;&lt; a1 * b1 &lt;&lt; endl; cout &lt;&lt; a1 &#x2F; b1 &lt;&lt; endl; &#x2F;&#x2F;两个整数相除结果依然是整数 int a2 &#x3D; 10; int b2 &#x3D; 20; cout &lt;&lt; a2 &#x2F; b2 &lt;&lt; endl; int a3 &#x3D; 10; int b3 &#x3D; 0; &#x2F;&#x2F;cout &lt;&lt; a3 &#x2F; b3 &lt;&lt; endl; &#x2F;&#x2F;报错，除数不可以为0 &#x2F;&#x2F;两个小数可以相除 double d1 &#x3D; 0.5; double d2 &#x3D; 0.25; cout &lt;&lt; d1 &#x2F; d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：在除法运算中，除数不能为0 示例2： &#x2F;&#x2F;取模 int main() &#123; int a1 &#x3D; 10; int b1 &#x3D; 3; cout &lt;&lt; 10 % 3 &lt;&lt; endl; int a2 &#x3D; 10; int b2 &#x3D; 20; cout &lt;&lt; a2 % b2 &lt;&lt; endl; int a3 &#x3D; 10; int b3 &#x3D; 0; &#x2F;&#x2F;cout &lt;&lt; a3 % b3 &lt;&lt; endl; &#x2F;&#x2F;取模运算时，除数也不能为0 &#x2F;&#x2F;两个小数不可以取模 double d1 &#x3D; 3.14; double d2 &#x3D; 1.1; &#x2F;&#x2F;cout &lt;&lt; d1 % d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：只有整型变量可以进行取模运算 示例3： &#x2F;&#x2F;递增 int main() &#123; &#x2F;&#x2F;后置递增 int a &#x3D; 10; a++; &#x2F;&#x2F;等价于a &#x3D; a + 1 cout &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; 11 &#x2F;&#x2F;前置递增 int b &#x3D; 10; ++b; cout &lt;&lt; b &lt;&lt; endl; &#x2F;&#x2F; 11 &#x2F;&#x2F;区别 &#x2F;&#x2F;前置递增先对变量进行++，再计算表达式 int a2 &#x3D; 10; int b2 &#x3D; ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; &#x2F;&#x2F;后置递增先计算表达式，后对变量进行++ int a3 &#x3D; 10; int b3 &#x3D; a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 3.2 赋值运算符作用：用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： int main() &#123; &#x2F;&#x2F;赋值运算符 &#x2F;&#x2F; &#x3D; int a &#x3D; 10; a &#x3D; 100; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; +&#x3D; a &#x3D; 10; a +&#x3D; 2; &#x2F;&#x2F; a &#x3D; a + 2; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; -&#x3D; a &#x3D; 10; a -&#x3D; 2; &#x2F;&#x2F; a &#x3D; a - 2 cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; *&#x3D; a &#x3D; 10; a *&#x3D; 2; &#x2F;&#x2F; a &#x3D; a * 2 cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; &#x2F;&#x3D; a &#x3D; 10; a &#x2F;&#x3D; 2; &#x2F;&#x2F; a &#x3D; a &#x2F; 2; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F; %&#x3D; a &#x3D; 10; a %&#x3D; 2; &#x2F;&#x2F; a &#x3D; a % 2; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 3.3 比较运算符作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 &lt; 小于 4 &lt; 3 0 &gt; 大于 4 &gt; 3 1 &lt;= 小于等于 4 &lt;= 3 0 &gt;= 大于等于 4 &gt;= 1 1 示例： int main() &#123; int a &#x3D; 10; int b &#x3D; 20; cout &lt;&lt; (a &#x3D;&#x3D; b) &lt;&lt; endl; &#x2F;&#x2F; 0 cout &lt;&lt; (a !&#x3D; b) &lt;&lt; endl; &#x2F;&#x2F; 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; &#x2F;&#x2F; 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; &#x2F;&#x2F; 1 cout &lt;&lt; (a &gt;&#x3D; b) &lt;&lt; endl; &#x2F;&#x2F; 0 cout &lt;&lt; (a &lt;&#x3D; b) &lt;&lt; endl; &#x2F;&#x2F; 1 system(&quot;pause&quot;); return 0; &#125; 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 3.4 逻辑运算符作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 &amp;&amp; 与 a &amp;&amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 示例1：逻辑非 &#x2F;&#x2F;逻辑运算符 --- 非 int main() &#123; int a &#x3D; 10; cout &lt;&lt; !a &lt;&lt; endl; &#x2F;&#x2F; 0 cout &lt;&lt; !!a &lt;&lt; endl; &#x2F;&#x2F; 1 system(&quot;pause&quot;); return 0; &#125; 总结： 真变假，假变真 示例2：逻辑与 &#x2F;&#x2F;逻辑运算符 --- 与 int main() &#123; int a &#x3D; 10; int b &#x3D; 10; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;&#x2F;&#x2F; 1 a &#x3D; 10; b &#x3D; 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;&#x2F;&#x2F; 0 a &#x3D; 0; b &#x3D; 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;&#x2F;&#x2F; 0 system(&quot;pause&quot;); return 0; &#125; 总结：逻辑==与==运算符总结： ==同真为真，其余为假== 示例3：逻辑或 &#x2F;&#x2F;逻辑运算符 --- 或 int main() &#123; int a &#x3D; 10; int b &#x3D; 10; cout &lt;&lt; (a || b) &lt;&lt; endl;&#x2F;&#x2F; 1 a &#x3D; 10; b &#x3D; 0; cout &lt;&lt; (a || b) &lt;&lt; endl;&#x2F;&#x2F; 1 a &#x3D; 0; b &#x3D; 0; cout &lt;&lt; (a || b) &lt;&lt; endl;&#x2F;&#x2F; 0 system(&quot;pause&quot;); return 0; &#125; 逻辑==或==运算符总结： ==同假为假，其余为真== 4 程序流程结构C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构== 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构4.1.1 if语句作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 单行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125; 示例： int main() &#123; &#x2F;&#x2F;选择结构-单行if语句 &#x2F;&#x2F;输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score &#x3D; 0; cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl; &#x2F;&#x2F;if语句 &#x2F;&#x2F;注意事项，在if判断语句后面，不要加分号 if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 注意：if条件表达式后不要加分号 多行格式if语句：if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;; 示例： int main() &#123; int score &#x3D; 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 多条件的if语句：if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125; 示例： int main() &#123; int score &#x3D; 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： int main() &#123; int score &#x3D; 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; if (score &gt; 700) &#123; cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl; &#125; else if (score &gt; 650) &#123; cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl; &#125; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 4.1.2 三目运算符作用： 通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： int main() &#123; int a &#x3D; 10; int b &#x3D; 20; int c &#x3D; 0; c &#x3D; a &gt; b ? a : b; cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl; &#x2F;&#x2F;C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) &#x3D; 100; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 4.1.3 switch语句作用：执行多条件分支语句 语法： switch(表达式) &#123; case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break; &#125; 示例： int main() &#123; &#x2F;&#x2F;请给电影评分 &#x2F;&#x2F;10 ~ 9 经典 &#x2F;&#x2F; 8 ~ 7 非常好 &#x2F;&#x2F; 6 ~ 5 一般 &#x2F;&#x2F; 5分以下 烂片 int score &#x3D; 0; cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl; cin &gt;&gt; score; switch (score) &#123; case 10: case 9: cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl; break; case 8: cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl; break; case 7: case 6: cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl; break; default: cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl; break; &#125; system(&quot;pause&quot;); return 0; &#125; 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 4.2 循环结构4.2.1 while循环语句作用：满足循环条件，执行循环语句 语法： while(循环条件)&#123; 循环语句 &#125; 解释：==只要循环条件的结果为真，就执行循环语句== 示例： int main() &#123; int num &#x3D; 0; while (num &lt; 10) &#123; cout &lt;&lt; &quot;num &#x3D; &quot; &lt;&lt; num &lt;&lt; endl; num++; &#125; system(&quot;pause&quot;); return 0; &#125; 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例：==猜数字== 案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 4.2.2 do…while循环语句作用： 满足循环条件，执行循环语句 语法： do&#123; 循环语句 &#125; while(循环条件); 注意：与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件 示例： int main() &#123; int num &#x3D; 0; do &#123; cout &lt;&lt; num &lt;&lt; endl; num++; &#125; while (num &lt; 10); system(&quot;pause&quot;); return 0; &#125; 总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do…while语句，求出所有3位数中的水仙花数 4.2.3 for循环语句作用： 满足循环条件，执行循环语句 语法： for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125; 示例： int main() &#123; for (int i &#x3D; 0; i &lt; 10; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用 练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 4.2.4 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： int main() &#123; &#x2F;&#x2F;外层循环执行1次，内层循环执行1轮 for (int i &#x3D; 0; i &lt; 10; i++) &#123; for (int j &#x3D; 0; j &lt; 10; j++) &#123; cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 练习案例：乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 4.3 跳转语句4.3.1 break语句作用: 用于跳出==选择结构==或者==循环结构== break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： int main() &#123; &#x2F;&#x2F;1、在switch 语句中使用break cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl; int num &#x3D; 0; cin &gt;&gt; num; switch (num) &#123; case 1: cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl; break; &#125; system(&quot;pause&quot;); return 0; &#125; 示例2： int main() &#123; &#x2F;&#x2F;2、在循环语句中用break for (int i &#x3D; 0; i &lt; 10; i++) &#123; if (i &#x3D;&#x3D; 5) &#123; break; &#x2F;&#x2F;跳出循环语句 &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 示例3： int main() &#123; &#x2F;&#x2F;在嵌套循环语句中使用break，退出内层循环 for (int i &#x3D; 0; i &lt; 10; i++) &#123; for (int j &#x3D; 0; j &lt; 10; j++) &#123; if (j &#x3D;&#x3D; 5) &#123; break; &#125; cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 4.3.2 continue语句作用：在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： int main() &#123; for (int i &#x3D; 0; i &lt; 100; i++) &#123; if (i % 2 &#x3D;&#x3D; 0) &#123; continue; &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 注意：continue并没有使整个循环终止，而break会跳出循环 4.3.3 goto语句作用：可以无条件跳转语句 语法： goto 标记; 解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： int main() &#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; goto FLAG; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; FLAG: cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 5 数组5.1 概述所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1：数组中的每个==数据元素都是相同的数据类型== 特点2：数组是由==连续的内存==位置组成的 5.2 一维数组5.2.1 一维数组定义方式一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;; 数据类型 数组名[ ] = &#123; 值1，值2 ...&#125;; 示例 int main() &#123; &#x2F;&#x2F;定义方式1 &#x2F;&#x2F;数据类型 数组名[元素个数]; int score[10]; &#x2F;&#x2F;利用下标赋值 score[0] &#x3D; 100; score[1] &#x3D; 99; score[2] &#x3D; 85; &#x2F;&#x2F;利用下标输出 cout &lt;&lt; score[0] &lt;&lt; endl; cout &lt;&lt; score[1] &lt;&lt; endl; cout &lt;&lt; score[2] &lt;&lt; endl; &#x2F;&#x2F;第二种定义方式 &#x2F;&#x2F;数据类型 数组名[元素个数] &#x3D; &#123;值1，值2 ，值3 ...&#125;; &#x2F;&#x2F;如果&#123;&#125;内不足10个数据，剩余数据用0补全 int score2[10] &#x3D; &#123; 100, 90,80,70,60,50,40,30,20,10 &#125;; &#x2F;&#x2F;逐个输出 &#x2F;&#x2F;cout &lt;&lt; score2[0] &lt;&lt; endl; &#x2F;&#x2F;cout &lt;&lt; score2[1] &lt;&lt; endl; &#x2F;&#x2F;一个一个输出太麻烦，因此可以利用循环进行输出 for (int i &#x3D; 0; i &lt; 10; i++) &#123; cout &lt;&lt; score2[i] &lt;&lt; endl; &#125; &#x2F;&#x2F;定义方式3 &#x2F;&#x2F;数据类型 数组名[] &#x3D; &#123;值1，值2 ，值3 ...&#125;; int score3[] &#x3D; &#123; 100,90,80,70,60,50,40,30,20,10 &#125;; for (int i &#x3D; 0; i &lt; 10; i++) &#123; cout &lt;&lt; score3[i] &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 5.2.2 一维数组数组名一维数组名称的用途： 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例： int main() &#123; &#x2F;&#x2F;数组名用途 &#x2F;&#x2F;1、可以获取整个数组占用内存空间大小 int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl; &#x2F;&#x2F;2、可以通过数组名获取到数组首地址 cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl; cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl; &#x2F;&#x2F;arr &#x3D; 100; 错误，数组名是常量，因此不可以赋值 system(&quot;pause&quot;); return 0; &#125; 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小 练习案例1：五只小猪称体重 案例描述： 在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250}; 找出并打印最重的小猪体重。 练习案例2：数组元素逆置 案例描述：请声明一个5个元素的数组，并且将元素逆置. (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1); 5.2.3 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 int main() &#123; int arr[9] &#x3D; &#123; 4,2,8,0,5,7,1,3,9 &#125;; for (int i &#x3D; 0; i &lt; 9 - 1; i++) &#123; for (int j &#x3D; 0; j &lt; 9 - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp &#x3D; arr[j]; arr[j] &#x3D; arr[j + 1]; arr[j + 1] &#x3D; temp; &#125; &#125; &#125; for (int i &#x3D; 0; i &lt; 9; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 5.3 二维数组二维数组就是在一维数组上，多加一个维度。 5.3.1 二维数组定义方式二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;; 数据类型 数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;; 数据类型 数组名[ ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;; 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性== 示例： int main() &#123; &#x2F;&#x2F;方式1 &#x2F;&#x2F;数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] &#x3D; 1; arr[0][1] &#x3D; 2; arr[0][2] &#x3D; 3; arr[1][0] &#x3D; 4; arr[1][1] &#x3D; 5; arr[1][2] &#x3D; 6; for (int i &#x3D; 0; i &lt; 2; i++) &#123; for (int j &#x3D; 0; j &lt; 3; j++) &#123; cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#x2F;&#x2F;方式2 &#x2F;&#x2F;数据类型 数组名[行数][列数] &#x3D; &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;; int arr2[2][3] &#x3D; &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;; &#x2F;&#x2F;方式3 &#x2F;&#x2F;数据类型 数组名[行数][列数] &#x3D; &#123; 数据1，数据2 ,数据3，数据4 &#125;; int arr3[2][3] &#x3D; &#123; 1,2,3,4,5,6 &#125;; &#x2F;&#x2F;方式4 &#x2F;&#x2F;数据类型 数组名[][列数] &#x3D; &#123; 数据1，数据2 ,数据3，数据4 &#125;; int arr4[][3] &#x3D; &#123; 1,2,3,4,5,6 &#125;; system(&quot;pause&quot;); return 0; &#125; 总结：在定义二维数组时，如果初始化了数据，可以省略行数 5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例： int main() &#123; &#x2F;&#x2F;二维数组数组名 int arr[2][3] &#x3D; &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;; cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) &#x2F; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) &#x2F; sizeof(arr[0][0]) &lt;&lt; endl; &#x2F;&#x2F;地址 cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 5.3.3 二维数组应用案例考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案： int main() &#123; int scores[3][3] &#x3D; &#123; &#123;100,100,100&#125;, &#123;90,50,100&#125;, &#123;60,70,80&#125;, &#125;; string names[3] &#x3D; &#123; &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; &#125;; for (int i &#x3D; 0; i &lt; 3; i++) &#123; int sum &#x3D; 0; for (int j &#x3D; 0; j &lt; 3; j++) &#123; sum +&#x3D; scores[i][j]; &#125; cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 6 函数6.1 概述作用：将一段经常使用的代码封装起来，减少重复代码 一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。 6.2 函数的定义函数的定义一般主要有5个步骤： 1、返回值类型 2、函数名 3、参数表列 4、函数体语句 5、return 表达式 语法： 返回值类型 函数名 （参数列表） &#123; 函数体语句 return表达式 &#125; 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 示例：定义一个加法函数，实现两个数相加 &#x2F;&#x2F;函数定义 int add(int num1, int num2) &#123; int sum &#x3D; num1 + num2; return sum; &#125; 6.3 函数的调用功能：使用定义好的函数 语法： 函数名（参数） 示例： &#x2F;&#x2F;函数定义 int add(int num1, int num2) &#x2F;&#x2F;定义中的num1,num2称为形式参数，简称形参 &#123; int sum &#x3D; num1 + num2; return sum; &#125; int main() &#123; int a &#x3D; 10; int b &#x3D; 10; &#x2F;&#x2F;调用add函数 int sum &#x3D; add(a, b);&#x2F;&#x2F;调用时的a，b称为实际参数，简称实参 cout &lt;&lt; &quot;sum &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl; a &#x3D; 100; b &#x3D; 100; sum &#x3D; add(a, b); cout &lt;&lt; &quot;sum &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参 6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，==如果形参发生，并不会影响实参== 示例： void swap(int num1, int num2) &#123; cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 &#x3D; &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 &#x3D; &quot; &lt;&lt; num2 &lt;&lt; endl; int temp &#x3D; num1; num1 &#x3D; num2; num2 &#x3D; temp; cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 &#x3D; &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 &#x3D; &quot; &lt;&lt; num2 &lt;&lt; endl; &#x2F;&#x2F;return ; 当函数声明时候，不需要返回值，可以不写return &#125; int main() &#123; int a &#x3D; 10; int b &#x3D; 20; swap(a, b); cout &lt;&lt; &quot;mian中的 a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;mian中的 b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结： 值传递时，形参是修饰不了实参的 6.5 函数的常见样式常见的函数样式有4种 无参无返 有参无返 无参有返 有参有返 示例： &#x2F;&#x2F;函数常见样式 &#x2F;&#x2F;1、 无参无返 void test01() &#123; &#x2F;&#x2F;void a &#x3D; 10; &#x2F;&#x2F;无类型不可以创建变量,原因无法分配内存 cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl; &#x2F;&#x2F;test01(); 函数调用 &#125; &#x2F;&#x2F;2、 有参无返 void test02(int a) &#123; cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; &#125; &#x2F;&#x2F;3、无参有返 int test03() &#123; cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl; return 10; &#125; &#x2F;&#x2F;4、有参有返 int test04(int a, int b) &#123; cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl; int sum &#x3D; a + b; return sum; &#125; 6.6 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数的声明可以多次，但是函数的定义只能有一次 示例： &#x2F;&#x2F;声明可以多次，定义只能一次 &#x2F;&#x2F;声明 int max(int a, int b); int max(int a, int b); &#x2F;&#x2F;定义 int max(int a, int b) &#123; return a &gt; b ? a : b; &#125; int main() &#123; int a &#x3D; 100; int b &#x3D; 200; cout &lt;&lt; max(a, b) &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 6.7 函数的分文件编写作用：让代码结构更加清晰 函数分文件编写一般有4个步骤 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例： &#x2F;&#x2F;swap.h文件 #include&lt;iostream&gt; using namespace std; &#x2F;&#x2F;实现两个数字交换的函数声明 void swap(int a, int b); &#x2F;&#x2F;swap.cpp文件 #include &quot;swap.h&quot; void swap(int a, int b) &#123; int temp &#x3D; a; a &#x3D; b; b &#x3D; temp; cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl; &#125; &#x2F;&#x2F;main函数文件 #include &quot;swap.h&quot; int main() &#123; int a &#x3D; 100; int b &#x3D; 200; swap(a, b); system(&quot;pause&quot;); return 0; &#125; 7 指针7.1 指针的基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名； 示例： int main() &#123; &#x2F;&#x2F;1、指针的定义 int a &#x3D; 10; &#x2F;&#x2F;定义整型变量a &#x2F;&#x2F;指针定义语法： 数据类型 * 变量名 ; int * p; &#x2F;&#x2F;指针变量赋值 p &#x3D; &amp;a; &#x2F;&#x2F;指针指向变量a的地址 cout &lt;&lt; &amp;a &lt;&lt; endl; &#x2F;&#x2F;打印数据a的地址 cout &lt;&lt; p &lt;&lt; endl; &#x2F;&#x2F;打印指针变量p &#x2F;&#x2F;2、指针的使用 &#x2F;&#x2F;通过*操作指针变量指向的内存 cout &lt;&lt; &quot;*p &#x3D; &quot; &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 指针变量和普通变量的区别 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 &amp; 符号 获取变量的地址 总结2：利用指针可以记录地址 总结3：对指针变量解引用，可以操作指针指向的内存 7.3 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？ 示例： int main() &#123; int a &#x3D; 10; int * p; p &#x3D; &amp;a; &#x2F;&#x2F;指针指向数据a的地址 cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;* 解引用 cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; sizeof(double *) &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：所有指针类型在32位操作系统下是4个字节 7.4 空指针和野指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 示例1：空指针 int main() &#123; &#x2F;&#x2F;指针变量p指向内存地址编号为0的空间 int * p &#x3D; NULL; &#x2F;&#x2F;访问空指针报错 &#x2F;&#x2F;内存编号0 ~255为系统占用内存，不允许用户访问 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 野指针：指针变量指向非法的内存空间 示例2：野指针 int main() &#123; &#x2F;&#x2F;指针变量p指向内存地址编号为0x1100的空间 int * p &#x3D; (int *)0x1100; &#x2F;&#x2F;访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 7.5 const修饰指针const修饰指针有三种情况 const修饰指针 — 常量指针 const修饰常量 — 指针常量 const即修饰指针，又修饰常量 示例： int main() &#123; int a &#x3D; 10; int b &#x3D; 10; &#x2F;&#x2F;const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 &#x3D; &amp;a; p1 &#x3D; &amp;b; &#x2F;&#x2F;正确 &#x2F;&#x2F;*p1 &#x3D; 100; 报错 &#x2F;&#x2F;const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 &#x3D; &amp;a; &#x2F;&#x2F;p2 &#x3D; &amp;b; &#x2F;&#x2F;错误 *p2 &#x3D; 100; &#x2F;&#x2F;正确 &#x2F;&#x2F;const既修饰指针又修饰常量 const int * const p3 &#x3D; &amp;a; &#x2F;&#x2F;p3 &#x3D; &amp;b; &#x2F;&#x2F;错误 &#x2F;&#x2F;*p3 &#x3D; 100; &#x2F;&#x2F;错误 system(&quot;pause&quot;); return 0; &#125; 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量 7.6 指针和数组作用：利用指针访问数组中元素 示例： int main() &#123; int arr[] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; int * p &#x3D; arr; &#x2F;&#x2F;指向数组的指针 cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl; for (int i &#x3D; 0; i &lt; 10; i++) &#123; &#x2F;&#x2F;利用指针遍历数组 cout &lt;&lt; *p &lt;&lt; endl; p++; &#125; system(&quot;pause&quot;); return 0; &#125; 7.7 指针和函数作用：利用指针作函数参数，可以修改实参的值 示例： &#x2F;&#x2F;值传递 void swap1(int a ,int b) &#123; int temp &#x3D; a; a &#x3D; b; b &#x3D; temp; &#125; &#x2F;&#x2F;地址传递 void swap2(int * p1, int *p2) &#123; int temp &#x3D; *p1; *p1 &#x3D; *p2; *p2 &#x3D; temp; &#125; int main() &#123; int a &#x3D; 10; int b &#x3D; 20; swap1(a, b); &#x2F;&#x2F; 值传递不会改变实参 swap2(&amp;a, &amp;b); &#x2F;&#x2F;地址传递会改变实参 cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递 7.8 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; 示例： &#x2F;&#x2F;冒泡排序函数 void bubbleSort(int * arr, int len) &#x2F;&#x2F;int * arr 也可以写为int arr[] &#123; for (int i &#x3D; 0; i &lt; len - 1; i++) &#123; for (int j &#x3D; 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp &#x3D; arr[j]; arr[j] &#x3D; arr[j + 1]; arr[j + 1] &#x3D; temp; &#125; &#125; &#125; &#125; &#x2F;&#x2F;打印数组函数 void printArray(int arr[], int len) &#123; for (int i &#x3D; 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; &#125; int main() &#123; int arr[10] &#x3D; &#123; 4,3,6,9,1,2,10,8,7,5 &#125;; int len &#x3D; sizeof(arr) &#x2F; sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(&quot;pause&quot;); return 0; &#125; 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针 8 结构体8.1 结构体基本概念结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型 8.2 结构体定义和使用语法：struct 结构体名 &#123; 结构体成员列表 &#125;； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值…} 定义结构体时顺便创建变量 示例： &#x2F;&#x2F;结构体定义 struct student &#123; &#x2F;&#x2F;成员列表 string name; &#x2F;&#x2F;姓名 int age; &#x2F;&#x2F;年龄 int score; &#x2F;&#x2F;分数 &#125;stu3; &#x2F;&#x2F;结构体变量创建方式3 int main() &#123; &#x2F;&#x2F;结构体变量创建方式1 struct student stu1; &#x2F;&#x2F;struct 关键字可以省略 stu1.name &#x3D; &quot;张三&quot;; stu1.age &#x3D; 18; stu1.score &#x3D; 100; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl; &#x2F;&#x2F;结构体变量创建方式2 struct student stu2 &#x3D; &#123; &quot;李四&quot;,19,60 &#125;; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl; stu3.name &#x3D; &quot;王五&quot;; stu3.age &#x3D; 18; stu3.score &#x3D; 80; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结1：定义结构体时的关键字是struct，不可省略 总结2：创建结构体变量时，关键字struct可以省略 总结3：结构体变量利用操作符 ‘’.’’ 访问成员 8.3 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法： struct 结构体名 数组名[元素个数] = &#123; &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125; 示例： &#x2F;&#x2F;结构体定义 struct student &#123; &#x2F;&#x2F;成员列表 string name; &#x2F;&#x2F;姓名 int age; &#x2F;&#x2F;年龄 int score; &#x2F;&#x2F;分数 &#125; int main() &#123; &#x2F;&#x2F;结构体数组 struct student arr[3]&#x3D; &#123; &#123;&quot;张三&quot;,18,80 &#125;, &#123;&quot;李四&quot;,19,60 &#125;, &#123;&quot;王五&quot;,20,70 &#125; &#125;; for (int i &#x3D; 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0; &#125; 8.4 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt; 可以通过结构体指针访问结构体属性 示例： &#x2F;&#x2F;结构体定义 struct student &#123; &#x2F;&#x2F;成员列表 string name; &#x2F;&#x2F;姓名 int age; &#x2F;&#x2F;年龄 int score; &#x2F;&#x2F;分数 &#125;; int main() &#123; struct student stu &#x3D; &#123; &quot;张三&quot;,18,100, &#125;; struct student * p &#x3D; &amp;stu; p-&gt;score &#x3D; 80; &#x2F;&#x2F;指针通过 -&gt; 操作符可以访问成员 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员 8.5 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 示例： &#x2F;&#x2F;学生结构体定义 struct student &#123; &#x2F;&#x2F;成员列表 string name; &#x2F;&#x2F;姓名 int age; &#x2F;&#x2F;年龄 int score; &#x2F;&#x2F;分数 &#125;; &#x2F;&#x2F;教师结构体定义 struct teacher &#123; &#x2F;&#x2F;成员列表 int id; &#x2F;&#x2F;职工编号 string name; &#x2F;&#x2F;教师姓名 int age; &#x2F;&#x2F;教师年龄 struct student stu; &#x2F;&#x2F;子结构体 学生 &#125;; int main() &#123; struct teacher t1; t1.id &#x3D; 10000; t1.name &#x3D; &quot;老王&quot;; t1.age &#x3D; 40; t1.stu.name &#x3D; &quot;张三&quot;; t1.stu.age &#x3D; 18; t1.stu.score &#x3D; 100; cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl; cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题 8.6 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 示例： &#x2F;&#x2F;学生结构体定义 struct student &#123; &#x2F;&#x2F;成员列表 string name; &#x2F;&#x2F;姓名 int age; &#x2F;&#x2F;年龄 int score; &#x2F;&#x2F;分数 &#125;; &#x2F;&#x2F;值传递 void printStudent(student stu ) &#123; stu.age &#x3D; 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; &#125; &#x2F;&#x2F;地址传递 void printStudent2(student *stu) &#123; stu-&gt;age &#x3D; 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl; &#125; int main() &#123; student stu &#x3D; &#123; &quot;张三&quot;,18,100&#125;; &#x2F;&#x2F;值传递 printStudent(stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; &#x2F;&#x2F;地址传递 printStudent2(&amp;stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递 8.7 结构体中 const使用场景作用：用const来防止误操作 示例： &#x2F;&#x2F;学生结构体定义 struct student &#123; &#x2F;&#x2F;成员列表 string name; &#x2F;&#x2F;姓名 int age; &#x2F;&#x2F;年龄 int score; &#x2F;&#x2F;分数 &#125;; &#x2F;&#x2F;const使用场景 void printStudent(const student *stu) &#x2F;&#x2F;加const防止函数体中的误操作 &#123; &#x2F;&#x2F;stu-&gt;age &#x3D; 100; &#x2F;&#x2F;操作失败，因为加了const修饰 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl; &#125; int main() &#123; student stu &#x3D; &#123; &quot;张三&quot;,18,100 &#125;; printStudent(&amp;stu); system(&quot;pause&quot;); return 0; &#125; 8.8 结构体案例8.8.1 案例1案例描述： 学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值 最终打印出老师数据以及老师所带的学生数据。 示例： struct Student &#123; string name; int score; &#125;; struct Teacher &#123; string name; Student sArray[5]; &#125;; void allocateSpace(Teacher tArray[] , int len) &#123; string tName &#x3D; &quot;教师&quot;; string sName &#x3D; &quot;学生&quot;; string nameSeed &#x3D; &quot;ABCDE&quot;; for (int i &#x3D; 0; i &lt; len; i++) &#123; tArray[i].name &#x3D; tName + nameSeed[i]; for (int j &#x3D; 0; j &lt; 5; j++) &#123; tArray[i].sArray[j].name &#x3D; sName + nameSeed[j]; tArray[i].sArray[j].score &#x3D; rand() % 61 + 40; &#125; &#125; &#125; void printTeachers(Teacher tArray[], int len) &#123; for (int i &#x3D; 0; i &lt; len; i++) &#123; cout &lt;&lt; tArray[i].name &lt;&lt; endl; for (int j &#x3D; 0; j &lt; 5; j++) &#123; cout &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; &#125; &#125; &#125; int main() &#123; srand((unsigned int)time(NULL)); &#x2F;&#x2F;随机数种子 头文件 #include &lt;ctime&gt; Teacher tArray[3]; &#x2F;&#x2F;老师数组 int len &#x3D; sizeof(tArray) &#x2F; sizeof(Teacher); allocateSpace(tArray, len); &#x2F;&#x2F;创建数据 printTeachers(tArray, len); &#x2F;&#x2F;打印数据 system(&quot;pause&quot;); return 0; &#125; 8.8.2 案例2案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 五名英雄信息如下： &#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;, &#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;, &#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;, &#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;, &#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;, 示例： &#x2F;&#x2F;英雄结构体 struct hero &#123; string name; int age; string sex; &#125;; &#x2F;&#x2F;冒泡排序 void bubbleSort(hero arr[] , int len) &#123; for (int i &#x3D; 0; i &lt; len - 1; i++) &#123; for (int j &#x3D; 0; j &lt; len - 1 - i; j++) &#123; if (arr[j].age &gt; arr[j + 1].age) &#123; hero temp &#x3D; arr[j]; arr[j] &#x3D; arr[j + 1]; arr[j + 1] &#x3D; temp; &#125; &#125; &#125; &#125; &#x2F;&#x2F;打印数组 void printHeros(hero arr[], int len) &#123; for (int i &#x3D; 0; i &lt; len; i++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl; &#125; &#125; int main() &#123; struct hero arr[5] &#x3D; &#123; &#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;, &#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;, &#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;, &#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;, &#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;, &#125;; int len &#x3D; sizeof(arr) &#x2F; sizeof(hero); &#x2F;&#x2F;获取数组元素个数 bubbleSort(arr, len); &#x2F;&#x2F;排序 printHeros(arr, len); &#x2F;&#x2F;打印 system(&quot;pause&quot;); return 0; &#125;","path":"2021/11/20/c-ji-chu-ru-men/","date":"11-20","excerpt":"","tags":[{"name":"C++","slug":"C","permalink":"https://oxford561.github.io/tags/C/"}]},{"title":"Leetcode学习-栈和队列的互转","text":"栈和队列结构 队列是一种先进先出的数据结构，栈是一种先进后出的数据结构 栈实现队列队列的结构是先进先出的，基于栈这种先进后出的结构是无法直接实现队列的，这里采用的是双栈的结构来实现，简单理解就是一个栈 S1 用于存放 Push 进来的元素，而 S2 则是用于取元素使用的。 但是队列取元素取的是最先进去的那个元素，所以 S2 做的工作就是将 S1 存放的元素颠倒存放进 S2，简单说就是在取元素的时候，将 S1 当中的元素全部拿出来放进 S2，这样 S2 最上面的元素就是模拟队列的队头元素了。 后面继续取模拟队列元素的时候，只需要去取 S2 中的元素，当然如果 S2 当中没有元素则需要再将 S1 中的元素放进来就可以了。这里判断模拟队列为空的时候就需要对比 S1 和 S2 两个栈的元素是否为空了。 public class MyQueue &#123; private Stack&lt;int&gt; s1, s2; public MyQueue() &#123; s1 &#x3D; new Stack&lt;int&gt;(); s2 &#x3D; new Stack&lt;int&gt;(); &#125; public void Push(int x) &#123; s1.Push(x); &#125; public int Pop() &#123; &#x2F;&#x2F; 确保 S2 中有元素可取 Peek(); return s2.Pop(); &#125; public int Peek() &#123; &#x2F;&#x2F; 发现 S2 元素没有了 if (s2.Count &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 再从 S1 中拿元素存放 while (s1.Count !&#x3D; 0) &#123; s2.Push(s1.Pop()); &#125; &#125; &#x2F;&#x2F; 这里其实还需要对 S2 栈元素个数判断，防止异常 return s2.Peek(); &#125; public bool Empty() &#123; return s1.Count &#x3D;&#x3D; 0 &amp;&amp; s2.Count &#x3D;&#x3D; 0; &#125; &#125; 队列实现栈基于队列来实现栈的结构，没有上面那么麻烦，也不需要多个队列来做，这里只需要一个队列就可以了。 存放元素的操作依旧使用的队列入队操作，但是取元素的时候，需要考虑当前模拟栈的栈顶元素是队列的头元素也就是最小放进去的元素，直接取出元素是不符合栈的结构的，那么这个时候需要将队列的前几个元素全部出队，留下 2 个元素，然后将出队的元素添加到队尾。 之所以留下 2 个元素，是因为我们需要记录当前模拟栈顶的元素（倒数第一个是需要出队的，但是出队的同时倒数第二个就是模拟栈顶元素了） public class MyStack &#123; private Queue&lt;int&gt; q; private int top &#x3D; 0; public MyStack() &#123; q &#x3D; new Queue&lt;int&gt;(); &#125; public void Push(int x) &#123; q.Enqueue(x); top &#x3D; x; &#125; public int Pop() &#123; int size &#x3D; q.Count; &#x2F;&#x2F; 留下最后两个元素 while (size &gt; 2) &#123; q.Enqueue(q.Dequeue()); size--; &#125; top &#x3D; q.Peek();&#x2F;&#x2F; 原先倒数第二个元素就是栈顶元素了 q.Enqueue(q.Dequeue()); return q.Dequeue();&#x2F;&#x2F;原先倒数第一个元素是需要出队的 &#125; public int Top() &#123; return top; &#125; public bool Empty() &#123; return q.Count &#x3D;&#x3D; 0; &#125; &#125;","path":"2021/10/28/leetcode-xue-xi-zhan-he-dui-lie-de-hu-zhuan/","date":"10-28","excerpt":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"}]},{"title":"Leetcode学习-滑动窗口","text":"什么是滑动窗口滑动窗口也就是之前说过的双指针技巧，通过维护一个窗口，不断滑动，然后更新结果，其主要的应用场景就是在字符串的匹配上了，比如最小覆盖子串、最长无重复子串等。 滑动窗口的算法上确实维护着一个窗口，可实际理解起来还是有点麻烦，不过按照步骤划分的话也就如下的几步： 首先我们依旧通过声明双指针 left = right = 0。 right ++ ，不断遍历源字符串，直到遍历过的字符串（窗口）中已经找到覆盖需要匹配的字符串要求(或者满足某种条件) 然后 left++，缩小【left,right）的窗口，直到窗口中的字符串不符合匹配的字符串要求 重复 2 和 3，直到遍历完整个字符串 最短覆盖子串 输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot; 输出：&quot;BANC&quot; &#x2F;&#x2F; 滑动窗口（最小覆盖子串） “AD0BEC0DEBANC” “ABC” public static string MinWindow(string srcStr, string patter) &#123; &#x2F;&#x2F; 存储 需要识别的子串（A:1,B:1,C:1） Dictionary&lt;char, int&gt; need &#x3D; new Dictionary&lt;char, int&gt;(); &#x2F;&#x2F; 滑动窗口中的字符串(A:2,B:1,C:2) Dictionary&lt;char, int&gt; window &#x3D; new Dictionary&lt;char, int&gt;(); &#x2F;&#x2F; 拿到需要识别的子串数据 foreach (char c in patter) &#123; if (need.ContainsKey(c)) &#123; need[c]++; &#125; else &#123; need.Add(c, 1); &#125; &#125; int left &#x3D; 0; int right &#x3D; 0; int valid &#x3D; 0; int start &#x3D; 0; int len &#x3D; int.MaxValue; while(right &lt; srcStr.Length) &#123; char c &#x3D; srcStr[right]; &#x2F;&#x2F; 右移窗口 right++; &#x2F;&#x2F; 获取窗口中的符合 识别子串的字符进行缓存 if(need.ContainsKey(c)) &#123; if (window.ContainsKey(c)) &#123; window[c]++; &#125; else &#123; window.Add(c, 1); &#125; &#x2F;&#x2F; 符合一个就计数1个 if (window[c] &#x3D;&#x3D; need[c]) &#123; valid++; &#125; &#125; &#x2F;&#x2F; 这个时候已经找到了覆盖子串的字符串窗口进行左移缩小窗口 while(valid &#x3D;&#x3D; need.Count)&#x2F;&#x2F;存在重复的可能 &#123; if(right - left &lt; len) &#123; start &#x3D; left; len &#x3D; right - left; &#125; char d &#x3D; srcStr[left]; left++; if (need.ContainsKey(d)) &#123; if (window[d] &#x3D;&#x3D; need[d]) valid--; window[d]--; &#125; &#125; &#125; return len &#x3D;&#x3D; int.MaxValue ? &quot;&quot; : srcStr.Substring(start,len); &#125; 字符串排列顺序 输入：s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot; 输出：true 解释：s2 包含 s1 的排列之一 (&quot;ba&quot;). public static bool checkInclusion(string t, string s) &#123; &#x2F;&#x2F; 存储 需要识别的子串（A:1,B:1,C:1） Dictionary&lt;char, int&gt; need &#x3D; new Dictionary&lt;char, int&gt;(); &#x2F;&#x2F; 滑动窗口中的字符串(A:2,B:1,C:2) Dictionary&lt;char, int&gt; window &#x3D; new Dictionary&lt;char, int&gt;(); &#x2F;&#x2F; 拿到需要识别的子串数据 foreach (char c in t) &#123; if (need.ContainsKey(c)) &#123; need[c]++; &#125; else &#123; need.Add(c, 1); &#125; &#125; int left &#x3D; 0; int right &#x3D; 0; int valid &#x3D; 0; bool isExist &#x3D; false; while (right &lt; s.Length) &#123; char c &#x3D; s[right]; &#x2F;&#x2F; 右移窗口 right++; &#x2F;&#x2F; 获取窗口中的符合 识别子串的字符进行缓存 if (need.ContainsKey(c)) &#123; if (window.ContainsKey(c)) &#123; window[c]++; &#125; else &#123; window.Add(c, 1); &#125; &#x2F;&#x2F; 符合一个就计数1个 if (window[c] &#x3D;&#x3D; need[c]) &#123; valid++; &#125; &#125; &#x2F;&#x2F; 这个时候已经找到了覆盖子串的字符串窗口进行左移缩小窗口 while ((right -left)&gt;&#x3D;t.Length) &#123; if (valid &#x3D;&#x3D; need.Count) &#123; isExist &#x3D; true; break; &#125; char d &#x3D; s[left]; left++; if (need.ContainsKey(d)) &#123; if (window[d] &#x3D;&#x3D; need[d]) valid--; window[d]--; &#125; &#125; &#125; return isExist; &#125; 最长无重复子串 输入: s &#x3D; &quot;abcabcbb&quot; 输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 public static int LengthOfLongestSubstring(string s) &#123; Dictionary&lt;char, int&gt; window &#x3D; new Dictionary&lt;char, int&gt;(); int left &#x3D; 0, right &#x3D; 0; int res &#x3D; 0; &#x2F;&#x2F; 记录结果 while (right &lt; s.Length) &#123; char c &#x3D; s[right]; right++; &#x2F;&#x2F; 进行窗口内数据的一系列更新 if (window.ContainsKey(c)) &#123; window[c]++; &#125; else &#123; window.Add(c, 1); &#125; &#x2F;&#x2F; 判断左侧窗口是否要收缩 while (window.ContainsKey(c) &amp;&amp; window[c] &gt; 1) &#123; char d &#x3D; s[left]; left++; &#x2F;&#x2F; 进行窗口内数据的一系列更新 window[d]--; &#125; &#x2F;&#x2F; 在这里更新答案 if ((right - left) &gt; res) &#123; res &#x3D; right - left; &#125; &#125; return res; &#125;","path":"2021/10/27/leetcode-xue-xi-hua-dong-chuang-kou/","date":"10-27","excerpt":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"}]},{"title":"Leetcode学习-链表的环与相交","text":"链表结构public class ListNode &#123; public int val; public ListNode next; public ListNode(int val &#x3D; 0, ListNode next &#x3D; null) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; &#125; 链表是否包含环什么是链表的环链表中环的结构字面意思就是在链表的结构中，末尾链表节点不再指向空对象，而是让末尾链表节点指向其它节点，使得整体的链表结构不再是一条顺序的线，而变成了一个环形的状态。 判断链表中是否存在环的情况，解决方案也是使用的快慢指针，依照上次说过的寻找链表中点的代码逻辑，检测链表中的是否存在环，也只不过在遍历链表的时候调整下判断条件即可，如下： public static bool hasCycle(ListNode head) &#123; ListNode slow &#x3D; head; ListNode fast &#x3D; head; while(fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null) &#123; slow &#x3D; slow.next; fast &#x3D; fast.next.next; if(fast &#x3D;&#x3D; slow) &#123; return true; &#125; &#125; return false; &#125; 链表是否相交链表相交指的是多个链表的节点中存在汇聚的节点，使得多个链表最终汇集到一起，形象化理解就是多条小河流汇集到一条大河流的感觉。但是要解决这类相交问题，比较麻烦的一点是多个链表的长度是不一样的，无法直接通过遍历链表的方式得到相交的节点，节点之间也不一一对应。 当然处理链表中节点是否相同，其实直接用 HashSet（不重复元素集合）去收集链表节点对象，然后逐一对照就能得到答案。不过除去这种使用额外空间的方式，还有更直接的方式嘛。 确实是有的，解决问题的关键在于，通过某种方式让多个链表的节点能够在遍历的时候同时到达相交的节点。这里的解决方式就是，让这 2 个（多个）链表进行拼接，使得最后产生 2 个（多个）节点数目相同的链表，再进行逐一遍历即可。 public static ListNode GetIntersectionNode(ListNode headA,ListNode headB) &#123; &#x2F;&#x2F; p1 指向 A 链表头结点，p2 指向 B 链表头结点 ListNode p1 &#x3D; headA, p2 &#x3D; headB; while (p1 !&#x3D; p2) &#123; &#x2F;&#x2F; p1 走一步，如果走到 A 链表末尾，转到 B 链表 if (p1 &#x3D;&#x3D; null) p1 &#x3D; headB; else p1 &#x3D; p1.next; &#x2F;&#x2F; p2 走一步，如果走到 B 链表末尾，转到 A 链表 if (p2 &#x3D;&#x3D; null) p2 &#x3D; headA; else p2 &#x3D; p2.next; &#125; return p1; &#125;","path":"2021/10/27/leetcode-xue-xi-lian-biao-de-huan-yu-xiang-jiao/","date":"10-27","excerpt":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"}]},{"title":"Leetcode学习-查找链表元素","text":"什么是链表 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 链表节点代码： public class ListNode &#123; public int val; public ListNode next; public ListNode(int val &#x3D; 0, ListNode next &#x3D; null) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; &#125; 生成单链表： ListNode head &#x3D; new ListNode(0); ListNode one &#x3D; new ListNode(1); head.next &#x3D; one; ListNode two &#x3D; new ListNode(2); one.next &#x3D; two; ListNode three &#x3D; new ListNode(3); two.next &#x3D; three; ListNode four &#x3D; new ListNode(4); three.next &#x3D; four; &#x2F;&#x2F; head(0)-&gt;one(1)-&gt;two(2)-&gt;three(3)-&gt;four(4)-&gt;null 遍历链表： ListNode temp &#x3D; head; while(temp!&#x3D;null) &#123; temp &#x3D; temp.next; &#125; 单链表的倒数第 k 个节点链表不像数组那般可以直接通过下标进行数值的获取，访问第 k 节点，只需要从头开始遍历链表计数即可，但是对于获取链表的倒数第 k 个节点，就不是这般容易了。 一般的做法： 首先遍历链表，遍历的过程中进行计数，得到链表的长度 n 那么重新遍历一次链表直到 n-k 个节点也就得到了倒数第 k 个节点了 但是这种通用的做法需要遍历链表两次才能得到答案，那能不能一次遍历链表就得到结果呢？ 双指针做法： 声明 2 个指针 p1 和 p2 让 p1 先走 k 步 然后 p1 和 p2 一起走，等 p1 走到底了，p2 就到了倒数第 k 的位置 public static int FindLastKNode(ListNode node, int k) &#123; ListNode p1 &#x3D; node; ListNode p2 &#x3D; node; for (int i &#x3D; 0; i &lt; k; i++) &#123; p1 &#x3D; p1.next; &#125; while (p1 !&#x3D; null) &#123; p1 &#x3D; p1.next; p2 &#x3D; p2.next; &#125; return p2.val; &#125; 单链表的中点由于我们无法快速得到单链表的长度，光是遍历一次链表的话，可以采用「快慢指针」的方式进行求解。 每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 public static int FindMiddle(ListNode node) &#123; ListNode slow &#x3D; node; ListNode fast &#x3D; node; while (fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null) &#123; slow &#x3D; slow.next; fast &#x3D; fast.next.next; &#125; return slow.val; &#125;","path":"2021/10/27/leetcode-xue-xi-cha-zhao-lian-biao-yuan-su/","date":"10-27","excerpt":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"}]},{"title":"二分搜索算法","text":"什么是二分搜索二分搜索也称折半查找，是一种基于有序数组的查找特定元素的搜索算法。 搜索的过程是在有序数组的中间开始的，如果中间的元素刚好是我们希望查找到的元素，则提前搜索结束，返回元素的位置下标即可；如果我们查找的元素大于中间元素，则在数组大于中间元素的一半继续查找，同样的要是我们查找的元素小于中间元素，则在数组小于中间元素的一半继续查找。最后查找完数组的所有空间还没有返回特定元素的下标则代表没有查找到。 二分搜索算法每一次的查找都会缩小搜索范围的一半，以更快的速度进行查找。 基础的二分搜索public static int BinarySearch(int[] nums, int target) &#123; int left &#x3D; 0; int right &#x3D; nums.Length - 1; int mid &#x3D; 0; while (left &lt;&#x3D; right) &#123; mid &#x3D; left + (right - left) &#x2F; 2;&#x2F;&#x2F; 防止溢出 if (nums[mid] &#x3D;&#x3D; target) &#123; return mid; &#125; else if (nums[mid] &gt; target) &#123; right &#x3D; mid - 1; &#125; else if (nums[mid] &lt; target) &#123; left &#x3D; mid + 1; &#125; &#125; return -1; &#125; 这里的二分搜索代码中，需要注意的有以下几点： right 的赋值是 nums.Length - 1,而不是 数组的长度 while 循环中的条件是 &lt;= 而不是 &lt;（前者查遍所有元素，后者会遗漏元素） mid的赋值是这样的，mid = left + (right - left) / 2，为的就是防止（left+right）数值溢出 left 和 right 的赋值是 mid + 1 以及 mid - 1（因为 mid 已经搜索过了） 寻找左边界的二分搜索有序数组中的元素并不是没有重复元素，如果在使用二分搜索的时候遇到重复元素，如何定位具体要求下的位置，这对于基础的二分搜索就有更高要求了。 寻找左边界的二分搜索，就是能够查找到重复元素最左边的位置。 public static int BinarySearchLeft(int[] nums,int target) &#123; int left &#x3D; 0; int right &#x3D; nums.Length - 1; int mid &#x3D; 0; while (left &lt;&#x3D; right) &#123; mid &#x3D; left + (right - left) &#x2F; 2;&#x2F;&#x2F; 防止溢出 if (nums[mid] &#x3D;&#x3D; target) &#123; right &#x3D; mid - 1; &#125; else if (nums[mid] &gt; target) &#123; right &#x3D; mid - 1; &#125; else if (nums[mid] &lt; target) &#123; left &#x3D; mid + 1; &#125; &#125; &#x2F;&#x2F; 最后要检查 left 越界的情况 if (left &gt;&#x3D; nums.Length || nums[left] !&#x3D; target) return -1; return left; &#125; 上述代码大体和基础的二分搜索代码差不多，只不过在查找到特定元素后，不是直接返回特定元素的位置，而是将搜索范围进一步缩小开始继续搜索，直至找到最左边的元素位置。（注意 left 的越界情况） 寻找右边界的二分搜索有边界搜索问题和左边界搜索是差不多的，就不赘述了。 public static int BinarySearchRight(int[] nums, int target) &#123; int left &#x3D; 0; int right &#x3D; nums.Length - 1; int mid &#x3D; 0; while (left &lt;&#x3D; right) &#123; mid &#x3D; left + (right - left) &#x2F; 2;&#x2F;&#x2F; 防止溢出 if (nums[mid] &#x3D;&#x3D; target) &#123; left &#x3D; mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right &#x3D; mid - 1; &#125; else if (nums[mid] &lt; target) &#123; left &#x3D; mid + 1; &#125; &#125; &#x2F;&#x2F; 最后要检查 right 越界的情况 if (right &lt; 0 || nums[right] !&#x3D; target) return -1; return right; &#125;","path":"2021/10/23/leetcode-xue-xi-er-fen-sou-suo-suan-fa/","date":"10-23","excerpt":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"}]},{"title":"Leetcode学习-回文串的判断","text":"什么是回文串回文串就是正着读和反着读都一样的字符串，比如 aba 和 abba 都是回文串，字符串存在对称性就是了。 最长回文串要寻找一段字符串中的回文串，核心就是使用双指针,也就是聚焦字符串的中间开始向两边扩撒来判断回文串，但凡符合要求的就是回文串。 当然如果需要找寻最长的回文串，无非遍历整个字符串的所有节点一次进行回文串的判断，得到最长回文串罢了。 双指针解法： &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 寻找固定位置两边的回文串 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;s&quot;&gt;字符串&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;l&quot;&gt;左指针下标&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;r&quot;&gt;右指针下标&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static string Palindrome(string s,int l,int r) &#123; char[] arr &#x3D; s.ToCharArray(); while (l &gt;&#x3D; 0 &amp;&amp; r&lt;s.Length&amp;&amp; arr[l] &#x3D;&#x3D; arr[r]) &#123; l--; r++; &#125; return s.Substring(l+1,r-l-1); &#125; 寻找最长回文串： &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 寻找最长回文串 (aba,abba) &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;s&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static string LongestPalindrome(string s) &#123; string res &#x3D; &quot;&quot;; for (int i &#x3D; 0; i &lt; s.Length; i++) &#123; &#x2F;&#x2F; 以 s[i] 为中心的最长回文子串 string s1 &#x3D; Palindrome(s, i, i); &#x2F;&#x2F; 以 s[i] 和 s[i+1] 为中心的最长回文子串 string s2 &#x3D; Palindrome(s, i, i + 1); &#x2F;&#x2F; res &#x3D; longest(res, s1, s2) res &#x3D; res.Length &gt; s1.Length ? res : s1; res &#x3D; res.Length &gt; s2.Length ? res : s2; &#125; return res; &#125; 这里寻找最长回文串的代码中，声明了两种找寻方式，这也是针对不同回文串（奇数和偶数）的解决方法，这才有的双指针输入参数的意义，最后比较最长的那个字符串即可。","path":"2021/10/23/leetcode-xue-xi-hui-wen-chuan-de-pan-duan/","date":"10-23","excerpt":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"}]},{"title":"Leetcode学习-前缀和","text":"快速索引一个区间内的元素之和 1、区间和检索测试用例 输入：[“NumArray”, “sumRange”, “sumRange”, “sumRange”][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]] 输出：[null, 1, -1, -3] 解释：NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1))numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1)) 普通解法： public class NumArray &#123; private int[] arr &#x3D; null; public NumArray(int[] nums) &#123; arr &#x3D; nums; &#125; public int SumRange(int left, int right) &#123; int res &#x3D; 0; for (int i &#x3D; left; i &lt;&#x3D; right; i++) &#123; res +&#x3D; arr[i]; &#125; return res; &#125; &#125; 前缀和解法： public class NumArray &#123; private int[] preSum &#x3D; null; public NumArray(int[] nums) &#123; preSum &#x3D; new int[nums.Length+1]; for(int i &#x3D; 1;i&lt; preSum.Length;i++)&#123; preSum[i] &#x3D; preSum[i-1]+nums[i-1]; &#125; &#125; public int SumRange(int left, int right) &#123; return preSum[right+1]- preSum[left]; &#125; &#125;","path":"2021/10/23/leetcode-xue-xi-qian-zhui-he/","date":"10-23","excerpt":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"}]},{"title":"Leetcode学习-原地修改数组","text":"原地修改数组，避免数据的搬移 1、有序链表去重1.1 声明链表结构public class ListNode &#123; public int val; public ListNode next; public ListNode(int val&#x3D;0, ListNode next&#x3D;null) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; &#125; 1.2 去重函数原地修改的话，也就不能再产生新的容器进行数据的存储，只能在原先的数据结构中进行数据的修改，这里采用快慢指针的方式进行链表元素的遍历. fast 指针快速遍历整个链表，遇到不重复的元素就通知 slow 指针前进，最后 fast 指针遍历完成则去重任务也就完成了。 public ListNode DeleteDuplicates(ListNode head) &#123; if (head &#x3D;&#x3D; null) return null; ListNode slow, fast; slow &#x3D; head; fast &#x3D; head; while(fast !&#x3D; null) &#123; if(fast.val !&#x3D; slow.val) &#123; slow.next &#x3D; fast; slow &#x3D; slow.next; &#125; fast &#x3D; fast.next; &#125; slow.next &#x3D; null; return head; &#125; 2、移除元素输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] public int RemoveElement(int[] nums, int val) &#123; int fast &#x3D; 0, slow &#x3D; 0; while (fast &lt; nums.Length) &#123; if (nums[fast] !&#x3D; val) &#123; nums[slow] &#x3D; nums[fast]; slow++; &#125; fast++; &#125; return slow; &#125;","path":"2021/10/23/leetcode-xue-xi-yuan-di-xiu-gai-shu-zu/","date":"10-23","excerpt":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"}]},{"title":"Protobuf 自动化","text":"Protobuf 标签问题之前有提到说，但凡序列化的对象都需要打上标签，像下面这种的。 [ProtoContract] [Serializable] class Student &#123; [ProtoMember(1)] public string name; [ProtoMember(2)] public int age; [ProtoMember(3)] public Address address; &#125; [ProtoContract] [Serializable] class Address &#123; [ProtoMember(1)] public string province; &#125; 不过对于这种手动打标签的方式，每次新增对象都去一个个添加标签是很繁琐的，而且也容易出现纰漏，那么有没有什么比较便捷的方式解决这样的情况呢？ 答案是有的，protobuf 提供了批处理序列化对象的方式。 Protobuf 自动化声明 proto 文件（定义协议格式）通过构建一个后缀为 .proto 的文件，里面填充关于所需要序列化对象的结构，比如 ProtoList.proto。 syntax&#x3D;&quot;proto2&quot;; package Protocol; message Address&#123; required string province &#x3D; 1; repeated string testLst &#x3D; 2; optional string other &#x3D; 3; &#125; message Student&#123; required string name &#x3D; 1; required int32 age &#x3D; 2; required Address address &#x3D; 3; &#125; syntax 代表着使用的是 proto2 的语法，目前 protobuf 已经有了 proto3 的语法，但是 proto2 的语法范围更广一点。 package 对于C#来说，这个协议封装在 Protocol 命名空间中，后续使用这里面的对象时需要先引入这个命名空间。 message 是包含一系列类型字段的集合，protobuf 提供了一些简单的数据类型，包括： bool int32 float double string 当然也存在其它类型，比如代码中 Address 也可以作为 Student 的数据类型，在数据类型后面的 =1、=2 表示的当前 message 的顺位。 对于数据类型前面的修饰符，protobuf 大体提供下面几种： required：这是是必须提供的，声明了就必须有的字段 optional：表示可选的字段，也就是可以没有数据 repeated：这个字段表示可以重复任意次数，可作为 List 使用 编译 .proto 文件咱们已经创建了一个 .proto 文件， 下面就需要调用 protobuf 提供的编译工具对这个文件进行处理，得到我们需要的 C# 序列化对象脚本。 关于获取 protobuf 提供的编译工具，可以到 protobuf-net github 地址获取源码，从里面获取 protoc.exe 以及 protogen.zip（针对windows平台）里面的东西。 获取到 protobuf 的编译工具 protoc 以及 protogen ，然后就是使用命令行针对 .proto 文件进行处理。 调用工具命令生成，进入到能够访问工具的地址，执行下面命令（protoc 命令也是可以的）： protogen.exe –csharp_out=outPath ProtoList.proto protogen.exe “生成C#语言协议”=“生成的路径” 需要的协议模板 执行完命令后会生成一个 C# 脚本文件，里面展示着之前声明的协议结构（不需要人工修改，有更改再直接生成） &#x2F;&#x2F; This file was generated by a tool; you should avoid making direct changes. &#x2F;&#x2F; Consider using &#39;partial classes&#39; to extend these types &#x2F;&#x2F; Input: ProtoList.proto #pragma warning disable CS1591, CS0612, CS3021, IDE1006 namespace Protocol &#123; [global::ProtoBuf.ProtoContract()] public partial class Address : global::ProtoBuf.IExtensible &#123; private global::ProtoBuf.IExtension __pbn__extensionData; global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing) &#x3D;&gt; global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing); [global::ProtoBuf.ProtoMember(1, Name &#x3D; @&quot;province&quot;, IsRequired &#x3D; true)] public string Province &#123; get; set; &#125; [global::ProtoBuf.ProtoMember(2, Name &#x3D; @&quot;testLst&quot;)] public global::System.Collections.Generic.List&lt;string&gt; testLsts &#123; get; &#125; &#x3D; new global::System.Collections.Generic.List&lt;string&gt;(); [global::ProtoBuf.ProtoMember(3, Name &#x3D; @&quot;other&quot;)] [global::System.ComponentModel.DefaultValue(&quot;&quot;)] public string Other &#123; get &#123; return __pbn__Other ?? &quot;&quot;; &#125; set &#123; __pbn__Other &#x3D; value; &#125; &#125; public bool ShouldSerializeOther() &#x3D;&gt; __pbn__Other !&#x3D; null; public void ResetOther() &#x3D;&gt; __pbn__Other &#x3D; null; private string __pbn__Other; &#125; [global::ProtoBuf.ProtoContract()] public partial class Student : global::ProtoBuf.IExtensible &#123; private global::ProtoBuf.IExtension __pbn__extensionData; global::ProtoBuf.IExtension global::ProtoBuf.IExtensible.GetExtensionObject(bool createIfMissing) &#x3D;&gt; global::ProtoBuf.Extensible.GetExtensionObject(ref __pbn__extensionData, createIfMissing); [global::ProtoBuf.ProtoMember(1, Name &#x3D; @&quot;name&quot;, IsRequired &#x3D; true)] public string Name &#123; get; set; &#125; [global::ProtoBuf.ProtoMember(2, Name &#x3D; @&quot;age&quot;, IsRequired &#x3D; true)] public int Age &#123; get; set; &#125; [global::ProtoBuf.ProtoMember(3, Name &#x3D; @&quot;address&quot;, IsRequired &#x3D; true)] public Address Address &#123; get; set; &#125; &#125; &#125; #pragma warning restore CS1591, CS0612, CS3021, IDE1006 生成协议的过程中，命令提示框会显示相关信息，如果 .proto 文件编写有错误也会在生成的时候显示出来，解决书写错误才能最终生成协议文件。 上述的生成C#协议文件，如果觉得命令敲得不方便，可以采用批处理的方式，将命令写进批处理程序中。 生成后的协议对象属性基本都是大写开头…","path":"2021/10/23/protobuf-zi-dong-hua/","date":"10-23","excerpt":"","tags":[{"name":"C#","slug":"C","permalink":"https://oxford561.github.io/tags/C/"}]},{"title":"Protobuf 的基本使用","text":"什么是 Protobuf？ Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。 Protobuf 的优势 序列化和反序列化速度很快 与语言平台无关，可以实现跨语言平台的数据转换 数据能实现高强度的压缩，占用空间会很小 扩展性和兼容性好，更新数据结构后也能兼容旧版本 Protobuf 的基本使用（protobuf-net版本）Protobuf 有很多个语言版本，对于 C# 而言，没有采用 Google 的版本，使用的是 protobuf-net 。 protobuf-net 是一个基于合约的 .NET 代码序列化器，它恰好以谷歌设计的“协议缓冲区”序列化格式写入数据。但是，该 API 与 Google 的非常不同，并且遵循典型的 .NET 模式（它在使用上具有广泛的可比性XmlSerializer，例如DataContractSerializer、 等）。它应该适用于大多数编写标准类型并可以使用属性的 .NET 语言。 Protobuf 对象相对于常规版序列化对象而言，Protobuf 针对对象添加了 「 ProtoContract」 标签，对于每个对象下的成员使用 「 ProtoMember」 标签，序号代表其所处的位置。 [ProtoContract] [Serializable] class Student &#123; [ProtoMember(1)] public string name; [ProtoMember(2)] public int age; [ProtoMember(3)] public Address address; &#125; [ProtoContract] [Serializable] class Address &#123; [ProtoMember(1)] public string province; &#125; Protobuf 序列化public static byte[] Serialize(Student stu) &#123; byte[] bytes &#x3D; null; using (MemoryStream ms &#x3D; new MemoryStream()) &#123; Serializer.Serialize(ms, stu); bytes &#x3D; new byte[ms.Length]; Buffer.BlockCopy(ms.GetBuffer(), 0, bytes, 0, (int)ms.Length); &#125; return bytes; &#125; Protobuf 反序列化public static Student DeSerialize(byte[] bytes) &#123; Student stu &#x3D; null; using (MemoryStream ms &#x3D; new MemoryStream(bytes)) &#123; stu &#x3D; Serializer.Deserialize&lt;Student&gt;(ms); &#125; return stu; &#125; Protobuf 读写文件&#x2F;&#x2F; 写入文件 using(FileStream file &#x3D; File.Create(&quot;student.bytes&quot;)) &#123; Serializer.Serialize(file, student); &#125; &#x2F;&#x2F; 读取文件 using(FileStream file &#x3D; File.OpenRead(&quot;student.bytes&quot;)) &#123; Student newStu &#x3D; Serializer.Deserialize&lt;Student&gt;(file); Console.WriteLine(newStu.address.province); &#125;","path":"2021/10/18/protobuf-de-ji-ben-shi-yong/","date":"10-18","excerpt":"","tags":[{"name":"C#","slug":"C","permalink":"https://oxford561.github.io/tags/C/"}]},{"title":"C# 常规序列化方式","text":"序列化是什么？序列化就是将对象的状态信息转换为可以存储或传输形式的过程。 其实就是将对象持久化，比如说把对象保存为二进制或者是XML的方式。 可以将对象序列到流、磁盘、内存和网络等等。 相反，反序列化则是将存储或传输形式转换为对象的过程。 序列化对象序列化的对象需要在 class 上面添加 「 Serializable 」 标签，嵌套对象也是需要的。 [Serializable] class Student &#123; public string name; public int age; public Address address; &#125; [Serializable] class Address &#123; public string province; &#125; 序列化代码public static byte[] Serialize(Student stu) &#123; byte[] data &#x3D; null; MemoryStream ms &#x3D; new MemoryStream(); BinaryFormatter bf &#x3D; new BinaryFormatter(); try &#123; bf.Serialize(ms, stu); ms.Seek(0, SeekOrigin.Begin); data &#x3D; ms.ToArray(); &#125; catch (SerializationException e) &#123; Console.WriteLine(e.ToString()); &#125; finally &#123; ms.Close(); &#125; return data; &#125; 反序列化代码public static Student DeSerialize(byte[] bytes) &#123; Student newStu &#x3D; null; MemoryStream ms &#x3D; new MemoryStream(bytes); BinaryFormatter bf &#x3D; new BinaryFormatter(); try &#123; newStu &#x3D; (Student)bf.Deserialize(ms); &#125; catch (SerializationException e) &#123; Console.WriteLine(e.ToString()); &#125; finally &#123; ms.Close(); &#125; return newStu; &#125;","path":"2021/10/18/csharp-chang-gui-xu-lie-hua-fang-shi/","date":"10-18","excerpt":"","tags":[{"name":"C#","slug":"C","permalink":"https://oxford561.github.io/tags/C/"}]},{"title":"第一个CPP程序","text":"创建项目既然是学习C++，必然少不了我们的宇宙最好的IDE—VS，使用VS创建一个支持C++的空项目。 创建文件然后在创建好的工程里，源文件右击添加新建项，选择cpp文件进行代码文件的创建。 编写代码在 CPP 文件中编写如下的代码，便能够得到 Hello World的结果了，具体代码的作用暂且不管~ #include &lt;iostream&gt; using namespace std; int main() &#123; cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl; return 0; &#125; 运行程序写完代码在VS上点击运行按钮即可看到运行结果。","path":"2021/06/22/di-yi-ge-cpp-cheng-xu/","date":"06-22","excerpt":"","tags":[{"name":"C++","slug":"C","permalink":"https://oxford561.github.io/tags/C/"}]},{"title":"游泳初尝试","text":"今天下午终于迈出了第一步，跟着老婆下到小区的游泳池，前段时间办理的游泳卡用到了～ 泳池里来的人不多，主要是我们下午3点半开始做饭，四点半就吃完晚饭了，五点半来到这边，基本还有好多人还在家吃饭吧。 在岸边戴好帽子和眼镜，而且也带来了游泳圈，本来不太想带游泳圈的，毕竟我们这么大的人，不过我们都不会游泳，所以为了安全带了。 事实证明游泳圈确实是带对了，有了游泳圈，套在自己的身上是完全不怕沉下去的，我试过无论怎么翻身都稳稳漂在水上。 下水之后，主要还是看老婆表演，毕竟她比我有基础，我除了几年前在泰国下过水，基本都没有下水了，我老婆小时候就经常游，不过长大了也不是很会。 我们俩折腾了两个小时，我发现泳帽下拉可以盖住耳朵防止进水，泳镜也不会进水，然后我尝试憋气沉下去，发现问题不大，然后逐渐胆子变大，尝试憋气模仿其他人游泳的姿势，在水里折腾了几下，发现可以在水下前行，我老婆都惊呆了，我竟然可以憋气下潜游泳，憋气多久就能游多远，不过就是没气的话就慌了，时常呛水～ 然后又过了差不多一个小时，我基本掌握了憋气下潜游泳，不得不说我在游泳这方面是有天赋的！ 差不多就回来了，实在是很不错的经历，以后可以常来游泳池游泳！","path":"2021/06/21/you-yong-chu-chang-shi/","date":"06-21","excerpt":"","tags":[{"name":"日记随笔","slug":"日记随笔","permalink":"https://oxford561.github.io/tags/%E6%97%A5%E8%AE%B0%E9%9A%8F%E7%AC%94/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","path":"2021/06/16/hello-world/","date":"06-16","excerpt":"","tags":[]},{"title":"扑克牌—梅花5","text":"多用谷歌引擎多去搜一搜普通人可能遇到的问题，并且思考有哪些办法能帮助他们解决问题。这样操作的次数多了以后，你会发现自己寻找需求的敏锐度有极大的提升。","path":"2021/05/30/bu-ke-pai-mei-hua-5/","date":"05-30","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—梅花4","text":"不要心存侥幸，你觉得可能出bug的地方，很大几率就会有bug。 互联网是世界上最全，最大的“书”，在问别人之前，要先学会问搜索引擎。","path":"2021/05/30/bu-ke-pai-mei-hua-4/","date":"05-30","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—梅花3","text":"多去了解各种现成的接口、插件、库。可能有些工程师经常调侃自己为接口的调试员，其实无伤大雅，我们看中的是你独立解决问题的能力。这是一场开卷考试，如何更快地帮助公司解决问题，是最重要的。","path":"2021/05/30/bu-ke-pai-mei-hua-3/","date":"05-30","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—梅花2","text":"不要重复造轮子，虽然技术上的成就感很有价值，但是从长远回报来看，更多地去从商业角度考虑问题，可能会价值更大。","path":"2021/05/30/bu-ke-pai-mei-hua-2/","date":"05-30","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—梅花A","text":"对你而言时间是最宝贵的，如果说能用钱去节省你的时间，请不要节省。付费去获取信息，付费去买工具，付费去买别人的时间，付费去买别人的资源……相信我，节省出来的时间，可以创造出无数的价值。","path":"2021/05/30/bu-ke-pai-mei-hua-a/","date":"05-30","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"循环队列","text":"Python 数组实现循环队列~ # 循环队列 用数组实现 class CircularQueue(object): def __init__(self,max_size): self.max_size &#x3D; max_size self.data &#x3D; [None]*max_size self.front &#x3D; 0 self.rear &#x3D; 0 def isEmpty(self): return self.front &#x3D;&#x3D; self.rear def isFull(self): return (self.rear + 1)%self.max_size &#x3D;&#x3D; self.front def enqueue(self,value): if self.isFull(): print(&#39;循环队列满了！&#39;) return self.data[self.rear] &#x3D; value self.rear &#x3D; (self.rear + 1)%self.max_size def dequeue(self): if(self.isEmpty()): print(&quot;当前队列是空的！&quot;) return item &#x3D; self.data[self.front] self.front &#x3D; (self.front + 1)%self.max_size return item def showHead(self): if(self.isEmpty()): print(&quot;当前队列是空的！&quot;) return return self.data[self.front] def show(self): if(self.isEmpty()): print(&quot;当前队列是空的！&quot;) return print(&#39;遍历队列数据：&#39;) for i in range(self.front,self.front + self.size()): print(self.data[i%self.max_size]) def size(self): # 有效数据 return (self.rear + self.max_size - self.front)%self.max_size if __name__ &#x3D;&#x3D; &quot;__main__&quot;: aq &#x3D; CircularQueue(5) aq.enqueue(1) aq.enqueue(2) aq.enqueue(3) aq.enqueue(4) aq.dequeue() print(aq.showHead()) aq.show() aq.enqueue(5) # aq.show() print(aq.showHead()) aq.show()","path":"2021/05/27/xun-huan-dui-lie/","date":"05-27","excerpt":"Python 数组实现循环队列~","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://oxford561.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"顺序队列","text":"Python 数组实现顺序队列~ # 顺序队列 用数组实现的队列 # 运用 py list 特性实现 # class ArrayQueue(object): # def __init__(self): # self.data &#x3D; [] # def isEmpty(self): # return self.data &#x3D;&#x3D; [] # def enqueue(self,value): # self.data.insert(0,value) # def dequeue(self): # return self.data.pop() # def showHead(self): # print(&quot;数据长度 &quot;+str(len(self.data))) # return self.data[len(self.data)-1] # def show(self): # for i in self.data: # print(i) # 不用 py list 的特性实现 class ArrayQueue(object): def __init__(self,max_size): self.max_size &#x3D; max_size self.data &#x3D; [None]*max_size self.front &#x3D; 0 self.rear &#x3D; 0 def isEmpty(self): return self.front &#x3D;&#x3D; self.rear def isFull(self): return self.rear &#x3D;&#x3D; self.max_size def enqueue(self,value): if self.rear &#x3D;&#x3D; self.max_size: if self.front &#x3D;&#x3D; 0: print(&quot;当前队列满了！&quot;) return else: for i in range(0,self.rear - self.front): self.data[i] &#x3D; self.data[i+self.front] self.rear &#x3D; self.rear - self.front self.front &#x3D; 0 self.data[self.rear] &#x3D; value self.rear &#x3D; self.rear + 1 def dequeue(self): if(self.isEmpty()): print(&quot;当前队列是空的！&quot;) return item &#x3D; self.data[self.front] self.front &#x3D; self.front + 1 return item def showHead(self): if(self.isEmpty()): print(&quot;当前队列是空的！&quot;) return return self.data[self.front] def show(self): if(self.isEmpty()): print(&quot;当前队列是空的！&quot;) return print(&#39;遍历队列数据：&#39;) for i in range(self.front,self.rear): print(self.data[i]) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: aq &#x3D; ArrayQueue(5) aq.show() aq.enqueue(1) aq.enqueue(2) aq.enqueue(3) aq.enqueue(4) aq.enqueue(5) aq.enqueue(6) aq.show() print(&quot;出列： &quot;+str(aq.dequeue())) print(aq.showHead()) aq.dequeue() print(aq.showHead()) aq.show() aq.dequeue() aq.dequeue() aq.dequeue() aq.dequeue() aq.enqueue(1) aq.show()","path":"2021/05/27/shun-xu-dui-lie/","date":"05-27","excerpt":"Python 数组实现顺序队列~","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://oxford561.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"稀疏数组","text":"稀疏数组的实现方式~ # 稀疏数组 # 1 0 0 0 0 0 5 6 3 # 0 0 3 0 0 0 0 0 1 # 0 0 0 0 0 0 &#x3D;&gt; 1 2 3 # 0 0 0 0 2 0 3 4 2 # 0 0 0 0 0 0 def testSparseArray(): # 构建原始数组 initArr &#x3D; [[0]*6 for i in range(5)] initArr[0][0] &#x3D; 1 initArr[1][2] &#x3D; 3 initArr[3][4] &#x3D; 2 # 打印初始数组 for i in range(5): for j in range(6): print(str(initArr[i][j]) + &quot; &quot;,end&#x3D;&#39;&#39;) print(&quot;\\n&quot;) # 找到原始数组中的有效数据 sum &#x3D; 0 for i in range(5): for j in range(6): if initArr[i][j] !&#x3D; 0: sum &#x3D; sum + 1 print(&quot;sum:&quot;+str(sum)) # 构建稀疏数组 sparseArr &#x3D; [[0]*3 for i in range(sum+1)] sparseArr[0][0] &#x3D; len(initArr) sparseArr[0][1] &#x3D; len(initArr[0]) sparseArr[0][2] &#x3D; sum index &#x3D; 0 for i in range(5): for j in range(6): if initArr[i][j] !&#x3D; 0: index &#x3D; index + 1 sparseArr[index][0] &#x3D; i sparseArr[index][1] &#x3D; j sparseArr[index][2] &#x3D; initArr[i][j] # 打印稀疏数组 print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;) for i in range(len(sparseArr)): for j in range(len(sparseArr[0])): print(str(sparseArr[i][j]) + &quot; &quot;,end&#x3D;&#39;&#39;) print(&quot;\\n&quot;) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: testSparseArray()","path":"2021/05/27/xi-shu-shu-zu/","date":"05-27","excerpt":"稀疏数组的实现方式~","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://oxford561.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"扑克牌—红桃K","text":"多分享多付出，前期多给别人创造价值并且不计回报，从长远来看这些付出都是会成倍地回报给你的，特别是刚开始跟别人合作的时候，不要去计较短期的回报，没有太大意义，更多的是锻炼自己的视野、视角以及解决问题的能力。","path":"2021/05/20/bu-ke-pai-hong-tao-k/","date":"05-20","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃Q","text":"选对圈子跟对人，尽可能多去近距离接触，帮他做一些事情，短期来看可能回报比较少，但是长期来看价值非常大。","path":"2021/05/20/bu-ke-pai-hong-tao-q/","date":"05-20","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃J","text":"很多人总是会纳闷，身边一堆厉害的年轻人，总觉得自己是不是年纪有点大了，做一些事情比较晚了，这就是短期的考虑，从长期出发，我们的人生长着呢，放眼整个人生，你现在做任何事都不晚。 比努力更重要的是，永远要相信努力是有用的。","path":"2021/05/20/bu-ke-pai-hong-tao-j/","date":"05-20","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃10","text":"Think different，做点跟你身边大多数人不一样的事情，你会离平庸更远一点。 一个人最幸运的莫过于在年富力强的时候找到了自己的使命，希望大家都能尽快找到自己的使命，并且为之付出努力。","path":"2021/05/18/bu-ke-pai-hong-tao-10/","date":"05-18","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃9","text":"特立独行是对的，融入圈子也是对的，重点是想清楚自己向往怎样的生活，为此愿意付出怎样的代价。","path":"2021/05/18/bu-ke-pai-hong-tao-9/","date":"05-18","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"扑克牌—红桃8","text":"如果可能，尽快地去锻炼自己的写作能力，这对于你影响力的培养是非常有帮助的。这个世界正在奖赏那些有影响力的人，而表达是最快的获得影响力的方式。 表达，无外乎两种，一个写作，一个演讲；对于我们大多数人来说，写作是建立影响力最快的方式。","path":"2021/05/18/bu-ke-pai-hong-tao-8/","date":"05-18","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"Web前端概述","text":"说明：本文使用的部分插图来自Jon Duckett先生的*HTML and CSS: Design and Build Websites*一书，这是一本非常棒的前端入门书，有兴趣的读者可以在亚马逊或者其他网站上找到该书的购买链接。 HTML简史 1991年10月：一个非正式CERN（欧洲核子研究中心）文件首次公开18个HTML标签，这个文件的作者是物理学家蒂姆·伯纳斯-李，因此他是万维网的发明者，也是万维网联盟的主席。 1995年11月：HTML 2.0标准发布（RFC 1866）。 1997年1月：HTML 3.2作为W3C推荐标准发布。 1997年12月：HTML 4.0作为W3C推荐标准发布。 1999年12月：HTML4.01作为W3C推荐标准发布。 2008年1月：HTML5由W3C作为工作草案发布。 2011年5月：W3C将HTML5推进至“最终征求”（Last Call）阶段。 2012年12月：W3C指定HTML5作为“候选推荐”阶段。 2014年10月：HTML5作为稳定W3C推荐标准发布，这意味着HTML5的标准化已经完成。 HTML5新特性 引入原生多媒体支持（audio和video标签） 引入可编程内容（canvas标签） 引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签） 引入新的表单控件（日历、邮箱、搜索、滑条等） 引入对离线存储更好的支持（localStorage和sessionStorage） 引入对定位、拖放、WebSocket、后台任务等的支持 使用标签承载内容结构 html head title meta body 文本 标题（heading）和段落（paragraph） h1 ~ h6 p 上标（superscript）和下标（subscript） sup sub 空白（白色空间折叠） 折行（break）和水平标尺（horizontal ruler） br hr 语义化标签 加粗和强调 - strong 引用 - blockquote 缩写词和首字母缩写词 - abbr / acronym 引文 - cite 所有者联系信息 - address 内容的修改 - ins / del 列表（list） 有序列表（ordered list）- ol / li 无序列表（unordered list）- ul / li 定义列表（definition list）- dl / dt / dd 链接（anchor） 页面链接 锚链接 功能链接 图像（image） 图像存储位置 图像及其宽高 选择正确的图像格式 JPEG GIF PNG 矢量图 语义化标签 - figure / figcaption 表格（table） 基本的表格结构 - table / tr / td / th 表格的标题 - caption 跨行和跨列 - rowspan属性 / colspan属性 长表格 - thead / tbody / tfoot 表单（form） 重要属性 - action / method / enctype 表单控件（input）- type属性 文本框 - text / 密码框 - password / 数字框 - number 邮箱 - email / 电话 - tel / 日期 - date / 滑条 - range / URL - url / 搜索 - search 单选按钮 - radio / 复选按钮 - checkbox 文件上传 - file / 隐藏域 - hidden 提交按钮 - submit / 图像按钮 - image / 重置按钮 - reset 下拉列表 - select / option 文本域（多行文本）- textarea 组合表单元素 - fieldset / legend 音视频（audio / video） 视频格式和播放器 视频托管服务 添加视频的准备工作 video标签和属性 - autoplay / controls / loop / muted / preload / src audio标签和属性 - autoplay / controls / loop / muted / preload / src / width / height / poster 窗口（frame） 框架集（过时，不建议使用） - frameset / frame 内嵌窗口 - iframe 其他 文档类型 &lt;!doctype html&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;strict.dtd&quot;&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt; 注释 &lt;!-- 这是一段注释，注释不能够嵌套 --&gt; 属性 id：唯一标识 class：元素所属的类，用于区分不同的元素 title：元素的额外信息（鼠标悬浮时会显示工具提示文本） tabindex：Tab键切换顺序 contenteditable：元素是否可编辑 draggable：元素是否可拖拽 块级元素 / 行级元素 字符实体（实体替换符） 使用CSS渲染页面简介 CSS的作用 CSS的工作原理 规则、属性和值 常用选择器 颜色（color） 如何指定颜色 颜色术语和颜色对比 背景色 文本（text / font） 文本的大小和字型(font-size / font-family) 粗细、样式、拉伸和装饰(font-weight / font-style / font-stretch / text-decoration) 行间距(line-height)、字母间距(letter-spacing)和单词间距(word-spacing) 对齐(text-align)方式和缩进(text-ident) 链接样式（:link / :visited / :active / :hover） CSS3新属性 阴影效果 - text-shadow 首字母和首行文本(:first-letter / :first-line) 响应用户 盒子（box model） 盒子大小的控制（width / height） 盒子的边框、外边距和内边距（border / margin / padding） 盒子的显示和隐藏（display / visibility） CSS3新属性 边框图像（border-image） 投影（border-shadow） 圆角（border-radius） 列表、表格和表单 列表的项目符号（list-style） 表格的边框和背景（border-collapse） 表单控件的外观 表单控件的对齐 浏览器的开发者工具 图像 控制图像的大小（display: inline-block） 对齐图像 背景图像（background / background-image / background-repeat / background-position） 布局 控制元素的位置（position / z-index） 普通流 相对定位 绝对定位 固定定位 浮动元素（float / clear） 网站布局 HTML5布局 适配屏幕尺寸 固定宽度布局 流体布局 布局网格 使用JavaScript控制行为JavaScript基本语法 语句和注释 变量和数据类型 声明和赋值 简单数据类型和复杂数据类型 变量的命名规则 表达式和运算符 赋值运算符 算术运算符 比较运算符 逻辑运算符 分支结构 if...else... switch...cas...default... 循环结构 for循环 while循环 do...while循环 数组 创建数组 操作数组中的元素 函数 声明函数 调用函数 参数和返回值 匿名函数 立即调用函数 面向对象 对象的概念 创建对象的字面量语法 访问成员运算符 创建对象的构造函数语法 this关键字 添加和删除属性 delete关键字 标准对象 Number / String / Boolean / Symbol / Array / Function Date / Error / Math / RegExp / Object / Map / Set JSON / Promise / Generator / Reflect / Proxy BOM window对象的属性和方法 history对象 forward() / back() / go() location对象 navigator对象 screen对象 DOM DOM树 访问元素 getElementById() / querySelector() getElementsByClassName() / getElementsByTagName() / querySelectorAll() parentNode / previousSibling / nextSibling / children / firstChild / lastChild 操作元素 nodeValue innerHTML / textContent / createElement() / createTextNode() / appendChild() / insertBefore() / removeChild() className / id / hasAttribute() / getAttribute() / setAttribute() / removeAttribute() 事件处理 事件类型 UI事件：load / unload / error / resize / scroll 键盘事件：keydown / keyup / keypress 鼠标事件：click / dbclick / mousedown / mouseup / mousemove / mouseover / mouseout 焦点事件：focus / blur 表单事件：input / change / submit / reset / cut / copy / paste / select 事件绑定 HTML事件处理程序（不推荐使用，因为要做到标签与代码分离） 传统的DOM事件处理程序（只能附加一个回调函数） 事件监听器（旧的浏览器中不被支持） 事件流：事件捕获 / 事件冒泡 事件对象（低版本IE中的window.event） target（有些浏览器使用srcElement） type cancelable preventDefault() stopPropagation()（低版本IE中的cancelBubble） 鼠标事件 - 事件发生的位置 屏幕位置：screenX和screenY 页面位置：pageX和pageY 客户端位置：clientX和clientY 键盘事件 - 哪个键被按下了 keyCode属性（有些浏览器使用which） String.fromCharCode(event.keyCode) HTML5事件 DOMContentLoaded hashchange beforeunload JavaScript API 客户端存储 - localStorage和sessionStorage localStorage.colorSetting &#x3D; &#39;#a4509b&#39;; localStorage[&#39;colorSetting&#39;] &#x3D; &#39;#a4509b&#39;; localStorage.setItem(&#39;colorSetting&#39;, &#39;#a4509b&#39;); 获取位置信息 - geolocation navigator.geolocation.getCurrentPosition(function(pos) &#123; console.log(pos.coords.latitude) console.log(pos.coords.longitude) &#125;) 从服务器获取数据 - Fetch API 绘制图形 - &lt;canvas&gt;的API 音视频 - &lt;audio&gt;和&lt;video&gt;的API 使用jQueryjQuery概述 Write Less Do More（用更少的代码来完成更多的工作） 使用CSS选择器来查找元素（更简单更方便） 使用jQuery方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法） 引入jQuery 下载jQuery的开发版和压缩版 从CDN加载jQuery &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; window.jQuery || document.write(&#39;&lt;script src&#x3D;&quot;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&#39;) &lt;&#x2F;script&gt; 查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent&gt;child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains(‘…’) / :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute=’value’] / [attribute!=’value’] / [attribute^=’value’] / [attribute$=’value’] / [attribute|=’value’] / [attribute~=’value’] 表单：:input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() 链式操作检测页面是否可用&lt;script&gt; $(document).ready(function() &#123; &#125;); &lt;&#x2F;script&gt; &lt;script&gt; $(function() &#123; &#125;); &lt;&#x2F;script&gt; jQuery插件 jQuery Validation jQuery Treeview jQuery Autocomplete jQuery UI 避免和其他库的冲突先引入其他库再引入jQuery的情况。 &lt;script src&#x3D;&quot;other.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;jquery.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; jQuery.noConflict(); jQuery(function() &#123; jQuery(&#39;div&#39;).hide(); &#125;); &lt;&#x2F;script&gt; 先引入jQuery再引入其他库的情况。 &lt;script src&#x3D;&quot;jquery.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;other.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; jQuery(function() &#123; jQuery(&#39;div&#39;).hide(); &#125;); &lt;&#x2F;script&gt; 使用AjaxAjax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 原生的Ajax 基于jQuery的Ajax 加载内容 提交表单 前端框架渐进式框架 - Vue.js前后端分离开发（前端渲染）必选框架。 快速上手 引入Vue的JavaScript文件，我们仍然推荐从CDN服务器加载它。 &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; 数据绑定（声明式渲染 ）。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; product &#125;&#125;库存信息&lt;&#x2F;h1&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; product: &#39;iPhone X&#39; &#125; &#125;); &lt;&#x2F;script&gt; 条件与循环。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h1&gt;库存信息&lt;&#x2F;h1&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;product in products&quot;&gt; &#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125; &lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt; 已经售罄 &lt;&#x2F;span&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; products: [ &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;, &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125; ] &#125; &#125;); &lt;&#x2F;script&gt; 计算属性。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h1&gt;库存信息&lt;&#x2F;h1&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;product in products&quot;&gt; &#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125; &lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt; 已经售罄 &lt;&#x2F;span&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; products: [ &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;, &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125; ] &#125;, computed: &#123; totalQuantity() &#123; return this.products.reduce((sum, product) &#x3D;&gt; &#123; return sum + product.quantity &#125;, 0); &#125; &#125; &#125;); &lt;&#x2F;script&gt; 处理事件。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h1&gt;库存信息&lt;&#x2F;h1&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;product in products&quot;&gt; &#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125; &lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt; 已经售罄 &lt;&#x2F;span&gt; &lt;button @click&#x3D;&quot;product.quantity +&#x3D; 1&quot;&gt; 增加库存 &lt;&#x2F;button&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; products: [ &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;, &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125; ] &#125;, computed: &#123; totalQuantity() &#123; return this.products.reduce((sum, product) &#x3D;&gt; &#123; return sum + product.quantity &#125;, 0); &#125; &#125; &#125;); &lt;&#x2F;script&gt; 用户输入。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h1&gt;库存信息&lt;&#x2F;h1&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;product in products&quot;&gt; &#123;&#123; product.name &#125;&#125; - &lt;input type&#x3D;&quot;number&quot; v-model.number&#x3D;&quot;product.quantity&quot; min&#x3D;&quot;0&quot;&gt; &lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt; 已经售罄 &lt;&#x2F;span&gt; &lt;button @click&#x3D;&quot;product.quantity +&#x3D; 1&quot;&gt; 增加库存 &lt;&#x2F;button&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; products: [ &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;, &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;, &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125; ] &#125;, computed: &#123; totalQuantity() &#123; return this.products.reduce((sum, product) &#x3D;&gt; &#123; return sum + product.quantity &#125;, 0); &#125; &#125; &#125;); &lt;&#x2F;script&gt; 通过网络加载JSON数据。 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h2&gt;库存信息&lt;&#x2F;h2&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;product in products&quot;&gt; &#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125; &lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt; 已经售罄 &lt;&#x2F;span&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; const app &#x3D; new Vue(&#123; el: &#39;#app&#39;, data: &#123; products: [] &#125;， created() &#123; fetch(&#39;https:&#x2F;&#x2F;jackfrued.top&#x2F;api&#x2F;products&#39;) .then(response &#x3D;&gt; response.json()) .then(json &#x3D;&gt; &#123; this.products &#x3D; json &#125;); &#125; &#125;); &lt;&#x2F;script&gt; 使用脚手架 - vue-cliVue为商业项目开发提供了非常便捷的脚手架工具vue-cli，通过工具可以省去手工配置开发环境、测试环境和运行环境的步骤，让开发者只需要关注要解决的问题。 安装脚手架。 创建项目。 安装依赖包。 运行项目。 UI框架 - Element基于Vue 2.0的桌面端组件库，用于构造用户界面，支持响应式布局。 引入Element的CSS和JavaScript文件。 &lt;!-- 引入样式 --&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt; &lt;!-- 引入组件库 --&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt; 一个简单的例子。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;el-button @click&#x3D;&quot;visible &#x3D; true&quot;&gt;点我&lt;&#x2F;el-button&gt; &lt;el-dialog :visible.sync&#x3D;&quot;visible&quot; title&#x3D;&quot;Hello world&quot;&gt; &lt;p&gt;开始使用Element吧&lt;&#x2F;p&gt; &lt;&#x2F;el-dialog&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; new Vue(&#123; el: &#39;#app&#39;, data: &#123; visible: false, &#125; &#125;) &lt;&#x2F;script&gt; &lt;&#x2F;html&gt; 使用组件。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;el-table :data&#x3D;&quot;tableData&quot; stripe style&#x3D;&quot;width: 100%&quot;&gt; &lt;el-table-column prop&#x3D;&quot;date&quot; label&#x3D;&quot;日期&quot; width&#x3D;&quot;180&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;name&quot; label&#x3D;&quot;姓名&quot; width&#x3D;&quot;180&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;address&quot; label&#x3D;&quot;地址&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;&#x2F;el-table&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; new Vue(&#123; el: &#39;#app&#39;, data: &#123; tableData: [ &#123; date: &#39;2016-05-02&#39;, name: &#39;王一霸&#39;, address: &#39;上海市普陀区金沙江路 1518 弄&#39; &#125;, &#123; date: &#39;2016-05-04&#39;, name: &#39;刘二狗&#39;, address: &#39;上海市普陀区金沙江路 1517 弄&#39; &#125;, &#123; date: &#39;2016-05-01&#39;, name: &#39;杨三萌&#39;, address: &#39;上海市普陀区金沙江路 1519 弄&#39; &#125;, &#123; date: &#39;2016-05-03&#39;, name: &#39;陈四吹&#39;, address: &#39;上海市普陀区金沙江路 1516 弄&#39; &#125; ] &#125; &#125;) &lt;&#x2F;script&gt; &lt;&#x2F;html&gt; 报表框架 - ECharts百度出品的开源可视化库，常用于生成各种类型的报表。 基于弹性盒子的CSS框架 - BulmaBulma是一个基于Flexbox的现代化的CSS框架，其初衷就是移动优先（Mobile First），模块化设计，可以轻松用来实现各种简单或者复杂的内容布局，即使不懂CSS的开发者也能够使用它定制出漂亮的页面。 &lt;!DOCTYPE html&gt; &lt;html lang&#x3D;&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;Bulma&lt;&#x2F;title&gt; &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bulma&#x2F;0.7.4&#x2F;css&#x2F;bulma.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt; div &#123; margin-top: 10px; &#125; .column &#123; color: #fff; background-color: #063; margin: 10px 10px; text-align: center; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;columns&quot;&gt; &lt;div class&#x3D;&quot;column&quot;&gt;1&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;2&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;3&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;column&quot;&gt;4&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div&gt; &lt;a class&#x3D;&quot;button is-primary&quot;&gt;Primary&lt;&#x2F;a&gt; &lt;a class&#x3D;&quot;button is-link&quot;&gt;Link&lt;&#x2F;a&gt; &lt;a class&#x3D;&quot;button is-info&quot;&gt;Info&lt;&#x2F;a&gt; &lt;a class&#x3D;&quot;button is-success&quot;&gt;Success&lt;&#x2F;a&gt; &lt;a class&#x3D;&quot;button is-warning&quot;&gt;Warning&lt;&#x2F;a&gt; &lt;a class&#x3D;&quot;button is-danger&quot;&gt;Danger&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;div&gt; &lt;progress class&#x3D;&quot;progress is-danger is-medium&quot; max&#x3D;&quot;100&quot;&gt;60%&lt;&#x2F;progress&gt; &lt;&#x2F;div&gt; &lt;div&gt; &lt;table class&#x3D;&quot;table is-hoverable&quot;&gt; &lt;tr&gt; &lt;th&gt;One&lt;&#x2F;th&gt; &lt;th&gt;Two&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Three&lt;&#x2F;td&gt; &lt;td&gt;Four&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Five&lt;&#x2F;td&gt; &lt;td&gt;Six&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Seven&lt;&#x2F;td&gt; &lt;td&gt;Eight&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Nine&lt;&#x2F;td&gt; &lt;td&gt;Ten&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;Eleven&lt;&#x2F;td&gt; &lt;td&gt;Twelve&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 响应式布局框架 - Bootstrap用于快速开发Web应用程序的前端框架，支持响应式布局。 特点 支持主流的浏览器和移动设备 容易上手 响应式设计 内容 网格系统 封装的CSS 现成的组件 JavaScript插件 可视化","path":"2021/05/06/web-qian-duan-gai-shu/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"Python语言进阶","text":"重要知识点 生成式（推导式）的用法 prices &#x3D; &#123; &#39;AAPL&#39;: 191.88, &#39;GOOG&#39;: 1186.96, &#39;IBM&#39;: 149.24, &#39;ORCL&#39;: 48.44, &#39;ACN&#39;: 166.89, &#39;FB&#39;: 208.09, &#39;SYMC&#39;: 21.29 &#125; # 用股票价格大于100元的股票构造一个新的字典 prices2 &#x3D; &#123;key: value for key, value in prices.items() if value &gt; 100&#125; print(prices2) 说明：生成式（推导式）可以用来生成列表、集合和字典。 嵌套的列表的坑 names &#x3D; [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;] courses &#x3D; [&#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;] # 录入五个学生三门课程的成绩 # 错误 - 参考http:&#x2F;&#x2F;pythontutor.com&#x2F;visualize.html#mode&#x3D;edit # scores &#x3D; [[None] * len(courses)] * len(names) scores &#x3D; [[None] * len(courses) for _ in range(len(names))] for row, name in enumerate(names): for col, course in enumerate(courses): scores[row][col] &#x3D; float(input(f&#39;请输入&#123;name&#125;的&#123;course&#125;成绩: &#39;)) print(scores) Python Tutor - VISUALIZE CODE AND GET LIVE HELP heapq模块（堆排序） &quot;&quot;&quot; 从列表中找出最大的或最小的N个元素 堆结构(大根堆&#x2F;小根堆) &quot;&quot;&quot; import heapq list1 &#x3D; [34, 25, 12, 99, 87, 63, 58, 78, 88, 92] list2 &#x3D; [ &#123;&#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100, &#39;price&#39;: 91.1&#125;, &#123;&#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50, &#39;price&#39;: 543.22&#125;, &#123;&#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200, &#39;price&#39;: 21.09&#125;, &#123;&#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35, &#39;price&#39;: 31.75&#125;, &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45, &#39;price&#39;: 16.35&#125;, &#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: 75, &#39;price&#39;: 115.65&#125; ] print(heapq.nlargest(3, list1)) print(heapq.nsmallest(3, list1)) print(heapq.nlargest(2, list2, key&#x3D;lambda x: x[&#39;price&#39;])) print(heapq.nlargest(2, list2, key&#x3D;lambda x: x[&#39;shares&#39;])) itertools模块 &quot;&quot;&quot; 迭代工具模块 &quot;&quot;&quot; import itertools # 产生ABCD的全排列 itertools.permutations(&#39;ABCD&#39;) # 产生ABCDE的五选三组合 itertools.combinations(&#39;ABCDE&#39;, 3) # 产生ABCD和123的笛卡尔积 itertools.product(&#39;ABCD&#39;, &#39;123&#39;) # 产生ABC的无限循环序列 itertools.cycle((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)) collections模块 常用的工具类： namedtuple：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。 deque：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而deque底层是双向链表，因此当你需要在头尾添加和删除元素是，deque会表现出更好的性能，渐近时间复杂度为$O(1)$。 Counter：dict的子类，键是元素，值是元素的计数，它的most_common()方法可以帮助我们获取出现频率最高的元素。Counter和dict的继承关系我认为是值得商榷的，按照CARP原则，Counter跟dict的关系应该设计为关联关系更为合理。 OrderedDict：dict的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。 defaultdict：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的setdefault()方法，这种做法更加高效。 &quot;&quot;&quot; 找出序列中出现次数最多的元素 &quot;&quot;&quot; from collections import Counter words &#x3D; [ &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;not&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &quot;don&#39;t&quot;, &#39;look&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &quot;you&#39;re&quot;, &#39;under&#39; ] counter &#x3D; Counter(words) print(counter.most_common(3)) 数据结构和算法 算法：解决问题的方法和步骤 评价算法的好坏：渐近时间复杂度和渐近空间复杂度。 渐近时间复杂度的大O标记： - 常量时间复杂度 - 布隆过滤器 / 哈希存储 - 对数时间复杂度 - 折半查找（二分查找） - 线性时间复杂度 - 顺序查找 / 计数排序 - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序） - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序） - 立方时间复杂度 - Floyd算法 / 矩阵乘法运算 - 几何级数时间复杂度 - 汉诺塔 - 阶乘时间复杂度 - 旅行经销商问题 - NPC 排序算法（选择、冒泡和归并）和查找算法（顺序和折半） def select_sort(items, comp&#x3D;lambda x, y: x &lt; y): &quot;&quot;&quot;简单选择排序&quot;&quot;&quot; items &#x3D; items[:] for i in range(len(items) - 1): min_index &#x3D; i for j in range(i + 1, len(items)): if comp(items[j], items[min_index]): min_index &#x3D; j items[i], items[min_index] &#x3D; items[min_index], items[i] return items def bubble_sort(items, comp&#x3D;lambda x, y: x &gt; y): &quot;&quot;&quot;冒泡排序&quot;&quot;&quot; items &#x3D; items[:] for i in range(len(items) - 1): swapped &#x3D; False for j in range(i, len(items) - 1 - i): if comp(items[j], items[j + 1]): items[j], items[j + 1] &#x3D; items[j + 1], items[j] swapped &#x3D; True if not swapped: break return items def bubble_sort(items, comp&#x3D;lambda x, y: x &gt; y): &quot;&quot;&quot;搅拌排序(冒泡排序升级版)&quot;&quot;&quot; items &#x3D; items[:] for i in range(len(items) - 1): swapped &#x3D; False for j in range(i, len(items) - 1 - i): if comp(items[j], items[j + 1]): items[j], items[j + 1] &#x3D; items[j + 1], items[j] swapped &#x3D; True if swapped: swapped &#x3D; False for j in range(len(items) - 2 - i, i, -1): if comp(items[j - 1], items[j]): items[j], items[j - 1] &#x3D; items[j - 1], items[j] swapped &#x3D; True if not swapped: break return items def merge(items1, items2, comp&#x3D;lambda x, y: x &lt; y): &quot;&quot;&quot;合并(将两个有序的列表合并成一个有序的列表)&quot;&quot;&quot; items &#x3D; [] index1, index2 &#x3D; 0, 0 while index1 &lt; len(items1) and index2 &lt; len(items2): if comp(items1[index1], items2[index2]): items.append(items1[index1]) index1 +&#x3D; 1 else: items.append(items2[index2]) index2 +&#x3D; 1 items +&#x3D; items1[index1:] items +&#x3D; items2[index2:] return items def merge_sort(items, comp&#x3D;lambda x, y: x &lt; y): return _merge_sort(list(items), comp) def _merge_sort(items, comp): &quot;&quot;&quot;归并排序&quot;&quot;&quot; if len(items) &lt; 2: return items mid &#x3D; len(items) &#x2F;&#x2F; 2 left &#x3D; _merge_sort(items[:mid], comp) right &#x3D; _merge_sort(items[mid:], comp) return merge(left, right, comp) def seq_search(items, key): &quot;&quot;&quot;顺序查找&quot;&quot;&quot; for index, item in enumerate(items): if item &#x3D;&#x3D; key: return index return -1 def bin_search(items, key): &quot;&quot;&quot;折半查找&quot;&quot;&quot; start, end &#x3D; 0, len(items) - 1 while start &lt;&#x3D; end: mid &#x3D; (start + end) &#x2F;&#x2F; 2 if key &gt; items[mid]: start &#x3D; mid + 1 elif key &lt; items[mid]: end &#x3D; mid - 1 else: return mid return -1 常用算法： 穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。 贪婪法 - 在对问题求解时，总是做出在当前看来 最好的选择，不追求最优解，快速找到满意解。 分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。 回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。 动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。 穷举法例子：百钱百鸡和五人分鱼。 # 公鸡5元一只 母鸡3元一只 小鸡1元三只 # 用100元买100只鸡 问公鸡&#x2F;母鸡&#x2F;小鸡各多少只 for x in range(20): for y in range(33): z &#x3D; 100 - x - y if 5 * x + 3 * y + z &#x2F;&#x2F; 3 &#x3D;&#x3D; 100 and z % 3 &#x3D;&#x3D; 0: print(x, y, z) # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉 # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份 # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份 # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼 fish &#x3D; 6 while True: total &#x3D; fish enough &#x3D; True for _ in range(5): if (total - 1) % 5 &#x3D;&#x3D; 0: total &#x3D; (total - 1) &#x2F;&#x2F; 5 * 4 else: enough &#x3D; False break if enough: print(fish) break fish +&#x3D; 5 贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。 名称 价格（美元） 重量（kg） 电脑 200 20 收音机 20 4 钟 175 10 花瓶 50 2 书 10 1 油画 90 9 &quot;&quot;&quot; 贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。 输入： 20 6 电脑 200 20 收音机 20 4 钟 175 10 花瓶 50 2 书 10 1 油画 90 9 &quot;&quot;&quot; class Thing(object): &quot;&quot;&quot;物品&quot;&quot;&quot; def __init__(self, name, price, weight): self.name &#x3D; name self.price &#x3D; price self.weight &#x3D; weight @property def value(self): &quot;&quot;&quot;价格重量比&quot;&quot;&quot; return self.price &#x2F; self.weight def input_thing(): &quot;&quot;&quot;输入物品信息&quot;&quot;&quot; name_str, price_str, weight_str &#x3D; input().split() return name_str, int(price_str), int(weight_str) def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; max_weight, num_of_things &#x3D; map(int, input().split()) all_things &#x3D; [] for _ in range(num_of_things): all_things.append(Thing(*input_thing())) all_things.sort(key&#x3D;lambda x: x.value, reverse&#x3D;True) total_weight &#x3D; 0 total_price &#x3D; 0 for thing in all_things: if total_weight + thing.weight &lt;&#x3D; max_weight: print(f&#39;小偷拿走了&#123;thing.name&#125;&#39;) total_weight +&#x3D; thing.weight total_price +&#x3D; thing.price print(f&#39;总价值: &#123;total_price&#125;美元&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 分治法例子：快速排序。 &quot;&quot;&quot; 快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大 &quot;&quot;&quot; def quick_sort(items, comp&#x3D;lambda x, y: x &lt;&#x3D; y): items &#x3D; list(items)[:] _quick_sort(items, 0, len(items) - 1, comp) return items def _quick_sort(items, start, end, comp): if start &lt; end: pos &#x3D; _partition(items, start, end, comp) _quick_sort(items, start, pos - 1, comp) _quick_sort(items, pos + 1, end, comp) def _partition(items, start, end, comp): pivot &#x3D; items[end] i &#x3D; start - 1 for j in range(start, end): if comp(items[j], pivot): i +&#x3D; 1 items[i], items[j] &#x3D; items[j], items[i] items[i + 1], items[end] &#x3D; items[end], items[i + 1] return i + 1 回溯法例子：骑士巡逻。 &quot;&quot;&quot; 递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。 &quot;&quot;&quot; import sys import time SIZE &#x3D; 5 total &#x3D; 0 def print_board(board): for row in board: for col in row: print(str(col).center(4), end&#x3D;&#39;&#39;) print() def patrol(board, row, col, step&#x3D;1): if row &gt;&#x3D; 0 and row &lt; SIZE and \\ col &gt;&#x3D; 0 and col &lt; SIZE and \\ board[row][col] &#x3D;&#x3D; 0: board[row][col] &#x3D; step if step &#x3D;&#x3D; SIZE * SIZE: global total total +&#x3D; 1 print(f&#39;第&#123;total&#125;种走法: &#39;) print_board(board) patrol(board, row - 2, col - 1, step + 1) patrol(board, row - 1, col - 2, step + 1) patrol(board, row + 1, col - 2, step + 1) patrol(board, row + 2, col - 1, step + 1) patrol(board, row + 2, col + 1, step + 1) patrol(board, row + 1, col + 2, step + 1) patrol(board, row - 1, col + 2, step + 1) patrol(board, row - 2, col + 1, step + 1) board[row][col] &#x3D; 0 def main(): board &#x3D; [[0] * SIZE for _ in range(SIZE)] patrol(board, SIZE - 1, SIZE - 1) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 动态规划例子：子列表元素之和的最大值。 说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如： 输入：1 -2 3 5 -3 2 输出：8 输入：0 -2 3 5 -1 2 输出：9 输入：-9 -2 -3 -5 -3 输出：-2 def main(): items &#x3D; list(map(int, input().split())) overall &#x3D; partial &#x3D; items[0] for i in range(1, len(items)): partial &#x3D; max(items[i], partial + items[i]) overall &#x3D; max(partial, overall) print(overall) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明：这个题目最容易想到的解法是使用二重循环，但是代码的时间性能将会变得非常的糟糕。使用动态规划的思想，仅仅是多用了两个变量，就将原来$O(N^2)$复杂度的问题变成了$O(N)$。 函数的使用方式 将函数视为“一等公民” 函数可以赋值给变量 函数可以作为函数的参数 函数可以作为函数的返回值 高阶函数的用法（filter、map以及它们的替代品） items1 &#x3D; list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10)))) items2 &#x3D; [x ** 2 for x in range(1, 10) if x % 2] 位置参数、可变参数、关键字参数、命名关键字参数 参数的元信息（代码可读性问题） 匿名函数和内联函数的用法（lambda函数） 闭包和作用域问题 Python搜索变量的LEGB顺序（Local &gt;&gt;&gt; Embedded &gt;&gt;&gt; Global &gt;&gt;&gt; Built-in） global和nonlocal关键字的作用 global：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。 nonlocal：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。 装饰器函数（使用装饰器和取消装饰器） 例子：输出函数执行时间的装饰器。 def record_time(func): &quot;&quot;&quot;自定义装饰函数的装饰器&quot;&quot;&quot; @wraps(func) def wrapper(*args, **kwargs): start &#x3D; time() result &#x3D; func(*args, **kwargs) print(f&#39;&#123;func.__name__&#125;: &#123;time() - start&#125;秒&#39;) return result return wrapper 如果装饰器不希望跟print函数耦合，可以编写可以参数化的装饰器。 from functools import wraps from time import time def record(output): &quot;&quot;&quot;可以参数化的装饰器&quot;&quot;&quot; def decorate(func): @wraps(func) def wrapper(*args, **kwargs): start &#x3D; time() result &#x3D; func(*args, **kwargs) output(func.__name__, time() - start) return result return wrapper return decorate from functools import wraps from time import time class Record(): &quot;&quot;&quot;通过定义类的方式定义装饰器&quot;&quot;&quot; def __init__(self, output): self.output &#x3D; output def __call__(self, func): @wraps(func) def wrapper(*args, **kwargs): start &#x3D; time() result &#x3D; func(*args, **kwargs) self.output(func.__name__, time() - start) return result return wrapper 说明：由于对带装饰功能的函数添加了@wraps装饰器，可以通过func.__wrapped__方式获得被装饰之前的函数或类来取消装饰器的作用。 例子：用装饰器来实现单例模式。 from functools import wraps def singleton(cls): &quot;&quot;&quot;装饰类的装饰器&quot;&quot;&quot; instances &#x3D; &#123;&#125; @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: instances[cls] &#x3D; cls(*args, **kwargs) return instances[cls] return wrapper @singleton class President(): &quot;&quot;&quot;总统(单例类)&quot;&quot;&quot; pass 提示：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？ 线程安全的单例装饰器。 from functools import wraps from threading import RLock def singleton(cls): &quot;&quot;&quot;线程安全的单例装饰器&quot;&quot;&quot; instances &#x3D; &#123;&#125; locker &#x3D; RLock() @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: with locker: if cls not in instances: instances[cls] &#x3D; cls(*args, **kwargs) return instances[cls] return wrapper 提示：上面的代码用到了with上下文语法来进行锁操作，因为锁对象本身就是上下文管理器对象（支持__enter__和__exit__魔术方法）。在wrapper函数中，我们先做了一次不带锁的检查，然后再做带锁的检查，这样做比直接加锁检查性能要更好，如果对象已经创建就没有必须再去加锁而是直接返回该对象就可以了。 面向对象相关知识 三大支柱：封装、继承、多态 例子：工资结算系统。 &quot;&quot;&quot; 月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成 &quot;&quot;&quot; from abc import ABCMeta, abstractmethod class Employee(metaclass&#x3D;ABCMeta): &quot;&quot;&quot;员工(抽象类)&quot;&quot;&quot; def __init__(self, name): self.name &#x3D; name @abstractmethod def get_salary(self): &quot;&quot;&quot;结算月薪(抽象方法)&quot;&quot;&quot; pass class Manager(Employee): &quot;&quot;&quot;部门经理&quot;&quot;&quot; def get_salary(self): return 15000.0 class Programmer(Employee): &quot;&quot;&quot;程序员&quot;&quot;&quot; def __init__(self, name, working_hour&#x3D;0): self.working_hour &#x3D; working_hour super().__init__(name) def get_salary(self): return 200.0 * self.working_hour class Salesman(Employee): &quot;&quot;&quot;销售员&quot;&quot;&quot; def __init__(self, name, sales&#x3D;0.0): self.sales &#x3D; sales super().__init__(name) def get_salary(self): return 1800.0 + self.sales * 0.05 class EmployeeFactory(): &quot;&quot;&quot;创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）&quot;&quot;&quot; @staticmethod def create(emp_type, *args, **kwargs): &quot;&quot;&quot;创建员工&quot;&quot;&quot; all_emp_types &#x3D; &#123;&#39;M&#39;: Manager, &#39;P&#39;: Programmer, &#39;S&#39;: Salesman&#125; cls &#x3D; all_emp_types[emp_type.upper()] return cls(*args, **kwargs) if cls else None def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; emps &#x3D; [ EmployeeFactory.create(&#39;M&#39;, &#39;曹操&#39;), EmployeeFactory.create(&#39;P&#39;, &#39;荀彧&#39;, 120), EmployeeFactory.create(&#39;P&#39;, &#39;郭嘉&#39;, 85), EmployeeFactory.create(&#39;S&#39;, &#39;典韦&#39;, 123000), ] for emp in emps: print(f&#39;&#123;emp.name&#125;: &#123;emp.get_salary():.2f&#125;元&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 类与类之间的关系 is-a关系：继承 has-a关系：关联 / 聚合 / 合成 use-a关系：依赖 例子：扑克游戏。 &quot;&quot;&quot; 经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择 &quot;&quot;&quot; from enum import Enum, unique import random @unique class Suite(Enum): &quot;&quot;&quot;花色&quot;&quot;&quot; SPADE, HEART, CLUB, DIAMOND &#x3D; range(4) def __lt__(self, other): return self.value &lt; other.value class Card(): &quot;&quot;&quot;牌&quot;&quot;&quot; def __init__(self, suite, face): &quot;&quot;&quot;初始化方法&quot;&quot;&quot; self.suite &#x3D; suite self.face &#x3D; face def show(self): &quot;&quot;&quot;显示牌面&quot;&quot;&quot; suites &#x3D; [&#39;♠︎&#39;, &#39;♥︎&#39;, &#39;♣︎&#39;, &#39;♦︎&#39;] faces &#x3D; [&#39;&#39;, &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39;] return f&#39;&#123;suites[self.suite.value]&#125;&#123;faces[self.face]&#125;&#39; def __repr__(self): return self.show() class Poker(): &quot;&quot;&quot;扑克&quot;&quot;&quot; def __init__(self): self.index &#x3D; 0 self.cards &#x3D; [Card(suite, face) for suite in Suite for face in range(1, 14)] def shuffle(self): &quot;&quot;&quot;洗牌（随机乱序）&quot;&quot;&quot; random.shuffle(self.cards) self.index &#x3D; 0 def deal(self): &quot;&quot;&quot;发牌&quot;&quot;&quot; card &#x3D; self.cards[self.index] self.index +&#x3D; 1 return card @property def has_more(self): return self.index &lt; len(self.cards) class Player(): &quot;&quot;&quot;玩家&quot;&quot;&quot; def __init__(self, name): self.name &#x3D; name self.cards &#x3D; [] def get_one(self, card): &quot;&quot;&quot;摸一张牌&quot;&quot;&quot; self.cards.append(card) def sort(self, comp&#x3D;lambda card: (card.suite, card.face)): &quot;&quot;&quot;整理手上的牌&quot;&quot;&quot; self.cards.sort(key&#x3D;comp) def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; poker &#x3D; Poker() poker.shuffle() players &#x3D; [Player(&#39;东邪&#39;), Player(&#39;西毒&#39;), Player(&#39;南帝&#39;), Player(&#39;北丐&#39;)] while poker.has_more: for player in players: player.get_one(poker.deal()) for player in players: player.sort() print(player.name, end&#x3D;&#39;: &#39;) print(player.cards) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明：上面的代码中使用了Emoji字符来表示扑克牌的四种花色，在某些不支持Emoji字符的系统上可能无法显示。 对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆） 垃圾回收、循环引用和弱引用 Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略。 typedef struct_object &#123; &#x2F;* 引用计数 *&#x2F; int ob_refcnt; &#x2F;* 对象指针 *&#x2F; struct_typeobject *ob_type; &#125; PyObject; &#x2F;* 增加引用计数的宏定义 *&#x2F; #define Py_INCREF(op) ((op)-&gt;ob_refcnt++) &#x2F;* 减少引用计数的宏定义 *&#x2F; #define Py_DECREF(op) \\ &#x2F;&#x2F;减少计数 if (--(op)-&gt;ob_refcnt !&#x3D; 0) \\ ; \\ else \\ __Py_Dealloc((PyObject *)(op)) 导致引用计数+1的情况： 对象被创建，例如a = 23 对象被引用，例如b = a 对象被作为参数，传入到一个函数中，例如f(a) 对象作为一个元素，存储在容器中，例如list1 = [a, a] 导致引用计数-1的情况： 对象的别名被显式销毁，例如del a 对象的别名被赋予新的对象，例如a = 24 一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会） 对象所在的容器被销毁，或从容器中删除对象 引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。 # 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收 # 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效 # 如果不想造成循环引用可以使用弱引用 list1 &#x3D; [] list2 &#x3D; [] list1.append(list2) list2.append(list1) 以下情况会导致垃圾回收： 调用gc.collect() gc模块的计数器达到阀值 程序退出 如果循环引用中两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__方法，这个问题在Python 3.6中得到了解决。 也可以通过weakref模块构造弱引用的方式来解决循环引用的问题。 魔法属性和方法（请参考《Python魔法方法指南》） 有几个小问题请大家思考： 自定义的对象能不能使用运算符做运算？ 自定义的对象能不能放到set中？能去重吗？ 自定义的对象能不能作为dict的键？ 自定义的对象能不能使用上下文语法？ 混入（Mixin） 例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。 class SetOnceMappingMixin: &quot;&quot;&quot;自定义混入类&quot;&quot;&quot; __slots__ &#x3D; () def __setitem__(self, key, value): if key in self: raise KeyError(str(key) + &#39; already set&#39;) return super().__setitem__(key, value) class SetOnceDict(SetOnceMappingMixin, dict): &quot;&quot;&quot;自定义字典&quot;&quot;&quot; pass my_dict&#x3D; SetOnceDict() try: my_dict[&#39;username&#39;] &#x3D; &#39;jackfrued&#39; my_dict[&#39;username&#39;] &#x3D; &#39;hellokitty&#39; except KeyError: pass print(my_dict) 元编程和元类 对象是通过类创建的，类是通过元类创建的，元类提供了创建类的元信息。所有的类都直接或间接的继承自object，所有的元类都直接或间接的继承自type。 例子：用元类实现单例模式。 import threading class SingletonMeta(type): &quot;&quot;&quot;自定义元类&quot;&quot;&quot; def __init__(cls, *args, **kwargs): cls.__instance &#x3D; None cls.__lock &#x3D; threading.RLock() super().__init__(*args, **kwargs) def __call__(cls, *args, **kwargs): if cls.__instance is None: with cls.__lock: if cls.__instance is None: cls.__instance &#x3D; super().__call__(*args, **kwargs) return cls.__instance class President(metaclass&#x3D;SingletonMeta): &quot;&quot;&quot;总统(单例类)&quot;&quot;&quot; pass 面向对象设计原则 单一职责原则 （SRP）- 一个类只做该做的事情（类的设计要高内聚） 开闭原则 （OCP）- 软件实体应该对扩展开发对修改关闭 依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化） 里氏替换原则（LSP） - 任何时候可以用子类对象替换掉父类对象 接口隔离原则（ISP）- 接口要小而专不要大而全（Python中没有接口的概念） 合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码 最少知识原则（迪米特法则，LoD）- 不要给没有必然联系的对象发消息 说明：上面加粗的字母放在一起称为面向对象的SOLID原则。 GoF设计模式 创建型模式：单例、工厂、建造者、原型 结构型模式：适配器、门面（外观）、代理 行为型模式：迭代器、观察者、状态、策略 例子：可插拔的哈希算法（策略模式）。 class StreamHasher(): &quot;&quot;&quot;哈希摘要生成器&quot;&quot;&quot; def __init__(self, alg&#x3D;&#39;md5&#39;, size&#x3D;4096): self.size &#x3D; size alg &#x3D; alg.lower() self.hasher &#x3D; getattr(__import__(&#39;hashlib&#39;), alg.lower())() def __call__(self, stream): return self.to_digest(stream) def to_digest(self, stream): &quot;&quot;&quot;生成十六进制形式的摘要&quot;&quot;&quot; for buf in iter(lambda: stream.read(self.size), b&#39;&#39;): self.hasher.update(buf) return self.hasher.hexdigest() def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; hasher1 &#x3D; StreamHasher() with open(&#39;Python-3.7.6.tgz&#39;, &#39;rb&#39;) as stream: print(hasher1.to_digest(stream)) hasher2 &#x3D; StreamHasher(&#39;sha1&#39;) with open(&#39;Python-3.7.6.tgz&#39;, &#39;rb&#39;) as stream: print(hasher2(stream)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 迭代器和生成器 迭代器是实现了迭代器协议的对象。 Python中没有像protocol或interface这样的定义协议的关键字。 Python中用魔术方法表示协议。 __iter__和__next__魔术方法就是迭代器协议。 class Fib(object): &quot;&quot;&quot;迭代器&quot;&quot;&quot; def __init__(self, num): self.num &#x3D; num self.a, self.b &#x3D; 0, 1 self.idx &#x3D; 0 def __iter__(self): return self def __next__(self): if self.idx &lt; self.num: self.a, self.b &#x3D; self.b, self.a + self.b self.idx +&#x3D; 1 return self.a raise StopIteration() 生成器是语法简化版的迭代器。 def fib(num): &quot;&quot;&quot;生成器&quot;&quot;&quot; a, b &#x3D; 0, 1 for _ in range(num): a, b &#x3D; b, a + b yield a 生成器进化为协程。 生成器对象可以使用send()方法发送数据，发送的数据会成为生成器函数中通过yield表达式获得的值。这样，生成器就可以作为协程使用，协程简单的说就是可以相互协作的子程序。 def calc_avg(): &quot;&quot;&quot;流式计算平均值&quot;&quot;&quot; total, counter &#x3D; 0, 0 avg_value &#x3D; None while True: value &#x3D; yield avg_value total, counter &#x3D; total + value, counter + 1 avg_value &#x3D; total &#x2F; counter gen &#x3D; calc_avg() next(gen) print(gen.send(10)) print(gen.send(20)) print(gen.send(30)) 并发编程Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。 多线程：Python中提供了Thread类并辅以Lock、Condition、Event、Semaphore和Barrier。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。 &quot;&quot;&quot; 面试题：进程和线程的区别和联系？ 进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程 线程 - 操作系统分配CPU的基本单位 并发编程（concurrent programming） 1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行 2. 改善用户体验 - 让耗时间的操作不会造成程序的假死 &quot;&quot;&quot; import glob import os import threading from PIL import Image PREFIX &#x3D; &#39;thumbnails&#39; def generate_thumbnail(infile, size, format&#x3D;&#39;PNG&#39;): &quot;&quot;&quot;生成指定图片文件的缩略图&quot;&quot;&quot; file, ext &#x3D; os.path.splitext(infile) file &#x3D; file[file.rfind(&#39;&#x2F;&#39;) + 1:] outfile &#x3D; f&#39;&#123;PREFIX&#125;&#x2F;&#123;file&#125;_&#123;size[0]&#125;_&#123;size[1]&#125;.&#123;ext&#125;&#39; img &#x3D; Image.open(infile) img.thumbnail(size, Image.ANTIALIAS) img.save(outfile, format) def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; if not os.path.exists(PREFIX): os.mkdir(PREFIX) for infile in glob.glob(&#39;images&#x2F;*.png&#39;): for size in (32, 64, 128): # 创建并启动线程 threading.Thread( target&#x3D;generate_thumbnail, args&#x3D;(infile, (size, size)) ).start() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 多个线程竞争资源的情况。 &quot;&quot;&quot; 多线程程序如果没有竞争资源处理起来通常也比较简单 当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱 说明：临界资源就是被多个线程竞争的资源 &quot;&quot;&quot; import time import threading from concurrent.futures import ThreadPoolExecutor class Account(object): &quot;&quot;&quot;银行账户&quot;&quot;&quot; def __init__(self): self.balance &#x3D; 0.0 self.lock &#x3D; threading.Lock() def deposit(self, money): # 通过锁保护临界资源 with self.lock: new_balance &#x3D; self.balance + money time.sleep(0.001) self.balance &#x3D; new_balance class AddMoneyThread(threading.Thread): &quot;&quot;&quot;自定义线程类&quot;&quot;&quot; def __init__(self, account, money): self.account &#x3D; account self.money &#x3D; money # 自定义线程的初始化方法中必须调用父类的初始化方法 super().__init__() def run(self): # 线程启动之后要执行的操作 self.account.deposit(self.money) def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; account &#x3D; Account() # 创建线程池 pool &#x3D; ThreadPoolExecutor(max_workers&#x3D;10) futures &#x3D; [] for _ in range(100): # 创建线程的第1种方式 # threading.Thread( # target&#x3D;account.deposit, args&#x3D;(1, ) # ).start() # 创建线程的第2种方式 # AddMoneyThread(account, 1).start() # 创建线程的第3种方式 # 调用线程池中的线程来执行特定的任务 future &#x3D; pool.submit(account.deposit, 1) futures.append(future) # 关闭线程池 pool.shutdown() for future in futures: future.result() print(account.balance) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用threading模块的Condition来实现线程调度，该对象也是基于锁来创建的，代码如下所示： &quot;&quot;&quot; 多个线程竞争一个资源 - 保护临界资源 - 锁（Lock&#x2F;RLock） 多个线程竞争多个资源（线程数&gt;资源数） - 信号量（Semaphore） 多个线程的调度 - 暂停线程执行&#x2F;唤醒等待中的线程 - Condition &quot;&quot;&quot; from concurrent.futures import ThreadPoolExecutor from random import randint from time import sleep import threading class Account(): &quot;&quot;&quot;银行账户&quot;&quot;&quot; def __init__(self, balance&#x3D;0): self.balance &#x3D; balance lock &#x3D; threading.Lock() self.condition &#x3D; threading.Condition(lock) def withdraw(self, money): &quot;&quot;&quot;取钱&quot;&quot;&quot; with self.condition: while money &gt; self.balance: self.condition.wait() new_balance &#x3D; self.balance - money sleep(0.001) self.balance &#x3D; new_balance def deposit(self, money): &quot;&quot;&quot;存钱&quot;&quot;&quot; with self.condition: new_balance &#x3D; self.balance + money sleep(0.001) self.balance &#x3D; new_balance self.condition.notify_all() def add_money(account): while True: money &#x3D; randint(5, 10) account.deposit(money) print(threading.current_thread().name, &#39;:&#39;, money, &#39;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&#39;, account.balance) sleep(0.5) def sub_money(account): while True: money &#x3D; randint(10, 30) account.withdraw(money) print(threading.current_thread().name, &#39;:&#39;, money, &#39;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#39;, account.balance) sleep(1) def main(): account &#x3D; Account() with ThreadPoolExecutor(max_workers&#x3D;10) as pool: for _ in range(5): pool.submit(add_money, account) pool.submit(sub_money, account) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是Process，其他辅助的类跟threading模块中的类似，进程间共享数据可以使用管道、套接字等，在multiprocessing模块中有一个Queue类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。 &quot;&quot;&quot; 多进程和进程池的使用 多线程因为GIL的存在不能够发挥CPU的多核特性 对于计算密集型任务应该考虑使用多进程 time python3 example22.py real 0m11.512s user 0m39.319s sys 0m0.169s 使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍 这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU &quot;&quot;&quot; import concurrent.futures import math PRIMES &#x3D; [ 1116281, 1297337, 104395303, 472882027, 533000389, 817504243, 982451653, 112272535095293, 112582705942171, 112272535095293, 115280095190773, 115797848077099, 1099726899285419 ] * 5 def is_prime(n): &quot;&quot;&quot;判断素数&quot;&quot;&quot; if n % 2 &#x3D;&#x3D; 0: return False sqrt_n &#x3D; int(math.floor(math.sqrt(n))) for i in range(3, sqrt_n + 1, 2): if n % i &#x3D;&#x3D; 0: return False return True def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; with concurrent.futures.ProcessPoolExecutor() as executor: for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)): print(&#39;%d is prime: %s&#39; % (number, prime)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 重点：多线程和多进程的比较。 以下情况需要使用多线程： 程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。 程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。 以下情况需要使用多进程： 程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。 程序的输入可以并行的分成块，并且可以将运算结果合并。 程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。 异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者future对象来获取任务执行的结果。Python 3通过asyncio模块和await和async关键字（在Python 3.7中正式被列为关键字）来支持异步处理。 &quot;&quot;&quot; 异步I&#x2F;O - async &#x2F; await &quot;&quot;&quot; import asyncio def num_generator(m, n): &quot;&quot;&quot;指定范围的数字生成器&quot;&quot;&quot; yield from range(m, n + 1) async def prime_filter(m, n): &quot;&quot;&quot;素数过滤器&quot;&quot;&quot; primes &#x3D; [] for i in num_generator(m, n): flag &#x3D; True for j in range(2, int(i ** 0.5 + 1)): if i % j &#x3D;&#x3D; 0: flag &#x3D; False break if flag: print(&#39;Prime &#x3D;&gt;&#39;, i) primes.append(i) await asyncio.sleep(0.001) return tuple(primes) async def square_mapper(m, n): &quot;&quot;&quot;平方映射器&quot;&quot;&quot; squares &#x3D; [] for i in num_generator(m, n): print(&#39;Square &#x3D;&gt;&#39;, i * i) squares.append(i * i) await asyncio.sleep(0.001) return squares def main(): &quot;&quot;&quot;主函数&quot;&quot;&quot; loop &#x3D; asyncio.get_event_loop() future &#x3D; asyncio.gather(prime_filter(2, 100), square_mapper(1, 100)) future.add_done_callback(lambda x: print(x.result())) loop.run_until_complete(future) loop.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明：上面的代码使用get_event_loop函数获得系统默认的事件循环，通过gather函数可以获得一个future对象，future对象的add_done_callback可以添加执行完成时的回调函数，loop对象的run_until_complete方法可以等待通过future对象获得协程执行结果。 Python中有一个名为aiohttp的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟asyncio模块一起工作，并提供了对Future对象的支持。Python 3.6中引入了async和await来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。 import asyncio import re import aiohttp PATTERN &#x3D; re.compile(r&#39;\\&lt;title\\&gt;(?P&lt;title&gt;.*)\\&lt;\\&#x2F;title\\&gt;&#39;) async def fetch_page(session, url): async with session.get(url, ssl&#x3D;False) as resp: return await resp.text() async def show_title(url): async with aiohttp.ClientSession() as session: html &#x3D; await fetch_page(session, url) print(PATTERN.search(html).group(&#39;title&#39;)) def main(): urls &#x3D; (&#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;, &#39;https:&#x2F;&#x2F;git-scm.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;www.jd.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;www.taobao.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;www.douban.com&#x2F;&#39;) loop &#x3D; asyncio.get_event_loop() cos &#x3D; [show_title(url) for url in urls] loop.run_until_complete(asyncio.wait(cos)) loop.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 重点：异步I/O与多进程的比较。 当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，asyncio就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑asyncio，它很适合编写没有实时数据处理需求的Web应用服务器。 Python还有很多用于处理并行任务的三方库，例如：joblib、PyMP等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。 要实现任务的异步化，可以使用名为Celery的三方库。Celery是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。","path":"2021/05/06/python-yu-yan-jin-jie/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"图像和办公文档处理","text":"用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作。 操作图像计算机图像相关知识 颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。 名称 RGBA值 名称 RGBA值 White (255, 255, 255, 255) Red (255, 0, 0, 255) Green (0, 255, 0, 255) Blue (0, 0, 255, 255) Gray (128, 128, 128, 255) Yellow (255, 255, 0, 255) Black (0, 0, 0, 255) Purple (128, 0, 128, 255) 像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。 用Pillow操作图像Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。 pip install pillow Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。 &gt;&gt;&gt; from PIL import Image &gt;&gt;&gt; &gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;) &gt;&gt;&gt; image.format, image.size, image.mode (&#39;JPEG&#39;, (500, 750), &#39;RGB&#39;) &gt;&gt;&gt; image.show() 剪裁图像 &gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;) &gt;&gt;&gt; rect &#x3D; 80, 20, 310, 360 &gt;&gt;&gt; image.crop(rect).show() 生成缩略图 &gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;) &gt;&gt;&gt; size &#x3D; 128, 128 &gt;&gt;&gt; image.thumbnail(size) &gt;&gt;&gt; image.show() 缩放和黏贴图像 &gt;&gt;&gt; image1 &#x3D; Image.open(&#39;.&#x2F;res&#x2F;luohao.png&#39;) &gt;&gt;&gt; image2 &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;) &gt;&gt;&gt; rect &#x3D; 80, 20, 310, 360 &gt;&gt;&gt; guido_head &#x3D; image2.crop(rect) &gt;&gt;&gt; width, height &#x3D; guido_head.size &gt;&gt;&gt; image1.paste(guido_head.resize((int(width &#x2F; 1.5), int(height &#x2F; 1.5))), (172, 40)) 旋转和翻转 &gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.png&#39;) &gt;&gt;&gt; image.rotate(180).show() &gt;&gt;&gt; image.transpose(Image.FLIP_LEFT_RIGHT).show() 操作像素 &gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;) &gt;&gt;&gt; for x in range(80, 310): ... for y in range(20, 360): ... image.putpixel((x, y), (128, 128, 128)) ... &gt;&gt;&gt; image.show() 滤镜效果 &gt;&gt;&gt; from PIL import Image, ImageFilter &gt;&gt;&gt; &gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;) &gt;&gt;&gt; image.filter(ImageFilter.CONTOUR).show() 处理Excel电子表格Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，当然实际工作中，我们可能会用LibreOffice Calc和OpenOffice Calc来处理Excel的电子表格文件，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。关于openpyxl的使用手册和使用文档可以查看它的官方文档。 处理Word文档利用python-docx模块，Pytho 可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。 处理PDF文档PDF是Portable Document Format的缩写，使用.pdf作为文件扩展名。接下来我们就研究一下如何通过Python实现从PDF读取文本内容和从已有的文档生成新的PDF文件。","path":"2021/05/06/tu-xiang-he-ban-gong-wen-dang-chu-li/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"网络编程入门","text":"计算机网络基础计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。 计算机网络发展史 1960s - 美国国防部ARPANET项目问世，奠定了分组交换网络的基础。 1980s - 国际标准化组织（ISO）发布OSI/RM，奠定了网络技术标准化的基础。 1990s - 英国人蒂姆·伯纳斯-李发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。 在没有浏览器的年代，上网是这样的。 有了浏览器以后，上网是这样的。 TCP/IP模型实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组 （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。 IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。 TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情： 数据不传丢不传错（利用握手、校验和重传机制可以实现）。 流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。 拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。 网络应用模式 C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。 去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。 基于HTTP协议的网络资源访问HTTP（超文本传输协议）HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的《HTTP 协议入门》，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。 JSON格式JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。 XML的例子： &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;message&gt; &lt;from&gt;Alice&lt;&#x2F;from&gt; &lt;to&gt;Bob&lt;&#x2F;to&gt; &lt;content&gt;Will you marry me?&lt;&#x2F;content&gt; &lt;&#x2F;message&gt; JSON的例子： &#123; &quot;from&quot;: &quot;Alice&quot;, &quot;to&quot;: &quot;Bob&quot;, &quot;content&quot;: &quot;Will you marry me?&quot; &#125; requests库requests是一个基于HTTP协议来使用网络的第三库，其官方网站有这样的一句介绍它的话：“Requests是唯一的一个非转基因的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了天行数据提供的网络API。 我们可以先通过pip安装requests及其依赖库。 pip install requests 如果使用PyCharm作为开发工具，可以直接在代码中书写import requests，然后通过代码修复功能来自动下载安装requests。 from time import time from threading import Thread import requests # 继承Thread类创建自定义的线程类 class DownloadHanlder(Thread): def __init__(self, url): super().__init__() self.url &#x3D; url def run(self): filename &#x3D; self.url[self.url.rfind(&#39;&#x2F;&#39;) + 1:] resp &#x3D; requests.get(self.url) with open(&#39;&#x2F;Users&#x2F;Hao&#x2F;&#39; + filename, &#39;wb&#39;) as f: f.write(resp.content) def main(): # 通过requests模块的get函数获取网络资源 # 下面的代码中使用了天行数据接口提供的网络API # 要使用该数据接口需要在天行数据的网站上注册 # 然后用自己的Key替换掉下面代码的中APIKey即可 resp &#x3D; requests.get( &#39;http:&#x2F;&#x2F;api.tianapi.com&#x2F;meinv&#x2F;?key&#x3D;APIKey&amp;num&#x3D;10&#39;) # 将服务器返回的JSON格式的数据解析为字典 data_model &#x3D; resp.json() for mm_dict in data_model[&#39;newslist&#39;]: url &#x3D; mm_dict[&#39;picUrl&#39;] # 通过多线程的方式实现图片下载 DownloadHanlder(url).start() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 基于传输层协议的套接字编程套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 下面的代码实现了一个提供时间日期的服务器。 from socket import socket, SOCK_STREAM, AF_INET from datetime import datetime def main(): # 1.创建套接字对象并指定使用哪种传输服务 # family&#x3D;AF_INET - IPv4地址 # family&#x3D;AF_INET6 - IPv6地址 # type&#x3D;SOCK_STREAM - TCP套接字 # type&#x3D;SOCK_DGRAM - UDP套接字 # type&#x3D;SOCK_RAW - 原始套接字 server &#x3D; socket(family&#x3D;AF_INET, type&#x3D;SOCK_STREAM) # 2.绑定IP地址和端口(端口用于区分不同的服务) # 同一时间在同一个端口上只能绑定一个服务否则报错 server.bind((&#39;192.168.1.2&#39;, 6789)) # 3.开启监听 - 监听客户端连接到服务器 # 参数512可以理解为连接队列的大小 server.listen(512) print(&#39;服务器启动开始监听...&#39;) while True: # 4.通过循环接收客户端的连接并作出相应的处理(提供服务) # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行 # accept方法返回一个元组其中的第一个元素是客户端对象 # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成) client, addr &#x3D; server.accept() print(str(addr) + &#39;连接到了服务器.&#39;) # 5.发送数据 client.send(str(datetime.now()).encode(&#39;utf-8&#39;)) # 6.断开连接 client.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。 telnet 192.168.1.2 6789 当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。 from socket import socket def main(): # 1.创建套接字对象默认使用IPv4和TCP协议 client &#x3D; socket() # 2.连接到服务器(需要指定IP地址和端口) client.connect((&#39;192.168.1.2&#39;, 6789)) # 3.从服务器接收数据 print(client.recv(1024).decode(&#39;utf-8&#39;)) client.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。 服务器端代码： from socket import socket, SOCK_STREAM, AF_INET from base64 import b64encode from json import dumps from threading import Thread def main(): # 自定义线程类 class FileTransferHandler(Thread): def __init__(self, cclient): super().__init__() self.cclient &#x3D; cclient def run(self): my_dict &#x3D; &#123;&#125; my_dict[&#39;filename&#39;] &#x3D; &#39;guido.jpg&#39; # JSON是纯文本不能携带二进制数据 # 所以图片的二进制数据要处理成base64编码 my_dict[&#39;filedata&#39;] &#x3D; data # 通过dumps函数将字典处理成JSON字符串 json_str &#x3D; dumps(my_dict) # 发送JSON字符串 self.cclient.send(json_str.encode(&#39;utf-8&#39;)) self.cclient.close() # 1.创建套接字对象并指定使用哪种传输服务 server &#x3D; socket() # 2.绑定IP地址和端口(区分不同的服务) server.bind((&#39;192.168.1.2&#39;, 5566)) # 3.开启监听 - 监听客户端连接到服务器 server.listen(512) print(&#39;服务器启动开始监听...&#39;) with open(&#39;guido.jpg&#39;, &#39;rb&#39;) as f: # 将二进制数据处理成base64再解码成字符串 data &#x3D; b64encode(f.read()).decode(&#39;utf-8&#39;) while True: client, addr &#x3D; server.accept() # 启动一个线程来处理客户端的请求 FileTransferHandler(client).start() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 客户端代码： from socket import socket from json import loads from base64 import b64decode def main(): client &#x3D; socket() client.connect((&#39;192.168.1.2&#39;, 5566)) # 定义一个保存二进制数据的对象 in_data &#x3D; bytes() # 由于不知道服务器发送的数据有多大每次接收1024字节 data &#x3D; client.recv(1024) while data: # 将收到的数据拼接起来 in_data +&#x3D; data data &#x3D; client.recv(1024) # 将收到的二进制数据解码成JSON字符串并转换成字典 # loads函数的作用就是将JSON字符串转成字典对象 my_dict &#x3D; loads(in_data.decode(&#39;utf-8&#39;)) filename &#x3D; my_dict[&#39;filename&#39;] filedata &#x3D; my_dict[&#39;filedata&#39;].encode(&#39;utf-8&#39;) with open(&#39;&#x2F;Users&#x2F;Hao&#x2F;&#39; + filename, &#39;wb&#39;) as f: # 将base64格式的数据解码成二进制数据并写入文件 f.write(b64decode(filedata)) print(&#39;图片已保存.&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从000000到111111的64种状态。维基百科上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。 说明： 上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。 UDP套接字传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。 网络应用开发发送电子邮件在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。 就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。 下面的代码演示了如何在Python发送邮件。 from smtplib import SMTP from email.header import Header from email.mime.text import MIMEText def main(): # 请自行修改下面的邮件发送者和接收者 sender &#x3D; &#39;abcdefg@126.com&#39; receivers &#x3D; [&#39;uvwxyz@qq.com&#39;, &#39;uvwxyz@126.com&#39;] message &#x3D; MIMEText(&#39;用Python发送邮件的示例代码.&#39;, &#39;plain&#39;, &#39;utf-8&#39;) message[&#39;From&#39;] &#x3D; Header(&#39;王大锤&#39;, &#39;utf-8&#39;) message[&#39;To&#39;] &#x3D; Header(&#39;骆昊&#39;, &#39;utf-8&#39;) message[&#39;Subject&#39;] &#x3D; Header(&#39;示例代码实验邮件&#39;, &#39;utf-8&#39;) smtper &#x3D; SMTP(&#39;smtp.126.com&#39;) # 请自行修改下面的登录口令 smtper.login(sender, &#39;secretpass&#39;) smtper.sendmail(sender, receivers, message.as_string()) print(&#39;邮件发送完成!&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。 from smtplib import SMTP from email.header import Header from email.mime.text import MIMEText from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart import urllib def main(): # 创建一个带附件的邮件消息对象 message &#x3D; MIMEMultipart() # 创建文本内容 text_content &#x3D; MIMEText(&#39;附件中有本月数据请查收&#39;, &#39;plain&#39;, &#39;utf-8&#39;) message[&#39;Subject&#39;] &#x3D; Header(&#39;本月数据&#39;, &#39;utf-8&#39;) # 将文本内容添加到邮件消息对象中 message.attach(text_content) # 读取文件并将文件作为附件添加到邮件消息对象中 with open(&#39;&#x2F;Users&#x2F;Hao&#x2F;Desktop&#x2F;hello.txt&#39;, &#39;rb&#39;) as f: txt &#x3D; MIMEText(f.read(), &#39;base64&#39;, &#39;utf-8&#39;) txt[&#39;Content-Type&#39;] &#x3D; &#39;text&#x2F;plain&#39; txt[&#39;Content-Disposition&#39;] &#x3D; &#39;attachment; filename&#x3D;hello.txt&#39; message.attach(txt) # 读取文件并将文件作为附件添加到邮件消息对象中 with open(&#39;&#x2F;Users&#x2F;Hao&#x2F;Desktop&#x2F;汇总数据.xlsx&#39;, &#39;rb&#39;) as f: xls &#x3D; MIMEText(f.read(), &#39;base64&#39;, &#39;utf-8&#39;) xls[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;vnd.ms-excel&#39; xls[&#39;Content-Disposition&#39;] &#x3D; &#39;attachment; filename&#x3D;month-data.xlsx&#39; message.attach(xls) # 创建SMTP对象 smtper &#x3D; SMTP(&#39;smtp.126.com&#39;) # 开启安全连接 # smtper.starttls() sender &#x3D; &#39;abcdefg@126.com&#39; receivers &#x3D; [&#39;uvwxyz@qq.com&#39;] # 登录到SMTP服务器 # 请注意此处不是使用密码而是邮件客户端授权码进行登录 # 对此有疑问的读者可以联系自己使用的邮件服务器客服 smtper.login(sender, &#39;secretpass&#39;) # 发送邮件 smtper.sendmail(sender, receivers, message.as_string()) # 与邮件服务器断开连接 smtper.quit() print(&#39;发送完成!&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 发送短信发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。 import urllib.parse import http.client import json def main(): host &#x3D; &quot;106.ihuyi.com&quot; sms_send_uri &#x3D; &quot;&#x2F;webservice&#x2F;sms.php?method&#x3D;Submit&quot; # 下面的参数需要填入自己注册的账号和对应的密码 params &#x3D; urllib.parse.urlencode(&#123;&#39;account&#39;: &#39;你自己的账号&#39;, &#39;password&#39; : &#39;你自己的密码&#39;, &#39;content&#39;: &#39;您的验证码是：147258。请不要把验证码泄露给其他人。&#39;, &#39;mobile&#39;: &#39;接收者的手机号&#39;, &#39;format&#39;:&#39;json&#39; &#125;) print(params) headers &#x3D; &#123;&#39;Content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;, &#39;Accept&#39;: &#39;text&#x2F;plain&#39;&#125; conn &#x3D; http.client.HTTPConnection(host, port&#x3D;80, timeout&#x3D;30) conn.request(&#39;POST&#39;, sms_send_uri, params, headers) response &#x3D; conn.getresponse() response_str &#x3D; response.read() jsonstr &#x3D; response_str.decode(&#39;utf-8&#39;) print(json.loads(jsonstr)) conn.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main()","path":"2021/05/06/wang-luo-bian-cheng-ru-men/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"进程和线程","text":"今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。 概念进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。 一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。 当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。 Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。 Python中的多进程Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。 from random import randint from time import time, sleep def download_task(filename): print(&#39;开始下载%s...&#39; % filename) time_to_download &#x3D; randint(5, 10) sleep(time_to_download) print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download)) def main(): start &#x3D; time() download_task(&#39;Python从入门到住院.pdf&#39;) download_task(&#39;Peking Hot.avi&#39;) end &#x3D; time() print(&#39;总共耗费了%.2f秒.&#39; % (end - start)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 下面是运行程序得到的一次运行结果。 开始下载Python从入门到住院.pdf... Python从入门到住院.pdf下载完成! 耗费了6秒 开始下载Peking Hot.avi... Peking Hot.avi下载完成! 耗费了7秒 总共耗费了13.01秒. 从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。 from multiprocessing import Process from os import getpid from random import randint from time import time, sleep def download_task(filename): print(&#39;启动下载进程，进程号[%d].&#39; % getpid()) print(&#39;开始下载%s...&#39; % filename) time_to_download &#x3D; randint(5, 10) sleep(time_to_download) print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download)) def main(): start &#x3D; time() p1 &#x3D; Process(target&#x3D;download_task, args&#x3D;(&#39;Python从入门到住院.pdf&#39;, )) p1.start() p2 &#x3D; Process(target&#x3D;download_task, args&#x3D;(&#39;Peking Hot.avi&#39;, )) p2.start() p1.join() p2.join() end &#x3D; time() print(&#39;总共耗费了%.2f秒.&#39; % (end - start)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 在上面的代码中，我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，而join方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。 启动下载进程，进程号[1530]. 开始下载Python从入门到住院.pdf... 启动下载进程，进程号[1531]. 开始下载Peking Hot.avi... Peking Hot.avi下载完成! 耗费了7秒 Python从入门到住院.pdf下载完成! 耗费了10秒 总共耗费了10.01秒. 我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。 from multiprocessing import Process from time import sleep counter &#x3D; 0 def sub_task(string): global counter while counter &lt; 10: print(string, end&#x3D;&#39;&#39;, flush&#x3D;True) counter +&#x3D; 1 sleep(0.01) def main(): Process(target&#x3D;sub_task, args&#x3D;(&#39;Ping&#39;, )).start() Process(target&#x3D;sub_task, args&#x3D;(&#39;Pong&#39;, )).start() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个counter变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的Queue类，它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的，有兴趣的读者可以自己尝试一下。 Python中的多线程在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。 from random import randint from threading import Thread from time import time, sleep def download(filename): print(&#39;开始下载%s...&#39; % filename) time_to_download &#x3D; randint(5, 10) sleep(time_to_download) print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download)) def main(): start &#x3D; time() t1 &#x3D; Thread(target&#x3D;download, args&#x3D;(&#39;Python从入门到住院.pdf&#39;,)) t1.start() t2 &#x3D; Thread(target&#x3D;download, args&#x3D;(&#39;Peking Hot.avi&#39;,)) t2.start() t1.join() t2.join() end &#x3D; time() print(&#39;总共耗费了%.3f秒&#39; % (end - start)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 我们可以直接使用threading模块的Thread类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。 from random import randint from threading import Thread from time import time, sleep class DownloadTask(Thread): def __init__(self, filename): super().__init__() self._filename &#x3D; filename def run(self): print(&#39;开始下载%s...&#39; % self._filename) time_to_download &#x3D; randint(5, 10) sleep(time_to_download) print(&#39;%s下载完成! 耗费了%d秒&#39; % (self._filename, time_to_download)) def main(): start &#x3D; time() t1 &#x3D; DownloadTask(&#39;Python从入门到住院.pdf&#39;) t1.start() t2 &#x3D; DownloadTask(&#39;Peking Hot.avi&#39;) t2.start() t1.join() t2.join() end &#x3D; time() print(&#39;总共耗费了%.2f秒.&#39; % (end - start)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。 from time import sleep from threading import Thread class Account(object): def __init__(self): self._balance &#x3D; 0 def deposit(self, money): # 计算存款后的余额 new_balance &#x3D; self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance &#x3D; new_balance @property def balance(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account &#x3D; account self._money &#x3D; money def run(self): self._account.deposit(self._money) def main(): account &#x3D; Account() threads &#x3D; [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t &#x3D; AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print(&#39;账户余额为: ￥%d元&#39; % account.balance) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到new_balance = self._balance + money这行代码，多个线程得到的账户余额都是初始状态下的0，所以都是0上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。 from time import sleep from threading import Thread, Lock class Account(object): def __init__(self): self._balance &#x3D; 0 self._lock &#x3D; Lock() def deposit(self, money): # 先获取锁才能执行后续的代码 self._lock.acquire() try: new_balance &#x3D; self._balance + money sleep(0.01) self._balance &#x3D; new_balance finally: # 在finally中执行释放锁的操作保证正常异常锁都能释放 self._lock.release() @property def balance(self): return self._balance class AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account &#x3D; account self._money &#x3D; money def run(self): self._account.deposit(self._money) def main(): account &#x3D; Account() threads &#x3D; [] for _ in range(100): t &#x3D; AddMoneyThread(account, 1) threads.append(t) t.start() for t in threads: t.join() print(&#39;账户余额为: ￥%d元&#39; % account.balance) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。 多进程还是多线程无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。 但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。 是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。 除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。 说明： 上面的内容和例子来自于廖雪峰官方网站的《Python教程》，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。 单线程+异步I/O现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。 在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。 应用案例例子1：将耗时间的任务放到线程中以获得更好的用户体验。如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。 import time import tkinter import tkinter.messagebox def download(): # 模拟下载任务需要花费10秒钟时间 time.sleep(10) tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;下载完成!&#39;) def show_about(): tkinter.messagebox.showinfo(&#39;关于&#39;, &#39;作者: 骆昊(v1.0)&#39;) def main(): top &#x3D; tkinter.Tk() top.title(&#39;单线程&#39;) top.geometry(&#39;200x150&#39;) top.wm_attributes(&#39;-topmost&#39;, True) panel &#x3D; tkinter.Frame(top) button1 &#x3D; tkinter.Button(panel, text&#x3D;&#39;下载&#39;, command&#x3D;download) button1.pack(side&#x3D;&#39;left&#39;) button2 &#x3D; tkinter.Button(panel, text&#x3D;&#39;关于&#39;, command&#x3D;show_about) button2.pack(side&#x3D;&#39;right&#39;) panel.pack(side&#x3D;&#39;bottom&#39;) tkinter.mainloop() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。 import time import tkinter import tkinter.messagebox from threading import Thread def main(): class DownloadTaskHandler(Thread): def run(self): time.sleep(10) tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;下载完成!&#39;) # 启用下载按钮 button1.config(state&#x3D;tkinter.NORMAL) def download(): # 禁用下载按钮 button1.config(state&#x3D;tkinter.DISABLED) # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行) # 在线程中处理耗时间的下载任务 DownloadTaskHandler(daemon&#x3D;True).start() def show_about(): tkinter.messagebox.showinfo(&#39;关于&#39;, &#39;作者: 骆昊(v1.0)&#39;) top &#x3D; tkinter.Tk() top.title(&#39;单线程&#39;) top.geometry(&#39;200x150&#39;) top.wm_attributes(&#39;-topmost&#39;, 1) panel &#x3D; tkinter.Frame(top) button1 &#x3D; tkinter.Button(panel, text&#x3D;&#39;下载&#39;, command&#x3D;download) button1.pack(side&#x3D;&#39;left&#39;) button2 &#x3D; tkinter.Button(panel, text&#x3D;&#39;关于&#39;, command&#x3D;show_about) button2.pack(side&#x3D;&#39;right&#39;) panel.pack(side&#x3D;&#39;bottom&#39;) tkinter.mainloop() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 例子2：使用多进程对复杂任务进行“分而治之”。我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。 from time import time def main(): total &#x3D; 0 number_list &#x3D; [x for x in range(1, 100000001)] start &#x3D; time() for number in number_list: total +&#x3D; number print(total) end &#x3D; time() print(&#39;Execution time: %.3fs&#39; % (end - start)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。 from multiprocessing import Process, Queue from random import randint from time import time def task_handler(curr_list, result_queue): total &#x3D; 0 for number in curr_list: total +&#x3D; number result_queue.put(total) def main(): processes &#x3D; [] number_list &#x3D; [x for x in range(1, 100000001)] result_queue &#x3D; Queue() index &#x3D; 0 # 启动8个进程将数据切片后进行运算 for _ in range(8): p &#x3D; Process(target&#x3D;task_handler, args&#x3D;(number_list[index:index + 12500000], result_queue)) index +&#x3D; 12500000 processes.append(p) p.start() # 开始记录所有进程执行完成花费的时间 start &#x3D; time() for p in processes: p.join() # 合并执行结果 total &#x3D; 0 while not result_queue.empty(): total +&#x3D; result_queue.get() print(total) end &#x3D; time() print(&#39;Execution time: &#39;, (end - start), &#39;s&#39;, sep&#x3D;&#39;&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将Queue对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。","path":"2021/05/06/jin-cheng-he-xian-cheng/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"使用正则表达式","text":"正则表达式相关知识在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。 我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。 关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} | 分支 foo|bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?&nbsp;&lt;name&gt;exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.*ba.*?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\\进行转义处理，例如想匹配小数点可以写成\\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\\(和\\)，否则圆括号被视为正则表达式中的分组。 Python对正则表达式的支持Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 说明： 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。 下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。 例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。&quot;&quot;&quot; 验证输入用户名和QQ号是否有效并给出对应的提示信息 要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0 &quot;&quot;&quot; import re def main(): username &#x3D; input(&#39;请输入用户名: &#39;) qq &#x3D; input(&#39;请输入QQ号: &#39;) # match函数的第一个参数是正则表达式字符串或正则表达式对象 # 第二个参数是要跟正则表达式做匹配的字符串对象 m1 &#x3D; re.match(r&#39;^[0-9a-zA-Z_]&#123;6,20&#125;$&#39;, username) if not m1: print(&#39;请输入有效的用户名.&#39;) m2 &#x3D; re.match(r&#39;^[1-9]\\d&#123;4,11&#125;$&#39;, qq) if not m2: print(&#39;请输入有效的QQ号.&#39;) if m1 and m2: print(&#39;你输入的信息是有效的!&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 提示： 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\\\，例如表示数字的\\d得书写成\\\\d，这样不仅写起来不方便，阅读的时候也会很吃力。 例子2：从一段文字中提取出国内手机号码。下面这张图是截止到2017年底，国内三家运营商推出的手机号段。 import re def main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern &#x3D; re.compile(r&#39;(?&lt;&#x3D;\\D)1[34578]\\d&#123;9&#125;(?&#x3D;\\D)&#39;) sentence &#x3D; &#39;&#39;&#39; 重要的事情说8130123456789遍，我的手机号是13512346789这个靓号， 不是15600998765，也是110或119，王大锤的手机号才是15600998765。 &#39;&#39;&#39; # 查找所有匹配并保存到一个列表中 mylist &#x3D; re.findall(pattern, sentence) print(mylist) print(&#39;--------华丽的分隔线--------&#39;) # 通过迭代器取出匹配对象并获得匹配的内容 for temp in pattern.finditer(sentence): print(temp.group()) print(&#39;--------华丽的分隔线--------&#39;) # 通过search函数指定搜索位置找出所有匹配 m &#x3D; pattern.search(sentence) while m: print(m.group()) m &#x3D; pattern.search(sentence, m.end()) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明： 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?&lt;=\\D)(1[38]\\d&#123;9&#125;|14[57]\\d&#123;8&#125;|15[0-35-9]\\d&#123;8&#125;|17[678]\\d&#123;8&#125;)(?=\\D)，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。 例子3：替换字符串中的不良内容import re def main(): sentence &#x3D; &#39;你丫是傻叉吗? 我操你大爷的. Fuck you.&#39; purified &#x3D; re.sub(&#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#39;, &#39;*&#39;, sentence, flags&#x3D;re.IGNORECASE) print(purified) # 你丫是*吗? 我*你大爷的. * you. if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明： re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。 例子4：拆分长字符串import re def main(): poem &#x3D; &#39;窗前明月光，疑是地上霜。举头望明月，低头思故乡。&#39; sentence_list &#x3D; re.split(r&#39;[，。, .]&#39;, poem) while &#39;&#39; in sentence_list: sentence_list.remove(&#39;&#39;) print(sentence_list) # [&#39;窗前明月光&#39;, &#39;疑是地上霜&#39;, &#39;举头望明月&#39;, &#39;低头思故乡&#39;] if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 后话如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择Beautiful Soup或Lxml来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。","path":"2021/05/06/shi-yong-zheng-ze-biao-da-shi/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":" 文件和异常","text":"实际开发中常常会遇到对数据进行持久化操作的场景，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于文件系统的知识，但是这里我们并不浪费笔墨介绍这个概念，请大家自行通过维基百科进行了解。 在Python中实现文件的读写操作其实非常简单，通过Python内置的open函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。 操作模式 具体含义 &#39;r&#39; 读取 （默认） &#39;w&#39; 写入（会先截断之前的内容） &#39;x&#39; 写入，如果文件已经存在会产生异常 &#39;a&#39; 追加，将内容写入到已有文件的末尾 &#39;b&#39; 二进制模式 &#39;t&#39; 文本模式（默认） &#39;+&#39; 更新（既可以读又可以写） 下面这张图来自于菜鸟教程网站，它展示了如果根据应用程序的需要来设置操作模式。 读写文本文件读取文本文件时，需要在使用open函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为&#39;r&#39;（如果不指定，默认值也是&#39;r&#39;），然后通过encoding参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。 def main(): f &#x3D; open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) print(f.read()) f.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 请注意上面的代码，如果open函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。 def main(): f &#x3D; None try: f &#x3D; open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) print(f.read()) except FileNotFoundError: print(&#39;无法打开指定的文件!&#39;) except LookupError: print(&#39;指定了未知的编码!&#39;) except UnicodeDecodeError: print(&#39;读取文件时解码错误!&#39;) finally: if f: f.close() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 在Python中，我们可以将那些在运行时可能会出现状况的代码放在try代码块中，在try代码块的后面可以跟上一个或多个except来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发FileNotFoundError，指定了未知的编码会引发LookupError，而如果读取文件时无法按指定方式解码会引发UnicodeDecodeError，我们在try后面跟上了三个except分别处理这三种不同的异常状况。最后我们使用finally代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于finally块的代码不论程序正常还是异常都会执行到（甚至是调用了sys模块的exit函数退出Python环境，finally块都会被执行，因为exit函数实质上是引发了SystemExit异常），因此我们通常把finally块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在finally代码块中关闭文件对象释放资源，也可以使用上下文语法，通过with关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。 def main(): try: with open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) as f: print(f.read()) except FileNotFoundError: print(&#39;无法打开指定的文件!&#39;) except LookupError: print(&#39;指定了未知的编码!&#39;) except UnicodeDecodeError: print(&#39;读取文件时解码错误!&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 除了使用文件对象的read方法读取文件之外，还可以使用for-in循环逐行读取或者用readlines方法将文件按行读取到一个列表容器中，代码如下所示。 import time def main(): # 一次性读取整个文件内容 with open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) as f: print(f.read()) # 通过for-in循环逐行读取 with open(&#39;致橡树.txt&#39;, mode&#x3D;&#39;r&#39;) as f: for line in f: print(line, end&#x3D;&#39;&#39;) time.sleep(0.5) print() # 读取文件按行读取到列表中 with open(&#39;致橡树.txt&#39;) as f: lines &#x3D; f.readlines() print(lines) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 要将文本信息写入文件文件也非常简单，在使用open函数时指定好文件名并将文件模式设置为&#39;w&#39;即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为&#39;a&#39;。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999之间的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。 from math import sqrt def is_prime(n): &quot;&quot;&quot;判断素数的函数&quot;&quot;&quot; assert n &gt; 0 for factor in range(2, int(sqrt(n)) + 1): if n % factor &#x3D;&#x3D; 0: return False return True if n !&#x3D; 1 else False def main(): filenames &#x3D; (&#39;a.txt&#39;, &#39;b.txt&#39;, &#39;c.txt&#39;) fs_list &#x3D; [] try: for filename in filenames: fs_list.append(open(filename, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;)) for number in range(1, 10000): if is_prime(number): if number &lt; 100: fs_list[0].write(str(number) + &#39;\\n&#39;) elif number &lt; 1000: fs_list[1].write(str(number) + &#39;\\n&#39;) else: fs_list[2].write(str(number) + &#39;\\n&#39;) except IOError as ex: print(ex) print(&#39;写文件时发生错误!&#39;) finally: for fs in fs_list: fs.close() print(&#39;操作完成!&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 读写二进制文件知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。 def main(): try: with open(&#39;guido.jpg&#39;, &#39;rb&#39;) as fs1: data &#x3D; fs1.read() print(type(data)) # &lt;class &#39;bytes&#39;&gt; with open(&#39;吉多.jpg&#39;, &#39;wb&#39;) as fs2: fs2.write(data) except FileNotFoundError as e: print(&#39;指定的文件无法打开.&#39;) except IOError as e: print(&#39;读写文件时出现错误.&#39;) print(&#39;程序执行结束.&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 读写JSON文件通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考JSON的官方网站，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。 &#123; &quot;name&quot;: &quot;骆昊&quot;, &quot;age&quot;: 38, &quot;qq&quot;: 957658, &quot;friends&quot;: [&quot;王大锤&quot;, &quot;白元芳&quot;], &quot;cars&quot;: [ &#123;&quot;brand&quot;: &quot;BYD&quot;, &quot;max_speed&quot;: 180&#125;, &#123;&quot;brand&quot;: &quot;Audi&quot;, &quot;max_speed&quot;: 280&#125;, &#123;&quot;brand&quot;: &quot;Benz&quot;, &quot;max_speed&quot;: 320&#125; ] &#125; 可能大家已经注意到了，上面的JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的，如下面两张表所示。 JSON Python object dict array list string str number (int / real) int / float true / false True / False null None Python JSON dict object list, tuple array str string int, float, int- &amp; float-derived Enums number True / False true / false None null 我们使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中，代码如下所示。 import json def main(): mydict &#x3D; &#123; &#39;name&#39;: &#39;骆昊&#39;, &#39;age&#39;: 38, &#39;qq&#39;: 957658, &#39;friends&#39;: [&#39;王大锤&#39;, &#39;白元芳&#39;], &#39;cars&#39;: [ &#123;&#39;brand&#39;: &#39;BYD&#39;, &#39;max_speed&#39;: 180&#125;, &#123;&#39;brand&#39;: &#39;Audi&#39;, &#39;max_speed&#39;: 280&#125;, &#123;&#39;brand&#39;: &#39;Benz&#39;, &#39;max_speed&#39;: 320&#125; ] &#125; try: with open(&#39;data.json&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as fs: json.dump(mydict, fs) except IOError as e: print(e) print(&#39;保存数据完成!&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() json模块主要有四个比较重要的函数，分别是： dump - 将Python对象按照JSON格式序列化到文件中 dumps - 将Python对象处理成JSON格式的字符串 load - 将文件中的JSON数据反序列化成对象 loads - 将字符串的内容反序列化成Python对象 这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书维基百科上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。 目前绝大多数网络数据服务（或称之为网络API）都是基于HTTP协议提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的《HTTP协议入门》，如果想了解国内的网络数据服务，可以看看聚合数据和阿凡达数据等网站，国外的可以看看{API}Search网站。下面的例子演示了如何使用requests模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题，这个例子使用了天行数据提供的国内新闻数据接口，其中的APIKey需要自己到该网站申请。 import requests import json def main(): resp &#x3D; requests.get(&#39;http:&#x2F;&#x2F;api.tianapi.com&#x2F;guonei&#x2F;?key&#x3D;APIKey&amp;num&#x3D;10&#39;) data_model &#x3D; json.loads(resp.text) for news in data_model[&#39;newslist&#39;]: print(news[&#39;title&#39;]) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章《总结：Python中的异常处理》，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。","path":"2021/05/06/wen-jian-he-yi-chang/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"图形用户界面和游戏开发","text":"基于tkinter模块的GUIGUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。 基本上使用tkinter来开发GUI应用需要以下5个步骤： 导入tkinter模块中我们需要的东西。 创建一个顶层窗口对象并用它来承载整个GUI应用。 在顶层窗口对象上添加GUI组件。 通过代码将这些GUI组件的功能组织起来。 进入主事件循环(main loop)。 下面的代码演示了如何使用tkinter做一个简单的GUI应用。 import tkinter import tkinter.messagebox def main(): flag &#x3D; True # 修改标签上的文字 def change_label_text(): nonlocal flag flag &#x3D; not flag color, msg &#x3D; (&#39;red&#39;, &#39;Hello, world!&#39;)\\ if flag else (&#39;blue&#39;, &#39;Goodbye, world!&#39;) label.config(text&#x3D;msg, fg&#x3D;color) # 确认退出 def confirm_to_quit(): if tkinter.messagebox.askokcancel(&#39;温馨提示&#39;, &#39;确定要退出吗?&#39;): top.quit() # 创建顶层窗口 top &#x3D; tkinter.Tk() # 设置窗口大小 top.geometry(&#39;240x160&#39;) # 设置窗口标题 top.title(&#39;小游戏&#39;) # 创建标签对象并添加到顶层窗口 label &#x3D; tkinter.Label(top, text&#x3D;&#39;Hello, world!&#39;, font&#x3D;&#39;Arial -32&#39;, fg&#x3D;&#39;red&#39;) label.pack(expand&#x3D;1) # 创建一个装按钮的容器 panel &#x3D; tkinter.Frame(top) # 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数 button1 &#x3D; tkinter.Button(panel, text&#x3D;&#39;修改&#39;, command&#x3D;change_label_text) button1.pack(side&#x3D;&#39;left&#39;) button2 &#x3D; tkinter.Button(panel, text&#x3D;&#39;退出&#39;, command&#x3D;confirm_to_quit) button2.pack(side&#x3D;&#39;right&#39;) panel.pack(side&#x3D;&#39;bottom&#39;) # 开启主事件循环 tkinter.mainloop() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。 使用Pygame进行游戏开发Pygame是一个开源的Python模块，专门用于多媒体应用（如电子游戏）的开发，其中包含对图像、声音、视频、事件、碰撞等的支持。Pygame建立在SDL的基础上，SDL是一套跨平台的多媒体开发库，用C语言实现，被广泛的应用于游戏、模拟器、播放器等的开发。而Pygame让游戏开发者不再被底层语言束缚，可以更多的关注游戏的功能和逻辑。 下面我们来完成一个简单的小游戏，游戏的名字叫“大球吃小球”，当然完成这个游戏并不是重点，学会使用Pygame也不是重点，最重要的我们要在这个过程中体会如何使用前面讲解的面向对象程序设计，学会用这种编程思想去解决现实中的问题。 制作游戏窗口import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen &#x3D; pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(&#39;大球吃小球&#39;) running &#x3D; True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type &#x3D;&#x3D; pygame.QUIT: running &#x3D; False if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 在窗口中绘图可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条、矩形、多边形、圆、椭圆、圆弧等。需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点(0, 0)，向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是像素。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将一张图片放大若干倍，就可以看到这些点。pygame中表示颜色用的是色光三原色表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每种原色都用一个8位（bit）的值来表示，三种颜色相当于一共由24位构成，这也就是常说的“24位颜色表示法”。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen &#x3D; pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(&#39;大球吃小球&#39;) # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((242, 242, 242)) # 绘制一个圆(参数分别是: 屏幕, 颜色, 圆心位置, 半径, 0表示填充圆) pygame.draw.circle(screen, (255, 0, 0,), (100, 100), 30, 0) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running &#x3D; True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type &#x3D;&#x3D; pygame.QUIT: running &#x3D; False if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 加载图像如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的blit方法渲染图像，代码如下所示。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen &#x3D; pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(&#39;大球吃小球&#39;) # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组) screen.fill((255, 255, 255)) # 通过指定的文件名加载图像 ball_image &#x3D; pygame.image.load(&#39;.&#x2F;res&#x2F;ball.png&#39;) # 在窗口上渲染图像 screen.blit(ball_image, (50, 50)) # 刷新当前窗口(渲染窗口将绘制的图像呈现出来) pygame.display.flip() running &#x3D; True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type &#x3D;&#x3D; pygame.QUIT: running &#x3D; False if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 实现动画效果说到动画这个词大家都不会陌生，事实上要实现动画效果，本身的原理也非常简单，就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果。如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在循环中修改小球的位置再刷新整个窗口即可。 import pygame def main(): # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen &#x3D; pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(&#39;大球吃小球&#39;) # 定义变量来表示小球在屏幕上的位置 x, y &#x3D; 50, 50 running &#x3D; True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type &#x3D;&#x3D; pygame.QUIT: running &#x3D; False screen.fill((255, 255, 255)) pygame.draw.circle(screen, (255, 0, 0,), (x, y), 30, 0) pygame.display.flip() # 每隔50毫秒就改变小球的位置再刷新窗口 pygame.time.delay(50) x, y &#x3D; x + 5, y + 5 if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 碰撞检测通常一个游戏中会有很多对象出现，而这些对象之间的“碰撞”在所难免，比如炮弹击中了飞机、箱子撞到了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame的sprite（动画精灵）模块就提供了对碰撞检测的支持，这里我们暂时不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查球心的距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球，当然要做到这一点，我们可以把之前学习到的面向对象的知识应用起来。 from enum import Enum, unique from math import sqrt from random import randint import pygame @unique class Color(Enum): &quot;&quot;&quot;颜色&quot;&quot;&quot; RED &#x3D; (255, 0, 0) GREEN &#x3D; (0, 255, 0) BLUE &#x3D; (0, 0, 255) BLACK &#x3D; (0, 0, 0) WHITE &#x3D; (255, 255, 255) GRAY &#x3D; (242, 242, 242) @staticmethod def random_color(): &quot;&quot;&quot;获得随机颜色&quot;&quot;&quot; r &#x3D; randint(0, 255) g &#x3D; randint(0, 255) b &#x3D; randint(0, 255) return (r, g, b) class Ball(object): &quot;&quot;&quot;球&quot;&quot;&quot; def __init__(self, x, y, radius, sx, sy, color&#x3D;Color.RED): &quot;&quot;&quot;初始化方法&quot;&quot;&quot; self.x &#x3D; x self.y &#x3D; y self.radius &#x3D; radius self.sx &#x3D; sx self.sy &#x3D; sy self.color &#x3D; color self.alive &#x3D; True def move(self, screen): &quot;&quot;&quot;移动&quot;&quot;&quot; self.x +&#x3D; self.sx self.y +&#x3D; self.sy if self.x - self.radius &lt;&#x3D; 0 or \\ self.x + self.radius &gt;&#x3D; screen.get_width(): self.sx &#x3D; -self.sx if self.y - self.radius &lt;&#x3D; 0 or \\ self.y + self.radius &gt;&#x3D; screen.get_height(): self.sy &#x3D; -self.sy def eat(self, other): &quot;&quot;&quot;吃其他球&quot;&quot;&quot; if self.alive and other.alive and self !&#x3D; other: dx, dy &#x3D; self.x - other.x, self.y - other.y distance &#x3D; sqrt(dx ** 2 + dy ** 2) if distance &lt; self.radius + other.radius \\ and self.radius &gt; other.radius: other.alive &#x3D; False self.radius &#x3D; self.radius + int(other.radius * 0.146) def draw(self, screen): &quot;&quot;&quot;在窗口上绘制球&quot;&quot;&quot; pygame.draw.circle(screen, self.color, (self.x, self.y), self.radius, 0) 事件处理可以在事件循环中对鼠标事件进行处理，通过事件对象的type属性可以判定事件类型，再通过pos属性就可以获得鼠标点击的位置。如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似。 def main(): # 定义用来装所有球的容器 balls &#x3D; [] # 初始化导入的pygame中的模块 pygame.init() # 初始化用于显示的窗口并设置窗口尺寸 screen &#x3D; pygame.display.set_mode((800, 600)) # 设置当前窗口的标题 pygame.display.set_caption(&#39;大球吃小球&#39;) running &#x3D; True # 开启一个事件循环处理发生的事件 while running: # 从消息队列中获取事件并对事件进行处理 for event in pygame.event.get(): if event.type &#x3D;&#x3D; pygame.QUIT: running &#x3D; False # 处理鼠标事件的代码 if event.type &#x3D;&#x3D; pygame.MOUSEBUTTONDOWN and event.button &#x3D;&#x3D; 1: # 获得点击鼠标的位置 x, y &#x3D; event.pos radius &#x3D; randint(10, 100) sx, sy &#x3D; randint(-10, 10), randint(-10, 10) color &#x3D; Color.random_color() # 在点击鼠标的位置创建一个球(大小、速度和颜色随机) ball &#x3D; Ball(x, y, radius, sx, sy, color) # 将球添加到列表容器中 balls.append(ball) screen.fill((255, 255, 255)) # 取出容器中的球 如果没被吃掉就绘制 被吃掉了就移除 for ball in balls: if ball.alive: ball.draw(screen) else: balls.remove(ball) pygame.display.flip() # 每隔50毫秒就改变球的位置再刷新窗口 pygame.time.delay(50) for ball in balls: ball.move(screen) # 检查球有没有吃到其他的球 for other in balls: ball.eat(other) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 上面的两段代码合在一起，我们就完成了“大球吃小球”的游戏（如下图所示），准确的说它算不上一个游戏，但是做一个小游戏的基本知识我们已经通过这个例子告诉大家了，有了这些知识已经可以开始你的小游戏开发之旅了。其实上面的代码中还有很多值得改进的地方，比如刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程的知识后，用一个后台线程来处理这些事可能是更好的选择。如果希望获得更好的用户体验，我们还可以在游戏中加入背景音乐以及在球与球发生碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易的做到这一点，大家可以自行了解这方面的知识。事实上，想了解更多的关于pygame的知识，最好的教程是pygame的官方网站，如果英语没毛病就可以赶紧去看看啦。 如果想开发3D游戏，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者不妨看看Panda3D。","path":"2021/05/06/tu-xing-yong-hu-jie-mian-he-you-xi-kai-fa/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"面向对象进阶","text":"在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。 @property装饰器之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。 class Person(object): def __init__(self, name, age): self._name &#x3D; name self._age &#x3D; age # 访问器 - getter方法 @property def name(self): return self._name # 访问器 - getter方法 @property def age(self): return self._age # 修改器 - setter方法 @age.setter def age(self, age): self._age &#x3D; age def play(self): if self._age &lt;&#x3D; 16: print(&#39;%s正在玩飞行棋.&#39; % self._name) else: print(&#39;%s正在玩斗地主.&#39; % self._name) def main(): person &#x3D; Person(&#39;王大锤&#39;, 12) person.play() person.age &#x3D; 22 person.play() # person.name &#x3D; &#39;白元芳&#39; # AttributeError: can&#39;t set attribute if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() __slots__魔法我们讲到这里，不知道大家是否已经意识到，Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ &#x3D; (&#39;_name&#39;, &#39;_age&#39;, &#39;_gender&#39;) def __init__(self, name, age): self._name &#x3D; name self._age &#x3D; age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age &#x3D; age def play(self): if self._age &lt;&#x3D; 16: print(&#39;%s正在玩飞行棋.&#39; % self._name) else: print(&#39;%s正在玩斗地主.&#39; % self._name) def main(): person &#x3D; Person(&#39;王大锤&#39;, 22) person.play() person._gender &#x3D; &#39;男&#39; # AttributeError: &#39;Person&#39; object has no attribute &#39;_is_gay&#39; # person._is_gay &#x3D; True 静态方法和类方法之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。 from math import sqrt class Triangle(object): def __init__(self, a, b, c): self._a &#x3D; a self._b &#x3D; b self._c &#x3D; c @staticmethod def is_valid(a, b, c): return a + b &gt; c and b + c &gt; a and a + c &gt; b def perimeter(self): return self._a + self._b + self._c def area(self): half &#x3D; self.perimeter() &#x2F; 2 return sqrt(half * (half - self._a) * (half - self._b) * (half - self._c)) def main(): a, b, c &#x3D; 3, 4, 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle.is_valid(a, b, c): t &#x3D; Triangle(a, b, c) print(t.perimeter()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print(t.area()) # print(Triangle.area(t)) else: print(&#39;无法构成三角形.&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。 from time import time, localtime, sleep class Clock(object): &quot;&quot;&quot;数字时钟&quot;&quot;&quot; def __init__(self, hour&#x3D;0, minute&#x3D;0, second&#x3D;0): self._hour &#x3D; hour self._minute &#x3D; minute self._second &#x3D; second @classmethod def now(cls): ctime &#x3D; localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def run(self): &quot;&quot;&quot;走字&quot;&quot;&quot; self._second +&#x3D; 1 if self._second &#x3D;&#x3D; 60: self._second &#x3D; 0 self._minute +&#x3D; 1 if self._minute &#x3D;&#x3D; 60: self._minute &#x3D; 0 self._hour +&#x3D; 1 if self._hour &#x3D;&#x3D; 24: self._hour &#x3D; 0 def show(self): &quot;&quot;&quot;显示时间&quot;&quot;&quot; return &#39;%02d:%02d:%02d&#39; % \\ (self._hour, self._minute, self._second) def main(): # 通过类方法创建对象并获取系统时间 clock &#x3D; Clock.now() while True: print(clock.show()) sleep(1) clock.run() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 类之间的关系简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。 is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。 has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。 use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。 我们可以使用一种叫做UML（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读《UML面向对象设计基础》一书。 利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。 继承和多态刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为里氏替换原则。下面我们先看一个继承的例子。 class Person(object): &quot;&quot;&quot;人&quot;&quot;&quot; def __init__(self, name, age): self._name &#x3D; name self._age &#x3D; age @property def name(self): return self._name @property def age(self): return self._age @age.setter def age(self, age): self._age &#x3D; age def play(self): print(&#39;%s正在愉快的玩耍.&#39; % self._name) def watch_av(self): if self._age &gt;&#x3D; 18: print(&#39;%s正在观看爱情动作片.&#39; % self._name) else: print(&#39;%s只能观看《熊出没》.&#39; % self._name) class Student(Person): &quot;&quot;&quot;学生&quot;&quot;&quot; def __init__(self, name, age, grade): super().__init__(name, age) self._grade &#x3D; grade @property def grade(self): return self._grade @grade.setter def grade(self, grade): self._grade &#x3D; grade def study(self, course): print(&#39;%s的%s正在学习%s.&#39; % (self._grade, self._name, course)) class Teacher(Person): &quot;&quot;&quot;老师&quot;&quot;&quot; def __init__(self, name, age, title): super().__init__(name, age) self._title &#x3D; title @property def title(self): return self._title @title.setter def title(self, title): self._title &#x3D; title def teach(self, course): print(&#39;%s%s正在讲%s.&#39; % (self._name, self._title, course)) def main(): stu &#x3D; Student(&#39;王大锤&#39;, 15, &#39;初三&#39;) stu.study(&#39;数学&#39;) stu.watch_av() t &#x3D; Teacher(&#39;骆昊&#39;, 38, &#39;砖家&#39;) t.teach(&#39;Python程序设计&#39;) t.watch_av() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 from abc import ABCMeta, abstractmethod class Pet(object, metaclass&#x3D;ABCMeta): &quot;&quot;&quot;宠物&quot;&quot;&quot; def __init__(self, nickname): self._nickname &#x3D; nickname @abstractmethod def make_voice(self): &quot;&quot;&quot;发出声音&quot;&quot;&quot; pass class Dog(Pet): &quot;&quot;&quot;狗&quot;&quot;&quot; def make_voice(self): print(&#39;%s: 汪汪汪...&#39; % self._nickname) class Cat(Pet): &quot;&quot;&quot;猫&quot;&quot;&quot; def make_voice(self): print(&#39;%s: 喵...喵...&#39; % self._nickname) def main(): pets &#x3D; [Dog(&#39;旺财&#39;), Cat(&#39;凯蒂&#39;), Dog(&#39;大黄&#39;)] for pet in pets: pet.make_voice() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 在上面的代码中，我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，Dog和Cat两个子类分别对Pet类中的make_voice抽象方法进行了重写并给出了不同的实现版本，当我们在main函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。 综合案例案例1：奥特曼打小怪兽。from abc import ABCMeta, abstractmethod from random import randint, randrange class Fighter(object, metaclass&#x3D;ABCMeta): &quot;&quot;&quot;战斗者&quot;&quot;&quot; # 通过__slots__魔法限定对象可以绑定的成员变量 __slots__ &#x3D; (&#39;_name&#39;, &#39;_hp&#39;) def __init__(self, name, hp): &quot;&quot;&quot;初始化方法 :param name: 名字 :param hp: 生命值 &quot;&quot;&quot; self._name &#x3D; name self._hp &#x3D; hp @property def name(self): return self._name @property def hp(self): return self._hp @hp.setter def hp(self, hp): self._hp &#x3D; hp if hp &gt;&#x3D; 0 else 0 @property def alive(self): return self._hp &gt; 0 @abstractmethod def attack(self, other): &quot;&quot;&quot;攻击 :param other: 被攻击的对象 &quot;&quot;&quot; pass class Ultraman(Fighter): &quot;&quot;&quot;奥特曼&quot;&quot;&quot; __slots__ &#x3D; (&#39;_name&#39;, &#39;_hp&#39;, &#39;_mp&#39;) def __init__(self, name, hp, mp): &quot;&quot;&quot;初始化方法 :param name: 名字 :param hp: 生命值 :param mp: 魔法值 &quot;&quot;&quot; super().__init__(name, hp) self._mp &#x3D; mp def attack(self, other): other.hp -&#x3D; randint(15, 25) def huge_attack(self, other): &quot;&quot;&quot;究极必杀技(打掉对方至少50点或四分之三的血) :param other: 被攻击的对象 :return: 使用成功返回True否则返回False &quot;&quot;&quot; if self._mp &gt;&#x3D; 50: self._mp -&#x3D; 50 injury &#x3D; other.hp * 3 &#x2F;&#x2F; 4 injury &#x3D; injury if injury &gt;&#x3D; 50 else 50 other.hp -&#x3D; injury return True else: self.attack(other) return False def magic_attack(self, others): &quot;&quot;&quot;魔法攻击 :param others: 被攻击的群体 :return: 使用魔法成功返回True否则返回False &quot;&quot;&quot; if self._mp &gt;&#x3D; 20: self._mp -&#x3D; 20 for temp in others: if temp.alive: temp.hp -&#x3D; randint(10, 15) return True else: return False def resume(self): &quot;&quot;&quot;恢复魔法值&quot;&quot;&quot; incr_point &#x3D; randint(1, 10) self._mp +&#x3D; incr_point return incr_point def __str__(self): return &#39;~~~%s奥特曼~~~\\n&#39; % self._name + \\ &#39;生命值: %d\\n&#39; % self._hp + \\ &#39;魔法值: %d\\n&#39; % self._mp class Monster(Fighter): &quot;&quot;&quot;小怪兽&quot;&quot;&quot; __slots__ &#x3D; (&#39;_name&#39;, &#39;_hp&#39;) def attack(self, other): other.hp -&#x3D; randint(10, 20) def __str__(self): return &#39;~~~%s小怪兽~~~\\n&#39; % self._name + \\ &#39;生命值: %d\\n&#39; % self._hp def is_any_alive(monsters): &quot;&quot;&quot;判断有没有小怪兽是活着的&quot;&quot;&quot; for monster in monsters: if monster.alive &gt; 0: return True return False def select_alive_one(monsters): &quot;&quot;&quot;选中一只活着的小怪兽&quot;&quot;&quot; monsters_len &#x3D; len(monsters) while True: index &#x3D; randrange(monsters_len) monster &#x3D; monsters[index] if monster.alive &gt; 0: return monster def display_info(ultraman, monsters): &quot;&quot;&quot;显示奥特曼和小怪兽的信息&quot;&quot;&quot; print(ultraman) for monster in monsters: print(monster, end&#x3D;&#39;&#39;) def main(): u &#x3D; Ultraman(&#39;骆昊&#39;, 1000, 120) m1 &#x3D; Monster(&#39;狄仁杰&#39;, 250) m2 &#x3D; Monster(&#39;白元芳&#39;, 500) m3 &#x3D; Monster(&#39;王大锤&#39;, 750) ms &#x3D; [m1, m2, m3] fight_round &#x3D; 1 while u.alive and is_any_alive(ms): print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;第%02d回合&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; % fight_round) m &#x3D; select_alive_one(ms) # 选中一只小怪兽 skill &#x3D; randint(1, 10) # 通过随机数选择使用哪种技能 if skill &lt;&#x3D; 6: # 60%的概率使用普通攻击 print(&#39;%s使用普通攻击打了%s.&#39; % (u.name, m.name)) u.attack(m) print(&#39;%s的魔法值恢复了%d点.&#39; % (u.name, u.resume())) elif skill &lt;&#x3D; 9: # 30%的概率使用魔法攻击(可能因魔法值不足而失败) if u.magic_attack(ms): print(&#39;%s使用了魔法攻击.&#39; % u.name) else: print(&#39;%s使用魔法失败.&#39; % u.name) else: # 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击) if u.huge_attack(m): print(&#39;%s使用究极必杀技虐了%s.&#39; % (u.name, m.name)) else: print(&#39;%s使用普通攻击打了%s.&#39; % (u.name, m.name)) print(&#39;%s的魔法值恢复了%d点.&#39; % (u.name, u.resume())) if m.alive &gt; 0: # 如果选中的小怪兽没有死就回击奥特曼 print(&#39;%s回击了%s.&#39; % (m.name, u.name)) m.attack(u) display_info(u, ms) # 每个回合结束后显示奥特曼和小怪兽的信息 fight_round +&#x3D; 1 print(&#39;\\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;战斗结束!&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\\n&#39;) if u.alive &gt; 0: print(&#39;%s奥特曼胜利!&#39; % u.name) else: print(&#39;小怪兽胜利!&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 案例2：扑克游戏。import random class Card(object): &quot;&quot;&quot;一张牌&quot;&quot;&quot; def __init__(self, suite, face): self._suite &#x3D; suite self._face &#x3D; face @property def face(self): return self._face @property def suite(self): return self._suite def __str__(self): if self._face &#x3D;&#x3D; 1: face_str &#x3D; &#39;A&#39; elif self._face &#x3D;&#x3D; 11: face_str &#x3D; &#39;J&#39; elif self._face &#x3D;&#x3D; 12: face_str &#x3D; &#39;Q&#39; elif self._face &#x3D;&#x3D; 13: face_str &#x3D; &#39;K&#39; else: face_str &#x3D; str(self._face) return &#39;%s%s&#39; % (self._suite, face_str) def __repr__(self): return self.__str__() class Poker(object): &quot;&quot;&quot;一副牌&quot;&quot;&quot; def __init__(self): self._cards &#x3D; [Card(suite, face) for suite in &#39;♠♥♣♦&#39; for face in range(1, 14)] self._current &#x3D; 0 @property def cards(self): return self._cards def shuffle(self): &quot;&quot;&quot;洗牌(随机乱序)&quot;&quot;&quot; self._current &#x3D; 0 random.shuffle(self._cards) @property def next(self): &quot;&quot;&quot;发牌&quot;&quot;&quot; card &#x3D; self._cards[self._current] self._current +&#x3D; 1 return card @property def has_next(self): &quot;&quot;&quot;还有没有牌&quot;&quot;&quot; return self._current &lt; len(self._cards) class Player(object): &quot;&quot;&quot;玩家&quot;&quot;&quot; def __init__(self, name): self._name &#x3D; name self._cards_on_hand &#x3D; [] @property def name(self): return self._name @property def cards_on_hand(self): return self._cards_on_hand def get(self, card): &quot;&quot;&quot;摸牌&quot;&quot;&quot; self._cards_on_hand.append(card) def arrange(self, card_key): &quot;&quot;&quot;玩家整理手上的牌&quot;&quot;&quot; self._cards_on_hand.sort(key&#x3D;card_key) # 排序规则-先根据花色再根据点数排序 def get_key(card): return (card.suite, card.face) def main(): p &#x3D; Poker() p.shuffle() players &#x3D; [Player(&#39;东邪&#39;), Player(&#39;西毒&#39;), Player(&#39;南帝&#39;), Player(&#39;北丐&#39;)] for _ in range(13): for player in players: player.get(p.next) for player in players: print(player.name + &#39;:&#39;, end&#x3D;&#39; &#39;) player.arrange(get_key) print(player.cards_on_hand) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明： 大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。 案例3：工资结算系统。&quot;&quot;&quot; 某公司有三种类型的员工 分别是部门经理、程序员和销售员 需要设计一个工资结算系统 根据提供的员工信息来计算月薪 部门经理的月薪是每月固定15000元 程序员的月薪按本月工作时间计算 每小时150元 销售员的月薪是1200元的底薪加上销售额5%的提成 &quot;&quot;&quot; from abc import ABCMeta, abstractmethod class Employee(object, metaclass&#x3D;ABCMeta): &quot;&quot;&quot;员工&quot;&quot;&quot; def __init__(self, name): &quot;&quot;&quot; 初始化方法 :param name: 姓名 &quot;&quot;&quot; self._name &#x3D; name @property def name(self): return self._name @abstractmethod def get_salary(self): &quot;&quot;&quot; 获得月薪 :return: 月薪 &quot;&quot;&quot; pass class Manager(Employee): &quot;&quot;&quot;部门经理&quot;&quot;&quot; def get_salary(self): return 15000.0 class Programmer(Employee): &quot;&quot;&quot;程序员&quot;&quot;&quot; def __init__(self, name, working_hour&#x3D;0): super().__init__(name) self._working_hour &#x3D; working_hour @property def working_hour(self): return self._working_hour @working_hour.setter def working_hour(self, working_hour): self._working_hour &#x3D; working_hour if working_hour &gt; 0 else 0 def get_salary(self): return 150.0 * self._working_hour class Salesman(Employee): &quot;&quot;&quot;销售员&quot;&quot;&quot; def __init__(self, name, sales&#x3D;0): super().__init__(name) self._sales &#x3D; sales @property def sales(self): return self._sales @sales.setter def sales(self, sales): self._sales &#x3D; sales if sales &gt; 0 else 0 def get_salary(self): return 1200.0 + self._sales * 0.05 def main(): emps &#x3D; [ Manager(&#39;刘备&#39;), Programmer(&#39;诸葛亮&#39;), Manager(&#39;曹操&#39;), Salesman(&#39;荀彧&#39;), Salesman(&#39;吕布&#39;), Programmer(&#39;张辽&#39;), Programmer(&#39;赵云&#39;) ] for emp in emps: if isinstance(emp, Programmer): emp.working_hour &#x3D; int(input(&#39;请输入%s本月工作时间: &#39; % emp.name)) elif isinstance(emp, Salesman): emp.sales &#x3D; float(input(&#39;请输入%s本月销售额: &#39; % emp.name)) # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态) print(&#39;%s本月工资为: ￥%s元&#39; % (emp.name, emp.get_salary())) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main()","path":"2021/05/06/mian-xiang-dui-xiang-jin-jie/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"面向对象编程基础","text":"活在当下的程序员应该都听过&quot;面向对象编程&quot;一词，也经常有人问能不能用一句话解释下什么是&quot;面向对象编程&quot;，我们先来看看比较正式的说法。 &quot;把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。&quot; 这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于知乎。 说明： 以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。 之前我们说过&quot;程序是指令的集合&quot;，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，&quot;每个人都应该学习编程&quot;这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，&quot;软件危机&quot;、&quot;软件工程&quot;等一系列的概念开始在行业中出现。 当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的&quot;银弹&quot;，真正让软件开发者看到希望的是上世纪70年代诞生的Smalltalk编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的Simula语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。 说明： 当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。 类和对象简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。 定义类在Python中可以使用class关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。 class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name &#x3D; name self.age &#x3D; age def study(self, course_name): print(&#39;%s正在学习%s.&#39; % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print(&#39;%s只能观看《熊出没》.&#39; % self.name) else: print(&#39;%s正在观看岛国爱情大电影.&#39; % self.name) 说明： 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。 创建和使用对象当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。 def main(): # 创建学生对象并指定姓名和年龄 stu1 &#x3D; Student(&#39;骆昊&#39;, 38) # 给对象发study消息 stu1.study(&#39;Python程序设计&#39;) # 给对象发watch_av消息 stu1.watch_movie() stu2 &#x3D; Student(&#39;王大锤&#39;, 15) stu2.study(&#39;思想品德&#39;) stu2.watch_movie() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 访问可见性问题对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。 class Test: def __init__(self, foo): self.__foo &#x3D; foo def __bar(self): print(self.__foo) print(&#39;__bar&#39;) def main(): test &#x3D; Test(&#39;hello&#39;) # AttributeError: &#39;Test&#39; object has no attribute &#39;__bar&#39; test.__bar() # AttributeError: &#39;Test&#39; object has no attribute &#39;__foo&#39; print(test.__foo) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是&quot;We are all consenting adults here&quot;。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。 class Test: def __init__(self, foo): self.__foo &#x3D; foo def __bar(self): print(self.__foo) print(&#39;__bar&#39;) def main(): test &#x3D; Test(&#39;hello&#39;) test._Test__bar() print(test._Test__foo) if __name__ &#x3D;&#x3D; &quot;__main__&quot;: main() 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的《Python - 那些年我们踩过的那些坑》文章中的讲解。 面向对象的支柱面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是&quot;隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口&quot;。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。 练习练习1：定义一个类描述数字时钟。参考答案： from time import sleep class Clock(object): &quot;&quot;&quot;数字时钟&quot;&quot;&quot; def __init__(self, hour&#x3D;0, minute&#x3D;0, second&#x3D;0): &quot;&quot;&quot;初始化方法 :param hour: 时 :param minute: 分 :param second: 秒 &quot;&quot;&quot; self._hour &#x3D; hour self._minute &#x3D; minute self._second &#x3D; second def run(self): &quot;&quot;&quot;走字&quot;&quot;&quot; self._second +&#x3D; 1 if self._second &#x3D;&#x3D; 60: self._second &#x3D; 0 self._minute +&#x3D; 1 if self._minute &#x3D;&#x3D; 60: self._minute &#x3D; 0 self._hour +&#x3D; 1 if self._hour &#x3D;&#x3D; 24: self._hour &#x3D; 0 def show(self): &quot;&quot;&quot;显示时间&quot;&quot;&quot; return &#39;%02d:%02d:%02d&#39; % \\ (self._hour, self._minute, self._second) def main(): clock &#x3D; Clock(23, 59, 58) while True: print(clock.show()) sleep(1) clock.run() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。参考答案： from math import sqrt class Point(object): def __init__(self, x&#x3D;0, y&#x3D;0): &quot;&quot;&quot;初始化方法 :param x: 横坐标 :param y: 纵坐标 &quot;&quot;&quot; self.x &#x3D; x self.y &#x3D; y def move_to(self, x, y): &quot;&quot;&quot;移动到指定位置 :param x: 新的横坐标 &quot;param y: 新的纵坐标 &quot;&quot;&quot; self.x &#x3D; x self.y &#x3D; y def move_by(self, dx, dy): &quot;&quot;&quot;移动指定的增量 :param dx: 横坐标的增量 &quot;param dy: 纵坐标的增量 &quot;&quot;&quot; self.x +&#x3D; dx self.y +&#x3D; dy def distance_to(self, other): &quot;&quot;&quot;计算与另一个点的距离 :param other: 另一个点 &quot;&quot;&quot; dx &#x3D; self.x - other.x dy &#x3D; self.y - other.y return sqrt(dx ** 2 + dy ** 2) def __str__(self): return &#39;(%s, %s)&#39; % (str(self.x), str(self.y)) def main(): p1 &#x3D; Point(3, 5) p2 &#x3D; Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明： 本章中的插图来自于Grady Booch等著作的《面向对象分析与设计》一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。","path":"2021/05/06/mian-xiang-dui-xiang-bian-cheng-ji-chu/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"字符串和常用数据结构","text":"使用字符串第二次世界大战促使了现代电子计算机的诞生，最初计算机被应用于导弹弹道的计算，而在计算机诞生后的很多年时间里，计算机处理的信息基本上都是数值型的信息。世界上的第一台电子计算机叫ENIAC（电子数值积分计算机），诞生于美国的宾夕法尼亚大学，每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据可能都是以文本的方式存在的，如果我们希望通过Python程序操作本这些文本信息，就必须要先了解字符串类型以及与它相关的知识。 所谓字符串，就是由零个或多个字符组成的有限序列，一般记为。在Python程序中，如果我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。 s1 &#x3D; &#39;hello, world!&#39; s2 &#x3D; &quot;hello, world!&quot; # 以三个双引号或单引号开头的字符串可以折行 s3 &#x3D; &quot;&quot;&quot; hello, world! &quot;&quot;&quot; print(s1, s2, s3, end&#x3D;&#39;&#39;) 可以在字符串中使用\\（反斜杠）来表示转义，也就是说\\后面的字符不再是它原来的意义，例如：\\n不是代表反斜杠和字符n，而是表示换行；而\\t也不是代表反斜杠和字符t，而是表示制表符。所以如果想在字符串中表示&#39;要写成\\&#39;，同理想表示\\要写成\\\\。可以运行下面的代码看看会输出什么。 s1 &#x3D; &#39;\\&#39;hello, world!\\&#39;&#39; s2 &#x3D; &#39;\\n\\\\hello, world!\\\\\\n&#39; print(s1, s2, end&#x3D;&#39;&#39;) 在\\后面还可以跟一个八进制或者十六进制数来表示字符，例如\\141和\\x61都代表小写字母a，前者是八进制的表示法，后者是十六进制的表示法。也可以在\\后面跟Unicode字符编码来表示字符，例如\\u9a86\\u660a代表的是中文“骆昊”。运行下面的代码，看看输出了什么。 s1 &#x3D; &#39;\\141\\142\\143\\x61\\x62\\x63&#39; s2 &#x3D; &#39;\\u9a86\\u660a&#39; print(s1, s2) 如果不希望字符串中的\\表示转义，我们可以通过在字符串的最前面加上字母r来加以说明，再看看下面的代码又会输出什么。 s1 &#x3D; r&#39;\\&#39;hello, world!\\&#39;&#39; s2 &#x3D; r&#39;\\n\\\\hello, world!\\\\\\n&#39; print(s1, s2, end&#x3D;&#39;&#39;) Python为字符串类型提供了非常丰富的运算符，我们可以使用+运算符来实现字符串的拼接，可以使用*运算符来重复一个字符串的内容，可以使用in和not in来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用[]和[:]运算符从字符串取出某个字符或某些字符（切片运算），代码如下所示。 s1 &#x3D; &#39;hello &#39; * 3 print(s1) # hello hello hello s2 &#x3D; &#39;world&#39; s1 +&#x3D; s2 print(s1) # hello hello hello world print(&#39;ll&#39; in s1) # True print(&#39;good&#39; in s1) # False str2 &#x3D; &#39;abc123456&#39; # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[::-1]) # 654321cba print(str2[-3:-1]) # 45 在Python中，我们还可以通过一系列的方法来完成对字符串的处理，代码如下所示。 str1 &#x3D; &#39;hello, world!&#39; # 通过内置函数len计算字符串的长度 print(len(str1)) # 13 # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串每个单词首字母大写的拷贝 print(str1.title()) # Hello, World! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 从字符串中查找子串所在位置 print(str1.find(&#39;or&#39;)) # 8 print(str1.find(&#39;shit&#39;)) # -1 # 与find类似但找不到子串时会引发异常 # print(str1.index(&#39;or&#39;)) # print(str1.index(&#39;shit&#39;)) # 检查字符串是否以指定的字符串开头 print(str1.startswith(&#39;He&#39;)) # False print(str1.startswith(&#39;hel&#39;)) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith(&#39;!&#39;)) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, &#39;*&#39;)) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, &#39; &#39;)) str2 &#x3D; &#39;abc123456&#39; # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 &#x3D; &#39; jackfrued@126.com &#39; print(str3) # 获得字符串修剪左右两侧空格之后的拷贝 print(str3.strip()) 我们之前讲过，可以用下面的方式来格式化输出字符串。 a, b &#x3D; 5, 10 print(&#39;%d * %d &#x3D; %d&#39; % (a, b, a * b)) 当然，我们也可以用字符串提供的方法来完成字符串的格式，代码如下所示。 a, b &#x3D; 5, 10 print(&#39;&#123;0&#125; * &#123;1&#125; &#x3D; &#123;2&#125;&#39;.format(a, b, a * b)) Python 3.6以后，格式化字符串还有更为简洁的书写方式，就是在字符串前加上字母f，我们可以使用下面的语法糖来简化上面的代码。 a, b &#x3D; 5, 10 print(f&#39;&#123;a&#125; * &#123;b&#125; &#x3D; &#123;a * b&#125;&#39;) 除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。 使用列表不知道大家是否注意到，刚才我们讲到的字符串类型（str）和之前我们讲到的数值类型（int和float）有一些区别。数值类型是标量类型，也就是说这种类型的对象没有可以访问的内部结构；而字符串类型是一种结构化的、非标量类型，所以才会有一系列的属性和方法。接下来我们要介绍的列表（list），也是一种结构化的、非标量类型，它是值的有序序列，每个值都可以通过索引进行标识，定义列表可以将列表的元素放在[]中，多个元素用,进行分隔，可以使用for循环对列表元素进行遍历，也可以使用[]或[:]运算符取出列表中的一个或多个元素。 下面的代码演示了如何定义列表、如何遍历列表以及列表的下标运算。 list1 &#x3D; [1, 3, 5, 7, 100] print(list1) # [1, 3, 5, 7, 100] # 乘号表示列表元素的重复 list2 &#x3D; [&#39;hello&#39;] * 3 print(list2) # [&#39;hello&#39;, &#39;hello&#39;, &#39;hello&#39;] # 计算列表长度(元素个数) print(len(list1)) # 5 # 下标(索引)运算 print(list1[0]) # 1 print(list1[4]) # 100 # print(list1[5]) # IndexError: list index out of range print(list1[-1]) # 100 print(list1[-3]) # 5 list1[2] &#x3D; 300 print(list1) # [1, 3, 300, 7, 100] # 通过循环用下标遍历列表元素 for index in range(len(list1)): print(list1[index]) # 通过for循环遍历列表元素 for elem in list1: print(elem) # 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值 for index, elem in enumerate(list1): print(index, elem) 下面的代码演示了如何向列表中添加元素以及如何从列表中移除元素。 list1 &#x3D; [1, 3, 5, 7, 100] # 添加元素 list1.append(200) list1.insert(1, 400) # 合并两个列表 # list1.extend([1000, 2000]) list1 +&#x3D; [1000, 2000] print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000] print(len(list1)) # 9 # 先通过成员运算判断元素是否在列表中，如果存在就删除该元素 if 3 in list1: list1.remove(3) if 1234 in list1: list1.remove(1234) print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000] # 从指定的位置删除元素 list1.pop(0) list1.pop(len(list1) - 1) print(list1) # [400, 5, 7, 100, 200, 1000] # 清空列表元素 list1.clear() print(list1) # [] 和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。 fruits &#x3D; [&#39;grape&#39;, &#39;apple&#39;, &#39;strawberry&#39;, &#39;waxberry&#39;] fruits +&#x3D; [&#39;pitaya&#39;, &#39;pear&#39;, &#39;mango&#39;] # 列表切片 fruits2 &#x3D; fruits[1:4] print(fruits2) # apple strawberry waxberry # 可以通过完整切片操作来复制列表 fruits3 &#x3D; fruits[:] print(fruits3) # [&#39;grape&#39;, &#39;apple&#39;, &#39;strawberry&#39;, &#39;waxberry&#39;, &#39;pitaya&#39;, &#39;pear&#39;, &#39;mango&#39;] fruits4 &#x3D; fruits[-3:-1] print(fruits4) # [&#39;pitaya&#39;, &#39;pear&#39;] # 可以通过反向切片操作来获得倒转后的列表的拷贝 fruits5 &#x3D; fruits[::-1] print(fruits5) # [&#39;mango&#39;, &#39;pear&#39;, &#39;pitaya&#39;, &#39;waxberry&#39;, &#39;strawberry&#39;, &#39;apple&#39;, &#39;grape&#39;] 下面的代码实现了对列表的排序操作。 list1 &#x3D; [&#39;orange&#39;, &#39;apple&#39;, &#39;zoo&#39;, &#39;internationalization&#39;, &#39;blueberry&#39;] list2 &#x3D; sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 &#x3D; sorted(list1, reverse&#x3D;True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 &#x3D; sorted(list1, key&#x3D;len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse&#x3D;True) print(list1) 生成式和生成器我们还可以使用列表的生成式语法来创建列表，代码如下所示。 f &#x3D; [x for x in range(1, 10)] print(f) f &#x3D; [x + y for x in &#39;ABCDE&#39; for y in &#39;1234567&#39;] print(f) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f &#x3D; [x ** 2 for x in range(1, 1000)] print(sys.getsizeof(f)) # 查看对象占用内存的字节数 print(f) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f &#x3D; (x ** 2 for x in range(1, 1000)) print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间 print(f) for val in f: print(val) 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。所谓斐波拉切数列可以通过下面递归的方法来进行定义： def fib(n): a, b &#x3D; 0, 1 for _ in range(n): a, b &#x3D; b, a + b yield a def main(): for val in fib(20): print(val) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 使用元组Python中的元组与列表类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。 # 定义元组 t &#x3D; (&#39;骆昊&#39;, 38, True, &#39;四川成都&#39;) print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] &#x3D; &#39;王大锤&#39; # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t &#x3D; (&#39;王大锤&#39;, 20, True, &#39;云南昆明&#39;) print(t) # 将元组转换成列表 person &#x3D; list(t) print(person) # 列表是可以修改它的元素的 person[0] &#x3D; &#39;李小龙&#39; person[1] &#x3D; 25 print(person) # 将列表转换成元组 fruits_list &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;] fruits_tuple &#x3D; tuple(fruits_list) print(fruits_tuple) 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。 使用集合Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。 可以按照下面代码所示的方式来创建和使用集合。 # 创建集合的字面量语法 set1 &#x3D; &#123;1, 2, 3, 3, 3, 2&#125; print(set1) print(&#39;Length &#x3D;&#39;, len(set1)) # 创建集合的构造器语法(面向对象部分会进行详细讲解) set2 &#x3D; set(range(1, 10)) set3 &#x3D; set((1, 2, 3, 3, 2, 1)) print(set2, set3) # 创建集合的推导式语法(推导式也可以用于推导集合) set4 &#x3D; &#123;num for num in range(1, 100) if num % 3 &#x3D;&#x3D; 0 or num % 5 &#x3D;&#x3D; 0&#125; print(set4) 向集合添加元素和从集合删除元素。 set1.add(4) set1.add(5) set2.update([11, 12]) set2.discard(5) if 4 in set2: set2.remove(4) print(set1, set2) print(set3.pop()) print(set3) 集合的成员、交集、并集、差集等运算。 # 集合的交集、并集、差集、对称差运算 print(set1 &amp; set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 &lt;&#x3D; set1) # print(set2.issubset(set1)) print(set3 &lt;&#x3D; set1) # print(set3.issubset(set1)) print(set1 &gt;&#x3D; set2) # print(set1.issuperset(set2)) print(set1 &gt;&#x3D; set3) # print(set1.issuperset(set3)) 说明： Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&amp;运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。 使用字典字典是另一种可变容器模型，Python中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。 # 创建字典的字面量语法 scores &#x3D; &#123;&#39;骆昊&#39;: 95, &#39;白元芳&#39;: 78, &#39;狄仁杰&#39;: 82&#125; print(scores) # 创建字典的构造器语法 items1 &#x3D; dict(one&#x3D;1, two&#x3D;2, three&#x3D;3, four&#x3D;4) # 通过zip函数将两个序列压成字典 items2 &#x3D; dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;123&#39;)) # 创建字典的推导式语法 items3 &#x3D; &#123;num: num ** 2 for num in range(1, 10)&#125; print(items1, items2, items3) # 通过键可以获取字典中对应的值 print(scores[&#39;骆昊&#39;]) print(scores[&#39;狄仁杰&#39;]) # 对字典中所有键值对进行遍历 for key in scores: print(f&#39;&#123;key&#125;: &#123;scores[key]&#125;&#39;) # 更新字典中的元素 scores[&#39;白元芳&#39;] &#x3D; 65 scores[&#39;诸葛王朗&#39;] &#x3D; 71 scores.update(冷面&#x3D;67, 方启鹤&#x3D;85) print(scores) if &#39;武则天&#39; in scores: print(scores[&#39;武则天&#39;]) print(scores.get(&#39;武则天&#39;)) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get(&#39;武则天&#39;, 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop(&#39;骆昊&#39;, 100)) # 清空字典 scores.clear() print(scores) 练习练习1：在屏幕上显示跑马灯文字。参考答案： import os import time def main(): content &#x3D; &#39;北京欢迎你为你开天辟地…………&#39; while True: # 清理屏幕上的输出 os.system(&#39;cls&#39;) # os.system(&#39;clear&#39;) print(content) # 休眠200毫秒 time.sleep(0.2) content &#x3D; content[1:] + content[0] if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。参考答案： import random def generate_code(code_len&#x3D;4): &quot;&quot;&quot; 生成指定长度的验证码 :param code_len: 验证码的长度(默认4个字符) :return: 由大小写英文字母和数字构成的随机验证码 &quot;&quot;&quot; all_chars &#x3D; &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; last_pos &#x3D; len(all_chars) - 1 code &#x3D; &#39;&#39; for _ in range(code_len): index &#x3D; random.randint(0, last_pos) code +&#x3D; all_chars[index] return code 练习3：设计一个函数返回给定文件名的后缀名。参考答案： def get_suffix(filename, has_dot&#x3D;False): &quot;&quot;&quot; 获取文件名的后缀名 :param filename: 文件名 :param has_dot: 返回的后缀名是否需要带点 :return: 文件的后缀名 &quot;&quot;&quot; pos &#x3D; filename.rfind(&#39;.&#39;) if 0 &lt; pos &lt; len(filename) - 1: index &#x3D; pos if has_dot else pos + 1 return filename[index:] else: return &#39;&#39; 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。参考答案： def max2(x): m1, m2 &#x3D; (x[0], x[1]) if x[0] &gt; x[1] else (x[1], x[0]) for index in range(2, len(x)): if x[index] &gt; m1: m2 &#x3D; m1 m1 &#x3D; x[index] elif x[index] &gt; m2: m2 &#x3D; x[index] return m1, m2 练习5：计算指定的年月日是这一年的第几天。参考答案： def is_leap_year(year): &quot;&quot;&quot; 判断指定的年份是不是闰年 :param year: 年份 :return: 闰年返回True平年返回False &quot;&quot;&quot; return year % 4 &#x3D;&#x3D; 0 and year % 100 !&#x3D; 0 or year % 400 &#x3D;&#x3D; 0 def which_day(year, month, date): &quot;&quot;&quot; 计算传入的日期是这一年的第几天 :param year: 年 :param month: 月 :param date: 日 :return: 第几天 &quot;&quot;&quot; days_of_month &#x3D; [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total &#x3D; 0 for index in range(month - 1): total +&#x3D; days_of_month[index] return total + date def main(): print(which_day(1980, 11, 28)) print(which_day(1981, 12, 31)) print(which_day(2018, 1, 1)) print(which_day(2016, 3, 1)) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 练习6：打印杨辉三角。参考答案： def main(): num &#x3D; int(input(&#39;Number of rows: &#39;)) yh &#x3D; [[]] * num for row in range(len(yh)): yh[row] &#x3D; [None] * (row + 1) for col in range(len(yh[row])): if col &#x3D;&#x3D; 0 or col &#x3D;&#x3D; row: yh[row][col] &#x3D; 1 else: yh[row][col] &#x3D; yh[row - 1][col] + yh[row - 1][col - 1] print(yh[row][col], end&#x3D;&#39;\\t&#39;) print() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 综合案例案例1：双色球选号。from random import randrange, randint, sample def display(balls): &quot;&quot;&quot; 输出列表中的双色球号码 &quot;&quot;&quot; for index, ball in enumerate(balls): if index &#x3D;&#x3D; len(balls) - 1: print(&#39;|&#39;, end&#x3D;&#39; &#39;) print(&#39;%02d&#39; % ball, end&#x3D;&#39; &#39;) print() def random_select(): &quot;&quot;&quot; 随机选择一组号码 &quot;&quot;&quot; red_balls &#x3D; [x for x in range(1, 34)] selected_balls &#x3D; [] selected_balls &#x3D; sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_balls def main(): n &#x3D; int(input(&#39;机选几注: &#39;)) for _ in range(n): display(random_select()) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明： 上面使用random模块的sample函数来实现从列表中选择不重复的n个元素。 综合案例2：约瑟夫环问题。&quot;&quot;&quot; 《幸运的基督徒》 有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。 &quot;&quot;&quot; def main(): persons &#x3D; [True] * 30 counter, index, number &#x3D; 0, 0, 0 while counter &lt; 15: if persons[index]: number +&#x3D; 1 if number &#x3D;&#x3D; 9: persons[index] &#x3D; False counter +&#x3D; 1 number &#x3D; 0 index +&#x3D; 1 index %&#x3D; 30 for person in persons: print(&#39;基&#39; if person else &#39;非&#39;, end&#x3D;&#39;&#39;) if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 综合案例3：井字棋游戏。import os def print_board(board): print(board[&#39;TL&#39;] + &#39;|&#39; + board[&#39;TM&#39;] + &#39;|&#39; + board[&#39;TR&#39;]) print(&#39;-+-+-&#39;) print(board[&#39;ML&#39;] + &#39;|&#39; + board[&#39;MM&#39;] + &#39;|&#39; + board[&#39;MR&#39;]) print(&#39;-+-+-&#39;) print(board[&#39;BL&#39;] + &#39;|&#39; + board[&#39;BM&#39;] + &#39;|&#39; + board[&#39;BR&#39;]) def main(): init_board &#x3D; &#123; &#39;TL&#39;: &#39; &#39;, &#39;TM&#39;: &#39; &#39;, &#39;TR&#39;: &#39; &#39;, &#39;ML&#39;: &#39; &#39;, &#39;MM&#39;: &#39; &#39;, &#39;MR&#39;: &#39; &#39;, &#39;BL&#39;: &#39; &#39;, &#39;BM&#39;: &#39; &#39;, &#39;BR&#39;: &#39; &#39; &#125; begin &#x3D; True while begin: curr_board &#x3D; init_board.copy() begin &#x3D; False turn &#x3D; &#39;x&#39; counter &#x3D; 0 os.system(&#39;clear&#39;) print_board(curr_board) while counter &lt; 9: move &#x3D; input(&#39;轮到%s走棋, 请输入位置: &#39; % turn) if curr_board[move] &#x3D;&#x3D; &#39; &#39;: counter +&#x3D; 1 curr_board[move] &#x3D; turn if turn &#x3D;&#x3D; &#39;x&#39;: turn &#x3D; &#39;o&#39; else: turn &#x3D; &#39;x&#39; os.system(&#39;clear&#39;) print_board(curr_board) choice &#x3D; input(&#39;再玩一局?(yes|no)&#39;) begin &#x3D; choice &#x3D;&#x3D; &#39;yes&#39; if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 说明： 最后这个案例来自《Python编程快速上手:让繁琐工作自动化》一书（这本书对有编程基础想迅速使用Python将日常工作自动化的人来说还是不错的选择），对代码做了一点点的调整。","path":"2021/05/06/zi-fu-chuan-he-chang-yong-shu-ju-jie-gou/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"函数和模块的使用","text":"在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。 事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。 可以用Python的程序来计算出这个值，代码如下所示。 &quot;&quot;&quot; 输入M和N计算C(M,N) Version: 0.1 Author: 骆昊 &quot;&quot;&quot; m &#x3D; int(input(&#39;m &#x3D; &#39;)) n &#x3D; int(input(&#39;n &#x3D; &#39;)) fm &#x3D; 1 for num in range(1, m + 1): fm *&#x3D; num fn &#x3D; 1 for num in range(1, n + 1): fn *&#x3D; num fmn &#x3D; 1 for num in range(1, m - n + 1): fmn *&#x3D; num print(fm &#x2F;&#x2F; fn &#x2F;&#x2F; fmn) 函数的作用不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。 定义函数在Python中可以使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。 在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。 def factorial(num): &quot;&quot;&quot;求阶乘&quot;&quot;&quot; result &#x3D; 1 for n in range(1, num + 1): result *&#x3D; n return result m &#x3D; int(input(&#39;m &#x3D; &#39;)) n &#x3D; int(input(&#39;n &#x3D; &#39;)) # 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数 print(factorial(m) &#x2F;&#x2F; factorial(n) &#x2F;&#x2F; factorial(m - n)) 说明： Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。下面例子中的一些函数在Python中也都是现成的，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中不建议做这种低级的重复性的工作。 函数的参数函数是绝大多数编程语言中都支持的一个代码的&quot;构建块&quot;，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。 from random import randint def roll_dice(n&#x3D;2): &quot;&quot;&quot;摇色子&quot;&quot;&quot; total &#x3D; 0 for _ in range(n): total +&#x3D; randint(1, 6) return total def add(a&#x3D;0, b&#x3D;0, c&#x3D;0): &quot;&quot;&quot;三个数相加&quot;&quot;&quot; return a + b + c # 如果没有指定参数那么使用默认值摇两颗色子 print(roll_dice()) # 摇三颗色子 print(roll_dice(3)) print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) # 传递参数时可以不按照设定的顺序进行传递 print(add(c&#x3D;50, a&#x3D;100, b&#x3D;200)) 我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。 其实上面的add函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。 # 在参数名前面的*表示args是一个可变参数 def add(*args): total &#x3D; 0 for val in args: total +&#x3D; val return total # 在调用add函数时可以传入0个或多个参数 print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) print(add(1, 3, 5, 7, 9)) 用模块管理函数对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。 def foo(): print(&#39;hello, world!&#39;) def foo(): print(&#39;goodbye, world!&#39;) # 下面的代码会输出什么呢？ foo() 当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数，代码如下所示。 module1.py def foo(): print(&#39;hello, world!&#39;) module2.py def foo(): print(&#39;goodbye, world!&#39;) test.py from module1 import foo # 输出hello, world! foo() from module2 import foo # 输出goodbye, world! foo() 也可以按照如下所示的方式来区分到底要使用哪一个foo函数。 test.py import module1 as m1 import module2 as m2 m1.foo() m2.foo() 但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个foo，因为后导入的foo覆盖了之前导入的foo。 test.py from module1 import foo from module2 import foo # 输出goodbye, world! foo() test.py from module2 import foo from module1 import foo # 输出hello, world! foo() 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是&quot;__main__&quot;。 module3.py def foo(): pass def bar(): pass # __name__是Python中一个隐含的变量它代表了模块的名字 # 只有被Python解释器直接执行的模块的名字才是__main__ if __name__ &#x3D;&#x3D; &#39;__main__&#39;: print(&#39;call foo()&#39;) foo() print(&#39;call bar()&#39;) bar() test.py import module3 # 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__ 练习练习1：实现计算求最大公约数和最小公倍数的函数。参考答案： def gcd(x, y): &quot;&quot;&quot;求最大公约数&quot;&quot;&quot; (x, y) &#x3D; (y, x) if x &gt; y else (x, y) for factor in range(x, 0, -1): if x % factor &#x3D;&#x3D; 0 and y % factor &#x3D;&#x3D; 0: return factor def lcm(x, y): &quot;&quot;&quot;求最小公倍数&quot;&quot;&quot; return x * y &#x2F;&#x2F; gcd(x, y) 练习2：实现判断一个数是不是回文数的函数。参考答案： def is_palindrome(num): &quot;&quot;&quot;判断一个数是不是回文数&quot;&quot;&quot; temp &#x3D; num total &#x3D; 0 while temp &gt; 0: total &#x3D; total * 10 + temp % 10 temp &#x2F;&#x2F;&#x3D; 10 return total &#x3D;&#x3D; num 练习3：实现判断一个数是不是素数的函数。参考答案： def is_prime(num): &quot;&quot;&quot;判断一个数是不是素数&quot;&quot;&quot; for factor in range(2, num): if num % factor &#x3D;&#x3D; 0: return False return True if num !&#x3D; 1 else False 练习4：写一个程序判断输入的正整数是不是回文素数。参考答案： if __name__ &#x3D;&#x3D; &#39;__main__&#39;: num &#x3D; int(input(&#39;请输入正整数: &#39;)) if is_palindrome(num) and is_prime(num): print(&#39;%d是回文素数&#39; % num) 注意：通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。 最后，我们来讨论一下Python中有关变量作用域的问题。 def foo(): b &#x3D; &#39;hello&#39; # Python中可以在函数内部再定义函数 def bar(): c &#x3D; True print(a) print(b) print(c) bar() # print(c) # NameError: name &#39;c&#39; is not defined if __name__ &#x3D;&#x3D; &#39;__main__&#39;: a &#x3D; 100 # print(b) # NameError: name &#39;b&#39; is not defined foo() 上面的代码能够顺利的执行并且打印出100、hello和True，但我们注意到了，在bar函数的内部并没有定义a和b两个变量，那么a和b是从哪里来的。我们在上面代码的if分支中定义了一个变量a，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在foo函数的外部并不能访问到它；但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它的。bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的input、print、int等都属于内置作用域。 再看看下面这段代码，我们希望通过函数调用修改全局变量a的值，但实际上下面的代码是做不到的。 def foo(): a &#x3D; 200 print(a) # 200 if __name__ &#x3D;&#x3D; &#39;__main__&#39;: a &#x3D; 100 foo() print(a) # 100 在调用foo函数后，我们发现a的值仍然是100，这是因为当我们在函数foo中写a = 200的时候，是重新定义了一个名字为a的局部变量，它跟全局作用域的a并不是同一个变量，因为局部作用域中有了自己的变量a，因此foo函数不再搜索全局作用域中的a。如果我们希望在foo函数中修改全局作用域中的a，代码如下所示。 def foo(): global a a &#x3D; 200 print(a) # 200 if __name__ &#x3D;&#x3D; &#39;__main__&#39;: a &#x3D; 100 foo() print(a) # 200 我们可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，那么下面一行的代码就会定义变量a并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用nonlocal关键字来指示变量来自于嵌套作用域，请大家自行试验。 在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以使用它的值，这时候就需要使用闭包，这个我们在后续的内容中进行讲解。 说明： 很多人经常会将“闭包”和“匿名函数”混为一谈，但实际上它们并不是一回事，如果想了解这个概念，可以看看维基百科的解释或者知乎上对这个概念的讨论。 说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。 def main(): # Todo: Add your code here pass if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main()","path":"2021/05/06/han-shu-he-mo-kuai-de-shi-yong/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"构造程序逻辑","text":"学完前面的几个章节后，我觉得有必要在这里带大家做一些练习来巩固之前所学的知识，虽然迄今为止我们学习的内容只是Python的冰山一角，但是这些内容已经足够我们来构建程序中的逻辑。对于编程语言的初学者来说，在学习了Python的核心语言元素（变量、类型、运算符、表达式、分支结构、循环结构等）之后，必须做的一件事情就是尝试用所学知识去解决现实中的问题，换句话说就是锻炼自己把用人类自然语言描述的算法（解决问题的方法和步骤）翻译成Python代码的能力，而这件事情必须通过大量的练习才能达成。 我们在本章为大家整理了一些经典的案例和习题，希望通过这些例子，一方面帮助大家巩固之前所学的Python知识，另一方面帮助大家了解如何建立程序中的逻辑以及如何运用一些简单的算法解决现实中的问题。 经典的例子 寻找水仙花数。 说明：水仙花数也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个3位数，该数字每个位上数字的立方之和正好等于它本身，例如：$1^3 + 5^3+ 3^3=153$。 &quot;&quot;&quot; 找出所有水仙花数 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; for num in range(100, 1000): low &#x3D; num % 10 mid &#x3D; num &#x2F;&#x2F; 10 % 10 high &#x3D; num &#x2F;&#x2F; 100 if num &#x3D;&#x3D; low ** 3 + mid ** 3 + high ** 3: print(num) 在上面的代码中，我们通过整除和求模运算分别找出了一个三位数的个位、十位和百位，这种小技巧在实际开发中还是常用的。用类似的方法，我们还可以实现将一个正整数反转，例如：将12345变成54321，代码如下所示。 &quot;&quot;&quot; 正整数的反转 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; num &#x3D; int(input(&#39;num &#x3D; &#39;)) reversed_num &#x3D; 0 while num &gt; 0: reversed_num &#x3D; reversed_num * 10 + num % 10 num &#x2F;&#x2F;&#x3D; 10 print(reversed_num) 百钱百鸡问题。 说明：百钱百鸡是我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：公鸡5元一只，母鸡3元一只，小鸡1元三只，用100块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？ &quot;&quot;&quot; 《百钱百鸡》问题 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; for x in range(0, 20): for y in range(0, 33): z &#x3D; 100 - x - y if 5 * x + 3 * y + z &#x2F; 3 &#x3D;&#x3D; 100: print(&#39;公鸡: %d只, 母鸡: %d只, 小鸡: %d只&#39; % (x, y, z)) 上面使用的方法叫做穷举法，也称为暴力搜索法，这种方法通过一项一项的列举备选解决方案中所有可能的候选项并检查每个候选项是否符合问题的描述，最终得到问题的解。这种方法看起来比较笨拙，但对于运算能力非常强大的计算机来说，通常都是一个可行的甚至是不错的选择，而且问题的解如果存在，这种方法一定能够找到它。 CRAPS赌博游戏。 说明：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简单的规则是：玩家第一次摇骰子如果摇出了7点或11点，玩家胜；玩家第一次如果摇出2点、3点或12点，庄家胜；其他点数玩家继续摇骰子，如果玩家摇出了7点，庄家胜；如果玩家摇出了第一次摇的点数，玩家胜；其他点数，玩家继续要骰子，直到分出胜负。 &quot;&quot;&quot; Craps赌博游戏 我们设定玩家开始游戏时有1000元的赌注 游戏结束的条件是玩家输光所有的赌注 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; from random import randint money &#x3D; 1000 while money &gt; 0: print(&#39;你的总资产为:&#39;, money) needs_go_on &#x3D; False while True: debt &#x3D; int(input(&#39;请下注: &#39;)) if 0 &lt; debt &lt;&#x3D; money: break first &#x3D; randint(1, 6) + randint(1, 6) print(&#39;玩家摇出了%d点&#39; % first) if first &#x3D;&#x3D; 7 or first &#x3D;&#x3D; 11: print(&#39;玩家胜!&#39;) money +&#x3D; debt elif first &#x3D;&#x3D; 2 or first &#x3D;&#x3D; 3 or first &#x3D;&#x3D; 12: print(&#39;庄家胜!&#39;) money -&#x3D; debt else: needs_go_on &#x3D; True while needs_go_on: needs_go_on &#x3D; False current &#x3D; randint(1, 6) + randint(1, 6) print(&#39;玩家摇出了%d点&#39; % current) if current &#x3D;&#x3D; 7: print(&#39;庄家胜&#39;) money -&#x3D; debt elif current &#x3D;&#x3D; first: print(&#39;玩家胜&#39;) money +&#x3D; debt else: needs_go_on &#x3D; True print(&#39;你破产了, 游戏结束!&#39;) ###有用的练习 生成斐波那契数列的前20个数。 说明：斐波那契数列（Fibonacci sequence），又称黄金分割数列，是意大利数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）在《计算之书》中提出一个在理想假设条件下兔子成长率的问题而引入的数列，所以这个数列也被戏称为&quot;兔子数列&quot;。斐波那契数列的特点是数列的前两个数都是1，从第三个数开始，每个数都是它前面两个数的和，形如：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …。斐波那契数列在现代物理、准晶体结构、化学等领域都有直接的应用。 找出10000以内的完美数。 说明：完美数又称为完全数或完备数，它的所有的真因子（即除了自身以外的因子）的和（即因子函数）恰好等于它本身。例如：6（$6=1+2+3$）和28（$28=1+2+4+7+14$）就是完美数。完美数有很多神奇的特性，有兴趣的可以自行了解。 输出100以内所有的素数。 说明：素数指的是只能被1和自身整除的正整数（不包括1）。 上面练习的参考答案在本章对应的代码目录中，如果需要帮助请读者自行查看参考答案。","path":"2021/05/06/gou-zao-cheng-xu-luo-ji/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"循环结构","text":"应用场景如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中不仅仅有需要重复的动作，还需要用到上一章讲的分支结构。再举一个简单的例子，我们要实现一个每隔1秒中在屏幕上打印一次&quot;hello, world&quot;并持续打印一个小时的程序，我们肯定不能够直接把print(&#39;hello, world&#39;)这句代码写3600遍，如果真的要这样做，那么编程的工作就太无聊乏味了。因此，我们还需要了解一下循环结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的去执行。 在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。 for-in循环如果明确的知道循环执行的次数或者要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环，例如下面代码中计算1~100求和的结果（$\\displaystyle \\sum \\limits_{n=1}^{100}n$）。 &quot;&quot;&quot; 用for循环实现1~100求和 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; sum &#x3D; 0 for x in range(101): sum +&#x3D; x print(sum) 需要说明的是上面代码中的range(101)可以用来构造一个从0到100的取值范围，这样就可以构造出一个整数的序列并用于循环中，例如： range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中2是步长，即数值序列的增量。 知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。 &quot;&quot;&quot; 用for循环实现1~100之间的偶数求和 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; sum &#x3D; 0 for x in range(2, 101, 2): sum +&#x3D; x print(sum) 也可以通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示。 &quot;&quot;&quot; 用for循环实现1~100之间的偶数求和 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; sum &#x3D; 0 for x in range(1, 101): if x % 2 &#x3D;&#x3D; 0: sum +&#x3D; x print(sum) while循环如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。 &quot;&quot;&quot; 猜数字游戏 计算机出一个1~100之间的随机数由人来猜 计算机根据人猜的数字分别给出提示大一点&#x2F;小一点&#x2F;猜对了 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; import random answer &#x3D; random.randint(1, 100) counter &#x3D; 0 while True: counter +&#x3D; 1 number &#x3D; int(input(&#39;请输入: &#39;)) if number &lt; answer: print(&#39;大一点&#39;) elif number &gt; answer: print(&#39;小一点&#39;) else: print(&#39;恭喜你猜对了!&#39;) break print(&#39;你总共猜了%d次&#39; % counter) if counter &gt; 7: print(&#39;你的智商余额明显不足&#39;) 上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。 &quot;&quot;&quot; 输出乘法口诀表(九九表) Version: 0.1 Author: 骆昊 &quot;&quot;&quot; for i in range(1, 10): for j in range(1, i + 1): print(&#39;%d*%d&#x3D;%d&#39; % (i, j, i * j), end&#x3D;&#39;\\t&#39;) print() 练习练习1：输入一个正整数判断是不是素数。 提示：素数指的是只能被1和自身整除的大于1的整数。 参考答案： &quot;&quot;&quot; 输入一个正整数判断它是不是素数 Version: 0.1 Author: 骆昊 Date: 2018-03-01 &quot;&quot;&quot; from math import sqrt num &#x3D; int(input(&#39;请输入一个正整数: &#39;)) end &#x3D; int(sqrt(num)) is_prime &#x3D; True for x in range(2, end + 1): if num % x &#x3D;&#x3D; 0: is_prime &#x3D; False break if is_prime and num !&#x3D; 1: print(&#39;%d是素数&#39; % num) else: print(&#39;%d不是素数&#39; % num) 练习2：输入两个正整数，计算它们的最大公约数和最小公倍数。参考答案： &quot;&quot;&quot; 输入两个正整数计算它们的最大公约数和最小公倍数 Version: 0.1 Author: 骆昊 Date: 2018-03-01 &quot;&quot;&quot; x &#x3D; int(input(&#39;x &#x3D; &#39;)) y &#x3D; int(input(&#39;y &#x3D; &#39;)) # 如果x大于y就交换x和y的值 if x &gt; y: # 通过下面的操作将y的值赋给x, 将x的值赋给y x, y &#x3D; y, x # 从两个数中较的数开始做递减的循环 for factor in range(x, 0, -1): if x % factor &#x3D;&#x3D; 0 and y % factor &#x3D;&#x3D; 0: print(&#39;%d和%d的最大公约数是%d&#39; % (x, y, factor)) print(&#39;%d和%d的最小公倍数是%d&#39; % (x, y, x * y &#x2F;&#x2F; factor)) break 练习3：打印如下所示的三角形图案。* ** *** **** ***** * ** *** **** ***** * *** ***** ******* ********* 参考答案： &quot;&quot;&quot; 打印三角形图案 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; row &#x3D; int(input(&#39;请输入行数: &#39;)) for i in range(row): for _ in range(i + 1): print(&#39;*&#39;, end&#x3D;&#39;&#39;) print() for i in range(row): for j in range(row): if j &lt; row - i - 1: print(&#39; &#39;, end&#x3D;&#39;&#39;) else: print(&#39;*&#39;, end&#x3D;&#39;&#39;) print() for i in range(row): for _ in range(row - i - 1): print(&#39; &#39;, end&#x3D;&#39;&#39;) for _ in range(2 * i + 1): print(&#39;*&#39;, end&#x3D;&#39;&#39;) print()","path":"2021/05/06/xun-huan-jie-gou/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"分支结构","text":"应用场景迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种代码结构通常称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后，我们要根据玩家得到分数来决定究竟是进入第二关，还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行。类似的场景还有很多，我们将这种结构称之为“分支结构”或“选择结构”。给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。 if语句的使用在Python中，要构造分支结构可以使用if、elif和else关键字。所谓关键字就是有特殊含义的单词，像if和else就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。 &quot;&quot;&quot; 用户身份验证 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; username &#x3D; input(&#39;请输入用户名: &#39;) password &#x3D; input(&#39;请输入口令: &#39;) # 用户名是admin且密码是123456则身份验证成功否则身份验证失败 if username &#x3D;&#x3D; &#39;admin&#39; and password &#x3D;&#x3D; &#39;123456&#39;: print(&#39;身份验证成功!&#39;) else: print(&#39;身份验证失败!&#39;) 唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果if条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。 当然如果要构造出更多的分支，可以使用if…elif…else…结构，例如下面的分段函数求值。 &quot;&quot;&quot; 分段函数求值 3x - 5 (x &gt; 1) f(x) &#x3D; x + 2 (-1 &lt;&#x3D; x &lt;&#x3D; 1) 5x + 3 (x &lt; -1) Version: 0.1 Author: 骆昊 &quot;&quot;&quot; x &#x3D; float(input(&#39;x &#x3D; &#39;)) if x &gt; 1: y &#x3D; 3 * x - 5 elif x &gt;&#x3D; -1: y &#x3D; x + 2 else: y &#x3D; 5 * x + 3 print(&#39;f(%.2f) &#x3D; %.2f&#39; % (x, y)) 当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在if的内部构造出一个新的分支结构，同理elif和else中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。 &quot;&quot;&quot; 分段函数求值 3x - 5 (x &gt; 1) f(x) &#x3D; x + 2 (-1 &lt;&#x3D; x &lt;&#x3D; 1) 5x + 3 (x &lt; -1) Version: 0.1 Author: 骆昊 &quot;&quot;&quot; x &#x3D; float(input(&#39;x &#x3D; &#39;)) if x &gt; 1: y &#x3D; 3 * x - 5 else: if x &gt;&#x3D; -1: y &#x3D; x + 2 else: y &#x3D; 5 * x + 3 print(&#39;f(%.2f) &#x3D; %.2f&#39; % (x, y)) 说明： 大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than nested.”，之所以提倡代码“扁平化”是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，所以能使用扁平化的结构时就不要使用嵌套。 练习练习1：英制单位英寸与公制单位厘米互换。参考答案： &quot;&quot;&quot; 英制单位英寸和公制单位厘米互换 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; value &#x3D; float(input(&#39;请输入长度: &#39;)) unit &#x3D; input(&#39;请输入单位: &#39;) if unit &#x3D;&#x3D; &#39;in&#39; or unit &#x3D;&#x3D; &#39;英寸&#39;: print(&#39;%f英寸 &#x3D; %f厘米&#39; % (value, value * 2.54)) elif unit &#x3D;&#x3D; &#39;cm&#39; or unit &#x3D;&#x3D; &#39;厘米&#39;: print(&#39;%f厘米 &#x3D; %f英寸&#39; % (value, value &#x2F; 2.54)) else: print(&#39;请输入有效的单位&#39;) 练习2：百分制成绩转换为等级制成绩。 要求：如果输入的成绩在90分以上（含90分）输出A；80分-90分（不含90分）输出B；70分-80分（不含80分）输出C；60分-70分（不含70分）输出D；60分以下输出E。 参考答案： &quot;&quot;&quot; 百分制成绩转换为等级制成绩 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; score &#x3D; float(input(&#39;请输入成绩: &#39;)) if score &gt;&#x3D; 90: grade &#x3D; &#39;A&#39; elif score &gt;&#x3D; 80: grade &#x3D; &#39;B&#39; elif score &gt;&#x3D; 70: grade &#x3D; &#39;C&#39; elif score &gt;&#x3D; 60: grade &#x3D; &#39;D&#39; else: grade &#x3D; &#39;E&#39; print(&#39;对应的等级是:&#39;, grade) 练习3：输入三条边长，如果能构成三角形就计算周长和面积。参考答案： &quot;&quot;&quot; 判断输入的边长能否构成三角形，如果能则计算出三角形的周长和面积 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; a &#x3D; float(input(&#39;a &#x3D; &#39;)) b &#x3D; float(input(&#39;b &#x3D; &#39;)) c &#x3D; float(input(&#39;c &#x3D; &#39;)) if a + b &gt; c and a + c &gt; b and b + c &gt; a: print(&#39;周长: %f&#39; % (a + b + c)) p &#x3D; (a + b + c) &#x2F; 2 area &#x3D; (p * (p - a) * (p - b) * (p - c)) ** 0.5 print(&#39;面积: %f&#39; % (area)) else: print(&#39;不能构成三角形&#39;) 说明： 上面使用的通过边长计算三角形面积的公式叫做海伦公式。","path":"2021/05/06/fen-zhi-jie-gou/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"语言元素","text":"指令和程序计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们大多数时候使用的计算机，虽然它们的元器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于“冯·诺依曼结构”的计算机。“冯·诺依曼结构”有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用维基百科或者百度百科科普一下。 提示：近期关于量子计算机的研究已经被推倒了风口浪尖，量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息。2018年6月，Intel宣布开发出新款量子芯片并通过了在接近绝对零度环境下的测试；2019年，IBM和Google都推出了自己的量子计算机。 变量和类型在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型：字符串是以单引号或双引号括起来的任意文本，比如&#39;hello&#39;和&quot;hello&quot;,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 复数型：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的i换成了j。实际上，这个类型并不能算作常用类型，大家了解下就可以了。 变量命名对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： 变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。 大小写敏感（大写的a和小写的A是两个不同的变量）。 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： 用小写字母拼写，多个单词用下划线连接。 受保护的实例属性用单个下划线开头（后面会讲到）。 私有的实例属性用两个下划线开头（后面会讲到）。 当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到见名知意也是非常重要的。 变量的使用下面通过几个例子来说明变量的类型和变量使用。 &quot;&quot;&quot; 使用变量保存数据并进行算术运算 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; a &#x3D; 321 b &#x3D; 123 print(a + b) print(a - b) print(a * b) print(a &#x2F; b) print(a &#x2F;&#x2F; b) print(a % b) print(a ** b) 在Python中可以使用type函数对变量的类型进行检查。程序设计中函数的概念跟数学上函数的概念是一致的，数学上的函数相信大家并不陌生，它包括了函数名、自变量和因变量。如果暂时不理解这个概念也不要紧，我们会在后续的章节中专门讲解函数的定义和使用。 &quot;&quot;&quot; 使用type()检查变量的类型 Version: 0.1 Author: 骆昊 Date: 2018-02-27 &quot;&quot;&quot; a &#x3D; 100 b &#x3D; 12.345 c &#x3D; 1 + 5j d &#x3D; &#39;hello, world&#39; e &#x3D; True print(type(a)) # &lt;class &#39;int&#39;&gt; print(type(b)) # &lt;class &#39;float&#39;&gt; print(type(c)) # &lt;class &#39;complex&#39;&gt; print(type(d)) # &lt;class &#39;str&#39;&gt; print(type(e)) # &lt;class &#39;bool&#39;&gt; 可以使用Python中内置的函数对变量类型进行转换。 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 下面的代码通过键盘输入两个整数来实现对两个整数的算术运算。 &quot;&quot;&quot; 使用input()函数获取键盘输入(字符串) 使用int()函数将输入的字符串转换成整数 使用print()函数输出带占位符的字符串 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; a &#x3D; int(input(&#39;a &#x3D; &#39;)) b &#x3D; int(input(&#39;b &#x3D; &#39;)) print(&#39;%d + %d &#x3D; %d&#39; % (a, b, a + b)) print(&#39;%d - %d &#x3D; %d&#39; % (a, b, a - b)) print(&#39;%d * %d &#x3D; %d&#39; % (a, b, a * b)) print(&#39;%d &#x2F; %d &#x3D; %f&#39; % (a, b, a &#x2F; b)) print(&#39;%d &#x2F;&#x2F; %d &#x3D; %d&#39; % (a, b, a &#x2F;&#x2F; b)) print(&#39;%d %% %d &#x3D; %d&#39; % (a, b, a % b)) print(&#39;%d ** %d &#x3D; %d&#39; % (a, b, a ** b)) 说明：上面的print函数中输出的字符串使用了占位符语法，其中%d是整数的占位符，%f是小数的占位符，%%表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成%%），字符串之后的%后面跟的变量值会替换掉占位符然后输出到终端中，运行上面的程序，看看程序执行结果就明白啦。 运算符Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。除了我们之前已经用过的赋值运算符和算术运算符，我们稍后会陆续讲到其他运算符的使用。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ | 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` = ^= &gt;&gt;= &lt;&lt;=` 说明： 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。 下面的例子演示了赋值运算符和复合赋值运算符的使用。 &quot;&quot;&quot; 赋值运算符和复合赋值运算符 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; a &#x3D; 10 b &#x3D; 3 a +&#x3D; b # 相当于：a &#x3D; a + b a *&#x3D; a + 2 # 相当于：a &#x3D; a * (a + 2) print(a) # 想想这里会输出什么 下面的例子演示了比较运算符（关系运算符）、逻辑运算符和身份运算符的使用。 &quot;&quot;&quot; 比较、逻辑和算身份运算符的使用 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; flag0 &#x3D; 1 &#x3D;&#x3D; 1 flag1 &#x3D; 3 &gt; 2 flag2 &#x3D; 2 &lt; 1 flag3 &#x3D; flag1 and flag2 flag4 &#x3D; flag1 or flag2 flag5 &#x3D; not (1 !&#x3D; 2) print(&#39;flag0 &#x3D;&#39;, flag0) # flag0 &#x3D; True print(&#39;flag1 &#x3D;&#39;, flag1) # flag1 &#x3D; True print(&#39;flag2 &#x3D;&#39;, flag2) # flag2 &#x3D; False print(&#39;flag3 &#x3D;&#39;, flag3) # flag3 &#x3D; False print(&#39;flag4 &#x3D;&#39;, flag4) # flag4 &#x3D; True print(&#39;flag5 &#x3D;&#39;, flag5) # flag5 &#x3D; False print(flag1 is True) # True print(flag2 is not False) # False 练习练习1：华氏温度转换为摄氏温度。 提示：华氏温度到摄氏温度的转换公式为：$C=(F - 32) \\div 1.8$。 参考答案： &quot;&quot;&quot; 将华氏温度转换为摄氏温度 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; f &#x3D; float(input(&#39;请输入华氏温度: &#39;)) c &#x3D; (f - 32) &#x2F; 1.8 print(&#39;%.1f华氏度 &#x3D; %.1f摄氏度&#39; % (f, c)) 练习2：输入圆的半径计算计算周长和面积。参考答案： &quot;&quot;&quot; 输入半径计算圆的周长和面积 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; import math radius &#x3D; float(input(&#39;请输入圆的半径: &#39;)) perimeter &#x3D; 2 * math.pi * radius area &#x3D; math.pi * radius * radius print(&#39;周长: %.2f&#39; % perimeter) print(&#39;面积: %.2f&#39; % area) 练习3：输入年份判断是不是闰年。参考答案： &quot;&quot;&quot; 输入年份 如果是闰年输出True 否则输出False Version: 0.1 Author: 骆昊 &quot;&quot;&quot; year &#x3D; int(input(&#39;请输入年份: &#39;)) # 如果代码太长写成一行不便于阅读 可以使用\\对代码进行折行 is_leap &#x3D; (year % 4 &#x3D;&#x3D; 0 and year % 100 !&#x3D; 0) or \\ year % 400 &#x3D;&#x3D; 0 print(is_leap)","path":"2021/05/06/yu-yan-yuan-su/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"初识Python","text":"Python简介Python的历史 1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，还有对列表、字典等核心数据类型，同时支持以模块为基础来构造应用程序。 1994年1月：Python 1.0正式发布。 2000年10月16日：Python 2.0发布，增加了完整的垃圾回收，提供了对Unicode的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。 2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。 目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以阅读名为《Python简史》的博文。 Python的优缺点Python的优点很多，简单的可以总结为以下几点。 简单和明确，做一件事只有一种方法。 学习曲线低，跟其他很多语言相比，Python更容易上手。 开放源代码，拥有强大的社区和生态圈。 解释型语言，天生具有平台可移植性。 对两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。 可扩展性和可嵌入性，例如在Python中可以调用C/C++代码。 代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。 Python的缺点主要集中在以下几点。 执行效率稍低，因此计算密集型任务可以由C/C++编写。 代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被弱化。 在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。 Python的应用领域目前Python在Web应用开发、云基础设施、DevOps、网络数据采集（爬虫）、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、自然语言处理、图像识别等一系列相关的职位。 安装Python解释器想要开始Python编程之旅，首先得在自己使用的计算机上安装Python解释器环境，下面将以安装官方的Python解释器为例，讲解如何在不同的操作系统上安装Python环境。官方的Python解释器是用C语言实现的，也是使用最为广泛的Python解释器，通常称之为CPython。除此之外，Python解释器还有Java语言实现的Jython、C#语言实现的IronPython以及PyPy、Brython、Pyston等版本，我们暂时不对这些内容进行介绍，有兴趣的读者可以自行了解。 Windows环境可以在Python官方网站下载到Python的Windows安装程序（exe文件），需要注意的是如果在Windows 7环境下安装Python 3.x，需要先安装Service Pack 1补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选“Add Python 3.x to PATH”（将Python 3.x添加到PATH环境变量）并选择自定义安装，在设置“Optional Features”界面最好将“pip”、“tcl/tk”、“Python test suite”等项全部勾选上。强烈建议选择自定义的安装路径并保证路径中没有中文。安装完成会看到“Setup was successful”的提示。如果稍后运行Python程序时，出现因为缺失一些动态链接库文件而导致Python解释器无法工作的问题，可以按照下面的方法加以解决。 如果系统显示api-ms-win-crt*.dll文件缺失，可以参照《api-ms-win-crt*.dll缺失原因分析和解决方法》一文讲解的方法进行处理或者直接在微软官网下载Visual C++ Redistributable for Visual Studio 2015文件进行修复；如果是因为更新Windows的DirectX之后导致某些动态链接库文件缺失问题，可以下载一个DirectX修复工具进行修复。 Linux环境Linux环境自带了Python 2.x版本，但是如果要更新到3.x的版本，可以在Python的官方网站下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示（以CentOS为例）。 安装依赖库（因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败）。 yum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 下载Python源代码并解压缩到指定目录。 wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.6&#x2F;Python-3.7.6.tar.xz xz -d Python-3.7.6.tar.xz tar -xvf Python-3.7.6.tar 切换至Python源代码目录并执行下面的命令进行配置和安装。 cd Python-3.7.6 .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python37 --enable-optimizations make &amp;&amp; make install 修改用户主目录下名为.bash_profile的文件，配置PATH环境变量并使其生效。 cd ~ vim .bash_profile # ... 此处省略上面的代码 ... export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;python37&#x2F;bin # ... 此处省略下面的代码 ... 激活环境变量。 source .bash_profile macOS环境macOS也自带了Python 2.x版本，可以通过Python的官方网站提供的安装文件（pkg文件）安装Python 3.x的版本。默认安装完成后，可以通过在终端执行python命令来启动2.x版本的Python解释器，启动3.x版本的Python解释器需要执行python3命令。 运行Python程序确认Python的版本可以Windows的命令行提示符中键入下面的命令。 python --version 或者是在Linux或macOS系统的终端中键入下面的命令。 python3 --version 当然也可以先输入python或python3进入交互式环境，再执行以下的代码检查Python的版本。 import sys print(sys.version_info) print(sys.version) 编写Python源代码可以用文本编辑工具（推荐使用Sublime、Visual Studio Code等高级文本编辑工具）编写Python源代码并用py作为后缀名保存该文件，代码内容如下所示。 print(&#39;hello, world!&#39;) 运行程序切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了”hello, world!”。 python hello.py 或 python3 hello.py 代码中的注释注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。 单行注释 - 以#和空格开头的部分 多行注释 - 三个引号开头，三个引号结尾 &quot;&quot;&quot; 第一个Python程序 - hello, world! 向伟大的Dennis M. Ritchie先生致敬 Version: 0.1 Author: 骆昊 &quot;&quot;&quot; print(&#39;hello, world!&#39;) # print(&quot;你好,世界！&quot;) print(&#39;你好&#39;, &#39;世界&#39;) print(&#39;hello&#39;, &#39;world&#39;, sep&#x3D;&#39;, &#39;, end&#x3D;&#39;!&#39;) print(&#39;goodbye, world&#39;, end&#x3D;&#39;!\\n&#39;) Python开发工具IDLE - 自带的集成开发工具IDLE是安装Python环境时自带的集成开发工具，如下图所示。但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。 IPython - 更好的交互式编程工具IPython是一种基于Python的交互式解释器。相较于原生的Python交互式环境，IPython提供了更为强大的编辑和交互功能。可以通过Python的包管理工具pip安装IPython和Jupyter，具体的操作如下所示。 pip install ipython 或 pip3 install ipython 安装成功后，可以通过下面的ipython命令启动IPython，如下图所示。 Sublime Text - 高级文本编辑器 首先可以通过官方网站下载安装程序安装Sublime Text 3或Sublime Text 2。 安装包管理工具。 通过快捷键Ctrl+`或者在View菜单中选择Show Console打开控制台，输入下面的代码。 Sublime 3 import urllib.request,os;pf&#x3D;&#39;Package Control.sublime-package&#39;;ipp&#x3D;sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib.request.urlopen(&#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read()) Sublime 2 import urllib2,os;pf&#x3D;&#39;Package Control.sublime-package&#39;;ipp&#x3D;sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read());print(&#39;Please restart Sublime Text to finish installation&#39;) 在浏览器中输入 https://sublime.wbond.net/Package%20Control.sublime-package 下载包管理工具的安装包，并找到安装Sublime目录下名为&quot;Installed Packages&quot;的目录，把刚才下载的文件放到这个文件加下，然后重启Sublime Text就搞定了。 安装插件。通过Preference菜单的Package Control或快捷键Ctrl+Shift+P打开命令面板，在面板中输入Install Package就可以找到安装插件的工具，然后再查找需要的插件。我们推荐大家安装以下几个插件： SublimeCodeIntel - 代码自动补全工具插件。 Emmet - 前端开发代码模板插件。 Git - 版本控制工具插件。 Python PEP8 Autoformat - PEP8规范自动格式化插件。 ConvertToUTF8 - 将本地编码转换为UTF-8。 说明：事实上Visual Studio Code可能是更好的选择，它不用花钱并提供了更为完整和强大的功能，有兴趣的读者可以自行研究。 PyCharm - Python开发神器PyCharm的安装、配置和使用在《玩转PyCharm》进行了介绍，有兴趣的读者可以选择阅读。 练习 在Python交互式环境中输入下面的代码并查看结果，请尝试将看到的内容翻译成中文。 import this 说明：输入上面的代码，在Python的交互式环境中可以看到Tim Peter撰写的“Python之禅”，里面讲述的道理不仅仅适用于Python，也适用于其他编程语言。 学习使用turtle在屏幕上绘制图形。 说明：turtle是Python内置的一个非常有趣的模块，特别适合对计算机程序设计进行初体验的小伙伴，它最早是Logo语言的一部分，Logo语言是Wally Feurzig和Seymour Papert在1966发明的编程语言。 import turtle turtle.pensize(4) turtle.pencolor(&#39;red&#39;) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.right(90) turtle.forward(100) turtle.mainloop() 提示：本章提供的代码中还有画国旗和画小猪佩奇的代码，有兴趣的读者请自行研究。","path":"2021/05/06/chu-shi-python/","date":"05-06","excerpt":"","tags":[{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"}]},{"title":"扑克牌—红桃7","text":"尽可能做一些产品出来，并让他成为你的作品，有一个作品很重要，这是别人了解你的窗口。 如果可能，给自己开一个公众号或者一个博客，记录自己每天的见闻思考。刚开始记会很凌乱没有逻辑，但是坚持下去一定会有很大价值。","path":"2021/05/06/bu-ke-pai-hong-tao-7/","date":"05-06","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃6","text":"技术不是万能的，程序员也不是最厉害的，一定要搞清楚，不要觉得“老子天下第一”。一旦有了这个意识，可能会耽误你成长。技术是为了解决问题的，如果说一个技术不能解决问题，那这个技术就是一文不值。 不要去炫技，没有意义。","path":"2021/04/28/bu-ke-pai-hong-tao-6/","date":"04-28","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃5","text":"不要沉迷于一些技术细节，虽然这些细节很重要，但是如果因为这些细节浪费了很多时间，那么要及时地去找更厉害的人来帮助你。独立地解决问题，是一个优秀的品质，但是更快地解决问题是更重要的。","path":"2021/04/26/bu-ke-pai-hong-tao-5/","date":"04-26","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃4","text":"理性、客观、谨慎是程序员的特点，也是优点，但是很多时候我们也需要带一点感性，带一点冲动，这个时候可以帮助我们更快更好地做决策。 “悲观者正确，乐观者成功。”希望大家都是一个乐观地解决问题的人。","path":"2021/04/25/bu-ke-pai-hong-tao-4/","date":"04-25","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃3","text":"问题 = 机会，遇到问题的时候，内心其实是开心的，越大的问题意味着越大的机会。任何事情都是有代价的，有得必有失，有失必有得，所以不要计较很多东西，你要想清楚自己要什么，并且想清楚自己愿意为之付出什么代价，然后就去做吧。","path":"2021/04/22/bu-ke-pai-hong-tao-3/","date":"04-22","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃2","text":"我们中的大部分人所接触的身边人，都是跟自己同层次同认知水平，他们的建议与观点往往没啥太大的借鉴价值。要想办法进入一个优质的圈子，优质的圈子可以为你打开一个新世界的大门，可以让你快速获得别人多年摸索的经验，可以给你带来创业点子和需要的资源，长期来看，这种圈子对你的认知冲击和产生的影响是巨大的，它一定影响你接下来的整个人生，而且这样的圈子越早接触越好。","path":"2021/04/21/bu-ke-pai-hong-tao-2/","date":"04-21","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"扑克牌—红桃A","text":"技术的迭代会非常快，但是从技术中沉淀下来的思维却是受益终生的。所以不要担心什么中年危机，那些担心中年危机的人通常很难成长起来。只要你成长，只要你的认知在不断突破，就不用担心中年危机，这个世界始终是需要那些优秀的人才的。","path":"2021/04/20/bu-ke-pai-hong-tao-a/","date":"04-20","excerpt":"","tags":[{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"}]},{"title":"网格策略记录","text":"纯粹自己记录用的~","path":"2021/04/10/wang-ge-ce-lue-ji-lu/","date":"04-10","excerpt":"纯粹自己记录用的~","tags":[{"name":"理财","slug":"理财","permalink":"https://oxford561.github.io/tags/%E7%90%86%E8%B4%A2/"}]},{"title":"MarkDown语法文章示例","text":"这篇文章只是为了熟悉 MarkDown 语法而进行编写的，而且本身也只是在测试 Gridea 博客发布是否存在问题，后续进行其它文章编写的时候基本都是会参照这篇文章格式进行编写。 一、标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题二、字体这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线 五、图片![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”） 六、超链接简书百度 七、列表无序列表 列表内容 列表内容 列表内容 有序列表 列表内容 列表内容 列表内容 列表嵌套 一级无序列表 二级无序列表 二级无序列表 二级有序列表 二级有序列表 一级有序列表 八、表格 表头 表头 表头 内容 内容 内容 内容 内容 内容 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码function fun()&#123; print(&quot;hello world&quot;) &#125; 十、流程图st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp;```","path":"2021/04/08/markdown-yu-fa-wen-zhang-shi-li/","date":"04-08","excerpt":"这篇文章只是为了熟悉 MarkDown 语法而进行编写的，而且本身也只是在测试 Gridea 博客发布是否存在问题，后续进行其它文章编写的时候基本都是会参照这篇文章格式进行编写。","tags":[{"name":"文章测试","slug":"文章测试","permalink":"https://oxford561.github.io/tags/%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95/"}]},{"title":"关于","text":"欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站👨‍💻 博主是谁⛹ 兴趣爱好📬 联系我呀","path":"2019/01/25/about/","date":"01-25","excerpt":"","tags":[]},{"title":"Hello Gridea","text":"👏 欢迎使用 Gridea ！✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意… … GithubGridea 主页示例网站 特性👇📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~","path":"2018/12/12/hello-gridea/","date":"12-12","excerpt":"👏 欢迎使用 Gridea ！✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意… …","tags":[{"name":"Gridea","slug":"Gridea","permalink":"https://oxford561.github.io/tags/Gridea/"}]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://oxford561.github.io/tags/C/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://oxford561.github.io/tags/Leetcode/"},{"name":"C#","slug":"C","permalink":"https://oxford561.github.io/tags/C/"},{"name":"日记随笔","slug":"日记随笔","permalink":"https://oxford561.github.io/tags/%E6%97%A5%E8%AE%B0%E9%9A%8F%E7%AC%94/"},{"name":"扑克牌封面","slug":"扑克牌封面","permalink":"https://oxford561.github.io/tags/%E6%89%91%E5%85%8B%E7%89%8C%E5%B0%81%E9%9D%A2/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://oxford561.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Python教程","slug":"Python教程","permalink":"https://oxford561.github.io/tags/Python%E6%95%99%E7%A8%8B/"},{"name":"理财","slug":"理财","permalink":"https://oxford561.github.io/tags/%E7%90%86%E8%B4%A2/"},{"name":"文章测试","slug":"文章测试","permalink":"https://oxford561.github.io/tags/%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95/"},{"name":"Gridea","slug":"Gridea","permalink":"https://oxford561.github.io/tags/Gridea/"}]}